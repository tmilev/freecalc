\begin{frame}
\alertNoH{1}{Secr.: $\mathrm{secret}_1, \dots, \mathrm{secret}_n$, pub. keys: $\mathrm{pub}_1 = g^{ \mathrm{secret }_1 }, \dots, \mathrm{pub}_n= g^{\mathrm{secret}_n}$}.
\begin{emptyTheorem}[Zilliqa non-PBFT Schnorr multi-signature: preparation (once)]
\begin{itemize}
\item<2-> Select a special node called an aggregator.
\item<3-> Each signer: one-time send public key $\mathrm{pub}_i \stackrel{?}{=} g^{\mathrm{secret}_i}$.
\item<4-> Aggregator: send back challenge message to be signed.
\item<5-> Each signer: send signed challenge back.
\end{itemize}
\end{emptyTheorem}

\begin{itemize}
\item<6-> The preparation simply ensures each signer owns $\mathrm{secret}_i$ from which $\mathrm{pub}_i $ is computed. 
\item<7-> If preparation skipped: malicious signer can spoof public key by 
\[
\mathrm{pub}_i \cdot \prod_{j \in \mathcal V} \left(\mathrm{pub}_j \right)^{-1} 
\] 
allowing him to single-handedly fake the aggregate signature for himself and the victim nodes in the set $\mathcal V$. 
\end{itemize}
\vskip 15cm

\end{frame}

\begin{frame}
Secr.: $\mathrm{secret}_1, \dots, \mathrm{secret}_n$, pub. keys: $\mathrm{pub}_1 = g^{ \mathrm{secret }_1 }, \dots, \mathrm{pub}_n= g^{\mathrm{secret}_n}$.

\begin{emptyTheorem}[Zilliqa \fcCancel{3}{non-}PB\alertNoH{3,4}{FT} Schnorr aggregate signature: signing]
\begin{itemize}
\item<2-> \uncover<2->{Each signer:} choose random $\alertNoH{2}{ \mathrm{nonce}_i}$, compute $ \alertNoH{2}{q_i = g^{\mathrm{nonce}_i}} $.
\item<10-> Each signer: send $q_i$ to aggregator.  \uncover<3->{\alertNoH{3}{Let $\mathcal A$: set of healthy nodes.}}
\item<3-> \uncover<2->{Aggregator:} compute $ \mathrm{Pub} =\prod_{i \uncover<3->{ \alertNoH{3}{\in \mathcal A} }} \mathrm{pub}_i \uncover<-2>{=\mathrm{pub}_1\cdot \dots \cdot \mathrm{pub}_n}$. 
\item \uncover<2->{Aggregator:} compute $ Q = \prod_{i \uncover<3->{ \alertNoH{3}{\in \mathcal A} }} q_i$.
\item \uncover<2->{Aggregator:} compute  $\mathrm{challenge} = H(Q, \mathrm{Pub}, \mathrm{digest})$.
\item<2-> Aggregator: send $\mathrm{challenge},\mathrm{Pub}, \mathrm{digest}$ to signers. \uncover<3->{\alertNoH{3,4}{Bad net: reset.}}
\item<2-> Each signer: verify $\mathrm{challenge} = H(Q, \mathrm {Pub}, \mathrm{digest}) $.
\item \uncover<2->{Each signer:} compute $\mathrm{solution}_i = {\mathrm{nonce}_i - \mathrm{challenge} \cdot \mathrm{secret}_i} $.
\item<2-> Each signer: send $\mathrm{solution}_i$ to aggregator. \uncover<3->{\alertNoH{3,4}{Bad net: reset.}}
\item \uncover<2->{Aggregator:} compute $\mathrm{solution} = \sum_i \mathrm{solution}_i $.
\item \uncover<2->{Aggregator:} final signature: $(\mathrm{challenge}, \mathrm{solution}), \uncover<3->{\alertNoH{3}{\mathcal A}}$.
\end{itemize}
\end{emptyTheorem}
\vskip -0.15cm
\begin{itemize}
\item \uncover<3->{\alertNoH{3}{To make algorithm fault tolerant: add highlighted steps.}}
\item \uncover<4->{\alertNoH{4}{Requires black-listing bad actors from second net transaction on.}}
\end{itemize}
\vskip 15cm
\end{frame}

\begin{frame}
Secr.: $\mathrm{secret}_1, \dots, \mathrm{secret}_n$, pub. keys: $\mathrm{pub}_1 = g^{ \mathrm{secret }_1 }, \dots, \mathrm{pub}_n= g^{\mathrm{secret}_n}$.

\begin{emptyTheorem}[Zilliqa non-PBFT Schnorr aggregate signature: verification]
\begin{itemize}
\item Given: aggregate public key: $\mathrm{Pub} $, message: $\mathrm{digest}$, aggregate signature: $(\mathrm{challenge}, \mathrm{solution})$.

\vskip -0.25cm
\hfil\hfil$
\begin{array}{rcl}
\mathrm{Pub}&\stackrel{?}{=}& \prod_i \mathrm{pub}_i\\
\mathrm{challenge} &\stackrel{?}{=}& H\left( \prod_i g^{\mathrm{nonce}_i}, \mathrm{Pub}, \mathrm{digest} \right) = H\left( g^{\sum_i \mathrm{nonce}_i}, \mathrm{Pub}, \mathrm{digest} \right)  \\
\mathrm{solution} &\stackrel{?}{=}& \sum _i \left(\mathrm{nonce}_i - \mathrm{challenge}\cdot \mathrm{secret}_i \right)
\end{array}
$
\item Compute

\noindent $\hskip -1cm
\begin{array}{r@{}c@{}l} 
X&{=}&\displaystyle g^{\mathrm{solution} } \mathrm{Pub}^{\mathrm{challenge}}\stackrel{?}{=} \displaystyle g^{\mathrm{solution}} \left(\prod_i \mathrm{pub}_i\right)^{\!\!\!\!\mathrm{challenge}} 
\!\!\!\!\!\!\!\!\!\!\! =\displaystyle  g^{\mathrm{solution}} \left(\prod_i g^{\mathrm{secret}_i}\right)^{\!\!\!\!\mathrm{challenge}}\\
&=&\displaystyle g^{\mathrm{solution}}\prod_i g^{\mathrm{secret}_i\cdot \mathrm{challenge}}= \displaystyle g^{\sum_i \left(\mathrm{nonce}_i - \mathrm{secret}_i\mathrm{challenge}\right)} g^ { \sum_i \mathrm{secret}_i\cdot \mathrm{challenge} }\\
&=&\displaystyle g^{\sum_i \left(\mathrm{nonce}_i - \mathrm{secret}_i\mathrm{challenge}\right)+ \sum_i \mathrm{secret}_i\cdot \mathrm{challenge} }=g^{\sum_i\mathrm{nonce}_i}.
\end{array}
$
\item If $H\left(X, \mathrm{Pub}, \mathrm{digest}\right) = \mathrm{challenge}$  signature - valid (otherwise invalid).
\end{itemize}
\end{emptyTheorem}

\vskip 15cm
\end{frame}