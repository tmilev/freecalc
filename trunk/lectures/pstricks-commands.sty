\ProvidesPackage{pstricks-commands}
\usepackage{etex, ifthen}
\usepackage [dvips={-o -Ppdf}, pspdf={-dNOSAFER -dAutoRotatePages=/None}, pdfcrop={}]
{auto-pst-pdf}
\usepackage{pst-plot}
\usepackage{pst-math}
%WARNING THE FOLLOWING PACKAGE IS BROKEN use only with EXTREME CAUTION
%\usepackage{pst-3dplot}

\makeatletter
\begingroup
\catcode `P=12  % digits and punct. catcode
\catcode `T=12  % digits and punct. catcode
\lowercase{%
\def\x{\def\rem@pt##1.##2PT{##1\ifnum##2>\z@.##2\fi}}}
\expandafter\endgroup\x%
\newcommand{\stripPoints}[1]{\expandafter\rem@pt\the#1}
\makeatother

\newcommand{\fcShiftX}{0}
\newcommand{\fcShiftY}{0}
\newcommand{\fcXLabel}{$x$}
\newcommand{\fcYLabel}{$y$}
\newcommand{\fcZLabel}{$z$}
\newcommand{\fcDelta}{0.5}
\newcommand{\fcZBufferNumXIntervals}{20}
\newcommand{\fcZBufferNumYIntervals}{20}
\newcommand{\fcZBufferRowColumnsUnderInvestigation}{(empty) (empty)}
\newcommand{\fcZBufferUparameterPointUnderInvestigation}{(empty) (empty)}
\newcommand{\fcZBufferVparameterPointUnderInvestigation}{(empty) (empty)}
%\newcommand{\fcContourDebugged}{-1}
\newcommand{\fcStartXIId}{0}
\newcommand{\fcStartYIId}{0}
\newcommand{\fcIterationsX}{9\space}
\newcommand{\fcIterationsY}{9\space}
\newcommand{\fcIterationsU}{9\space}
\newcommand{\fcIterationsV}{9\space}
\newcommand{\fcNumCountourSegmentsPatchU}{10\space}
\newcommand{\fcNumCountourSegmentsPatchV}{10\space}
\newcommand{\fcScreenStyle}{z}
\newcommand{\fcColorLine}{black}
\newcommand{\fcForceForeground}{false}
\newcommand{\fcLineWidth}{1}
\newcommand{\fcScale}{1\space}
\newcommand{\fcArrows}{}
\newcommand{\fcPlotPoints}{200}
\newcommand{\fcLineStyle}{0}
\newcommand{\fcDashLength}{2}
\newcommand{\fcColorPatchUV}{1 0.5 0.5}
\newcommand{\fcColorPatchVU}{0.7 0.2 0.2}
\newcommand{\fcFastPatchSort}{false}
\newcommand{\fcDashesCode}{%
(\fcLineStyle) (dashed) eq %
{[\fcDashLength\space \fcDashLength] 0 setdash}%
{[] 0 setdash}%
ifelse\space %
}
\newcommand{\fcScreen}{[-1 1 -0.5] -1} %default projection plane. Renew this command to change projection plane.

\newcommand{\fcSet}[1]{\setkeys{fcGraphics}{#1}}

\makeatletter %needed for define@key command.
\define@key{pstricks,pst-plot}{xLabel}[]{}
\define@key{pstricks,pst-plot}{yLabel}[]{}
\define@key{pstricks,pst-plot}{zLabel}[]{}
\define@key{fcGraphics}{Delta}[\renewcommand{\fcDelta}{1}]{\renewcommand{\fcDelta}{#1}}
\define@key{fcGraphics}{shiftX}[\renewcommand{\fcShiftX}{0}]{\renewcommand{\fcShiftX}{#1}}
\define@key{fcGraphics}{shiftY}[\renewcommand{\fcShiftY}{0}]{\renewcommand{\fcShiftY}{#1}}
\define@key{fcGraphics}{startX}[\renewcommand{\fcStartXIId}{0}]{\renewcommand{\fcStartXIId}{#1}}
\define@key{fcGraphics}{startY}[\renewcommand{\fcStartYIId}{0}]{\renewcommand{\fcStartYIId}{#1}}
\define@key{fcGraphics}{colorUV}[\renewcommand{\fcColorPatchUV}{1 0.5 0.5}]{\renewcommand{\fcColorPatchUV}{#1\space}}
\define@key{fcGraphics}{colorVU}[\renewcommand{\fcColorPatchVU}{0.7 0.2 0.2}]{\renewcommand{\fcColorPatchVU}{#1\space}}
\define@key{fcGraphics}{iterationsU}[\renewcommand{\fcIterationsU}{9\space}]{\renewcommand{\fcIterationsU}{#1\space}}
\define@key{fcGraphics}{iterationsV}[\renewcommand{\fcIterationsU}{9\space}]{\renewcommand{\fcIterationsV}{#1\space}}
\define@key{fcGraphics}{forceForeground}[\renewcommand{\fcForceForeground}{false\space}]{\renewcommand{\fcForceForeground}{#1\space}}
\define@key{fcGraphics}{iterationsX}[\renewcommand{\fcIterationsX}{9\space}]{\renewcommand{\fcIterationsX}{#1\space}}
\define@key{fcGraphics}{scale}[\renewcommand{\fcScale}{1}]{\renewcommand{\fcScale}{#1\space}}
%\define@key{fcGraphics}{debugContour}[\renewcommand{\fcContourDebugged}{-1\space}]{\renewcommand{\fcContourDebugged}{#1\space}}
\define@key{fcGraphics}{iterationsY}[\renewcommand{\fcIterationsY}{9\space}]{\renewcommand{\fcIterationsY}{#1\space}}
\define@key{fcGraphics}{screenStyle}[\renewcommand{\fcScreenStyle}{z}]{\renewcommand{\fcScreenStyle}{#1}}
\define@key{fcGraphics}{xLabel}[\renewcommand{\fcXLabel}{$x$}]{\renewcommand{\fcXLabel}{#1}}
\define@key{fcGraphics}{yLabel}[\renewcommand{\fcYLabel}{$y$}]{\renewcommand{\fcYLabel}{#1}}
\define@key{fcGraphics}{zLabel}[\renewcommand{\fcZLabel}{$z$}]{\renewcommand{\fcZLabel}{#1}}
\define@key{fcGraphics}{linecolor}[\renewcommand{\fcColorLine}{black}]{\renewcommand{\fcColorLine}{#1}}
\define@key{fcGraphics}{linewidth}[\renewcommand{\fcLineWidth}{1}]{\renewcommand{\fcLineWidth}{#1}}
\define@key{fcGraphics}{linestyle}[\renewcommand{\fcLineStyle}{0}]{\renewcommand{\fcLineStyle}{#1}}
\define@key{fcGraphics}{linestyle}[\renewcommand{\fcLineStyle}{0}]{\renewcommand{\fcLineStyle}{#1}}
\define@key{fcGraphics}{fastsort}[\renewcommand{\fcFastPatchSort}{false}]{\renewcommand{\fcFastPatchSort}{#1}}
\define@key{fcGraphics}{dashes}[\renewcommand{\fcDashLength}{300}]{\renewcommand{\fcDashLength}{#1 \fcConvertPSXUnit\space}}
\define@key{fcGraphics}{arrows}[\renewcommand{\fcArrows}{}]{\renewcommand{\fcArrows}{#1}}
\makeatother %undoes \makeatletter.


\newcommand{\fcHollowDot}[2]{
\pscircle*[fillcolor=white, linecolor=red](#1, #2){0.07}
\pscircle*[fillcolor=white, linecolor=white](#1, #2){0.04}
}

\newcommand{\fcFullDot}[3][linecolor=red]{
\setkeys{fcGraphics}{#1}
\pscircle*[#1](! #2 #3){! 0.07 \fcScale\space mul}
}

\newcommand{\fcFullDotCode}{
gsave
\fcCoordsPStricksToPS [0.02 0] \fcCoordsPStricksToPS pop 0 360 arc 1 0 0 setrgbcolor fill stroke
grestore
}

\newcommand{\fcHollowDotCode}{
gsave
\fcCoordsPStricksToPS [0.04 0] \fcCoordsPStricksToPS pop 0 360 arc 0 1 0 setrgbcolor stroke
grestore
}

\newcommand{\fcHashString}{
2 dict begin
/theString exch def
/counter -1 def
0
theString length {
/counter counter 1 add def
theString counter get cvi counter 1 add mul add
}repeat
20 string cvs
end
}

\newcommand{\fcToString}{
%(tostring function) ==
1 dict begin
/ToString
{
5 dict begin 
cvlit
/theData exch def
theData type (arraytype) eq{
([)
theData{ToString ( )} forall 
(])
theData length 2 mul 2 add \fcConcatenateMultiple
}
{theData 20 string cvs}
ifelse
end
} def %
ToString
end\space
}

\newcommand{\fcConcatenate}{ %Code taken from stackexchange, many thanks!
exch dup length 
2 index length add string    
dup dup 4 2 roll copy length
4 -1 roll putinterval 
}

\newcommand{\fcConcatenateMultiple}{ %Code taken from stackexchange, many thanks!
%Usage: (s1) (s2) (s3) ... (sN) n  \fcConcatenateMultiple  (s1s2s3...sN)
% s1 s2 s3 .. sN n                   % first sum the lengths
dup 1 add  % s1 s2 s3 .. sN n n+1 
copy       % s1 s2 s3 .. sN n  s1 s2 s3 .. sN n
0 exch     % s1 s2 s3 .. sN n  s1 s2 s3 .. sN 0 n 
{exch length add} repeat % s1 s2 s3 .. sN  n   len  % then allocate string
string exch          % s1 s2 s3 .. sN str   n   
0 exch               % s1 s2 s3 .. sN str  off  n
-1 1 {               % s1 s2 s3 .. sN str  off  n  % copy each string
  2 add -1 roll       % s2 s3 .. sN str  off s1  % bottom to top
  3 copy putinterval  % s2 s3 .. sN str' off s1
  length add          % s2 s3 .. sN str' off+len(s1)
                      % s2 s3 .. sN str' off'
} for                               % str' off'
pop  % str'
}

\newcommand{\fcRectangularRiemannSumCode}{
/theRiemannSumFigure exch def
theRiemannSumFigure \fcSetupFiles
graphicsCached not{
theRiemannSumFigure \fcArrayToStack
20 dict begin
/theFunction exch def
/yIterations exch def
/xIterations exch def
/yMax exch def
/xMax exch def
/yMin exch def
/xMin exch def
/DeltaX xMax xMin sub xIterations div def
/DeltaY yMax yMin sub yIterations div def
/theSideColor exch def
/theContourColor exch def
/x xMin def
xIterations{
/y yMin def
yIterations{
/xOld x def
/yOld y def
/x x DeltaX 2 div add def
/y y DeltaY 2 div add def
/z theFunction def
[xOld yOld 0]
[xOld DeltaX add yOld 0]
[xOld yOld DeltaY add 0]
[xOld yOld z]
theContourColor
theSideColor
\fcBoxIIIdFilledCode
/x xOld def
/y yOld DeltaY add def
}repeat
/x x DeltaX add def
}repeat
end
}if
}

\newcommand{\fcRectangularRiemannSum}[8][]{
\setkeys{fcGraphics}{#1}
\pscustom{%
\code{%
[[\fcGetColorCode{\fcColorLine}] [\fcGetColorCode{\fcColorPatchUV}]  #2\space #3\space #4\space #5 \space #6\space #7\space {#8}\space]
\fcRectangularRiemannSumCode
}%
}%
}

\newcommand{\fcTextCode}{
/Times-Roman findfont
4 scalefont
setfont
newpath
\fcCoordsPStricksToPS moveto
show
stroke
}

\newcommand{\fcHollowDotBlue}[2]{
\pscircle*[fillcolor=white, linecolor=blue](#1, #2){0.07}
\pscircle*[fillcolor=white, linecolor=white](#1, #2){0.04}
}
\newcommand{\fcFullDotBlack}[2]{
\pscircle*[fillcolor=white, linecolor=black](#1, #2){0.07}
}
\newcommand{\fcFullDotBlue}[2]{
\pscircle*[fillcolor=white, linecolor=blue](#1, #2){0.07}
}
\newcommand{\fcXTickColored}[2]{\psline[linecolor=#1](#2, -0.1)(#2,0.1)}

\newcommand{\fcXTick}[1]{\psline(! #1\space -0.1)(! #1 \space 0.1)}
\newcommand{\fcYTick}[1]{\psline(! -0.1 #1)(! 0.1 #1)}
\newcommand{\fcXYTick}[2]{\fcXTick{#1} \fcYTick{#2}}

\newcommand{\fcXTickWithLabel}[2]{\fcXTick{#1}\rput[t](! #1\space -0.2){#2}}
\newcommand{\fcYTickWithLabel}[2]{\fcYTick{#1}\rput[r](! -0.2 #1){#2}}

\newcommand{\fcLabelNumberXaxis}[1]{\fcXTickWithLabel{#1}{#1}}
\newcommand{\fcLabelNumberYaxis}[1]{\fcYTickWithLabel{#1}{#1}}

\newcommand{\fcLabelNumberXYaxes}[2]{\fcLabelNumberXaxis{#1} \fcLabelNumberYaxis{#2} }

\newcommand{\fcLabelXOne}{\fcLabelNumberXaxis{1} }
\newcommand{\fcLabelYOne}{\fcLabelNumberYaxis{1} }

\newcommand{\fcLabelOnXaxis}[2]{\fcXTick{#1}\rput[t](#1,-0.2){#2}}
\newcommand{\fcLabelOnYaxis}[2]{\fcYTick{#1}\rput[r](-0.2, #1){#2}}

\newcommand{\fcLabels}[1][$x$]{%
  \def\ArgpsXAxisLabel{{#1}}%
  \fcLabelsRelay
}
\newcommand\fcLabelsRelay[3][$y$]{\rput[t](! #2 -0.1){\ArgpsXAxisLabel}\rput[r](! -0.1 #3){#1}}

\newcommand{\fcLabelsWithOnes}[2]{\psline(1, -0.1)(1,0.1) \rput[t](1, -0.2 ) { $1$} \psline(-0.1, 1)(0.1, 1) \rput[r](-0.2, 1 ) { $1$} \fcLabels{#1}{#2}}

\newcommand{\fcDefaultXLabel}{$x$}
\newcommand{\fcDefaultYLabel}{$y$}

\newcommand{\fcBoundingBox}[4]{%
\psframe*[linecolor=white](! #1\space #2)(! #3\space #4)%
\psline[linecolor=black!1](! #1 #2 )(! #1 #2 0.01 add)%
\psline[linecolor=black!1](! #3 #4 )(! #3 #4 0.01 add)%
}
\newcommand{\fcAxesStandardNoFrame}[4]{%
\psaxes[ticks=none, labels=none]{<->}(0,0)(#1,#2)(#3,#4)% \fcLabels[\fcDefaultXLabel][\fcDefaultYLabel]{#3}{#4}%
}%

\newcommand{\fcAxesStandard}[4]{%
\psframe*[linecolor=white](! #1\space #2)(! #3 \space 0.1 add #4 \space 0.1 add)%
\fcAxesStandardNoFrame{#1}{#2}{#3}{#4}%
}%
\newcommand{\fcColorTangent}{blue}
\newcommand{\fcColorGraph}{red}
\newcommand{\fcColorAreaUnderGraph}{cyan}
\newcommand{\fcColorNegativeAreaUnderGraph}{orange}

\newcommand{\fcMachine}[2]{
\pscustom*[linecolor=#2]{
\psline(1,1.1)(1,0.1)(1.5,0.1)(2, 0.6)(2.5, 0.6)(2.5, -0.6)(2, -0.6)(1.5,-0.1)(1,-0.1)(1,-1.1)(-1,-1.1)(-1,-0.1)(-1.5,-0.1)(-2, -0.6)(-2.5, -0.6)(-2.5, 0.6)(-2, 0.6)(-1.5,0.1)(-1,0.1)(-1,1.1)
}
\pscircle*[linecolor=white](0,0){0.3}
\rput(0,0){#1}
}

%command format
%first argument gives you formula for the direction field in
%postscript notation, for example x y add.
%second and third argument give the starting x,y coordinates
\newcommand{\fcDirectionFieldOneTangent}[6]{%
\pstVerb{%
3 dict begin%
/x #2 \space def%
/y #3 \space def%
/F #1 \space def%
}%
\psline[#6](! x F ATAN 57.295 mul cos #4 mul sub y F ATAN 57.295 mul sin #4 mul sub)(! x F ATAN 57.295 mul cos #4 mul add y F ATAN 57.295 mul sin #4 mul add)%
\pscircle*[linecolor=red!60](! x y){#5}%
\pstVerb{%
end%
}%
}

\newcommand{\fcDirectionFieldOneTangentDefault}[3]{%
\fcDirectionFieldOneTangent{#1}{#2}{#3}{0.3}{0.03}{linecolor=blue}%
}

%command format
%first argument gives you formula for the direction field in
%postscript notation, for example x y add.
%second and third argument give the starting x,y coordinates
%fourth coordinate gives the delta x=delta y
%fifth argument gives the number of iterations delta x
%sixth argument gives the number of iterations delta y
%seventh argument gives the length of the vector
%eighth  argument gives the circle radius
%ninth argument gives the arguments of the psline command
\newcommand{\fcDirectionFieldFull}[9]{%
\multido{\ra=#2+#4}{#5}{%
\multido{\rb=#3+#4}{#6}{%
\fcDirectionFieldOneTangent{#1}{\ra}{\rb}{#7}{#8}{#9}%
}%end multido
}%end multido
}%end newcommand

\newcommand{\fcDirectionFieldDefault}[5]{%
\fcDirectionFieldFull{#1}{#2}{#3}{#4}{#5}{#5}{0.2}{0.02}{linecolor=blue}%
}%
\newcommand{\fcDirectionFieldDefaultRange}[1]{%
\fcDirectionFieldFull{#1}{-4}{-4}{0.5}{21}{21}{0.2}{0.02}{linecolor=blue}%
}

\newcommand{\fcMatrixTimesMatrix}{
10 dict begin
/matrixRight exch def
/matrixLeft exch def
/rowCounter -1 def
[
matrixLeft length {
/rowCounter rowCounter 1 add def
/columnCounter -1 def
[
matrixRight 0 get length{
/columnCounter columnCounter 1 add def
/thirdCounter -1 def
/accum 0 def
matrixLeft rowCounter get length{
/thirdCounter thirdCounter 1 add def
/accum accum
matrixLeft rowCounter get thirdCounter get 
matrixRight thirdCounter get columnCounter get
mul add def
}repeat
accum
}repeat
]
}repeat
]
end
}

\newcommand{\fcMatrixTimesVector}{
10 dict begin
/theVector exch def
/theMatrix exch def
/rowCounter -1 def
[
theMatrix length {
/rowCounter rowCounter 1 add def
/columnCounter -1 def
/accum 0 def
theVector length{
/columnCounter columnCounter 1 add def
/accum accum 
theMatrix rowCounter get columnCounter get theVector columnCounter get mul 
add def
}repeat
accum
}repeat
]
end
}

\newcommand{\fcVectorProjectOntoVector}{%
\fcVectorNormalize dup 3 1 roll \fcVectorScalarVector \fcVectorTimesScalar%
} %

%fcAngleIIId Arguments:
%first optional: pstricks options
%second: vector describing arm of first angle
%third: vector describing arm of second angle
%fourth: radius of arc representing the angle
\newcommand{\fcAngleIIId}[4][]{%
\pstVerb{%
3 dict begin%
/firstV #2 \fcVectorNormalize def%
/orthonormalV #3 dup firstV  \fcVectorProjectOntoVector \fcVectorMinusVector \fcVectorNormalize def%
/theAngle firstV #3\space \fcVectorNormalize \fcVectorScalarVector arccos def%
}%
\parametricplot[#1]{0}{theAngle}{firstV t cos #4 mul \fcVectorTimesScalar orthonormalV t sin #4 mul \fcVectorTimesScalar \fcVectorPlusVector \fcCoordsIIIdToPStricks}%
\pstVerb{end}%
}

\makeatletter
\newcommand{\fcAngle}[5][linecolor=\fcColorGraph]{%
\ifPst@algebraic{%
\parametricplot[#1, algebraic=true]{#2}{#3}{#4*cos(t)| #4*sin(t)}%
\rput(! #2\space #3\space add 2 div 57.29578 mul cos #4\space 0.2 add mul #2\space #3\space add 2 div 57.29578 mul sin #4\space 0.2 add mul){#5}%
}%
\else%
\parametricplot[#1, algebraic=false]{#2}{#3}{t 57.29578 mul cos #4\space mul t 57.29578 mul sin #4\space mul}%
\rput(! #2\space #3\space add 2 div 57.29578 mul cos #4\space 0.2 add mul #2\space #3\space add 2 div 57.29578 mul sin #4\space 0.2 add mul){#5}%
\fi%
}
\makeatother

\newcommand{\fcDistance}{ \fcVectorMinusVector \fcVectorNorm\space}

\newcommand{\fcLengthIndicator}[5]{
\psline[arrows=<-, linecolor=red](! #1 #2)(! #1 0.58 mul #3 0.42 mul add #2 0.58 mul #4 0.42 mul add)
\psline[arrows=->, linecolor=red]{->}(! #1 0.42 mul #3 0.58 mul add #2 0.42 mul #4 0.58 mul add)(! #3 #4)
\rput(! #1 #3 add 0.5 mul #2 #4 add 0.5 mul){ #5}
}

\makeatletter
\newcommand{\fcDrawPolar}[4][linecolor=\fcColorGraph]{%
\ifPst@algebraic{%
\parametricplot[#1]{#2}{#3}{(#4) *cos(t) | (#4) * sin(t)}%
}%
\else%
\parametricplot[#1]{#2}{#3}{#4 t 57.29578 mul cos mul #4 t 57.29578 mul sin mul}%
\fi%
}
\makeatother

\newcommand{\fcPolarCurveEvaluateX}[2]{
1 dict begin /t #1 def #1 57.29578 mul cos #2 mul end
}

\newcommand{\fcPolarCurveEvaluateY}[2]{
1 dict begin /t #1 def #1 57.29578 mul sin #2 mul end
}

\newcommand{\fcPolarCurveEvaluateXY}[2]{
\fcPolarCurveEvaluateX{#1}{#2} \fcPolarCurveEvaluateY{#1}{#2}
}

\newcommand{\fcPolarWedge}[3]{%
\ifPst@algebraic{%
\rput(0,0){Set algebraic to FALSE}%
}%
\else%
\pstVerb{%
%/firstX 1 dict begin /t #1 def #1 57.29578 mul sin #2 mul end def%
/firstX \fcPolarCurveEvaluateX{#1}{#3} def%
/firstY \fcPolarCurveEvaluateY{#1}{#3} def%
/secondX \fcPolarCurveEvaluateX{#2}{#3} def%
/secondY \fcPolarCurveEvaluateY{#2}{#3} def%
}%
\pscustom[fillcolor=\fcColorAreaUnderGraph, fillstyle=solid, linecolor=blue]{%
\psline(0,0)(! \fcPolarCurveEvaluateXY{#1}{#3} )(! \fcPolarCurveEvaluateXY{#2}{#3})(0,0)%
}%
\fi%
}%

\newcommand{\fcPolarWedgeSequence}[4]{%
\multido{\ra=#1+#2}{#3}{%
\fcPolarWedge{\ra}{\ra\space #2 add}{#4}
}%
}

\newcommand{\fcRegularNgon}[3][linecolor=\fcColorGraph]{%
\multido{\ra=0+1}{#2}{%
\psline[#1](! \ra \space #2 div 360 mul cos #3 mul \ra \space #2 div 360 mul sin #3 mul)(! \ra \space 1 add #2 div 360 mul cos #3 mul \ra \space 1 add #2 div 360 mul sin #3 mul)%
}%end multido
}

\newcommand{\fcEvaluateT}[2]{%
1 dict begin /t #1 def #2 end
}

\newcommand{\fcPolylineAlongCurve}[5][linecolor=\fcColorGraph]{%
\multido{\ra=0+1}{#2}{%
\psline[#1](! \fcEvaluateT{\ra\space #2 div #3 mul 1 \ra \space #2 div sub #4 mul add}{#5})(! \fcEvaluateT{\ra\space 1 add #2 div #3 mul 1 \ra \space 1 add #2 div sub #4 mul add}{#5})%
\rput(! \fcEvaluateT{\ra\space #2 div #3 mul 1 \ra \space #2 div sub #4 mul add}{#5}){\fcFullDot{0}{0}}%
}%
\rput(! \fcEvaluateT{#3}{#5}){\fcFullDot{0}{0}}%
}

\newcommand{\fcPolylineAlongCurveWithLabels}[6][linecolor=\fcColorGraph]{%
\fcPolylineAlongCurve[#1]{#2}{#3}{#4}{#5}%
\multido{\ia=0+1}{#2}{%
\rput[b](! \fcEvaluateT{\ia\space #2 div #3 mul 1 \ia \space #2 div sub #4 mul add}{#5} 0.1 add){${#6}_{\ia}$}%
}%
\rput[b](! \fcEvaluateT{#3}{#5}){${#6}_{#2}$}%
}

\newcommand{\fcVectorNormalize}{ %
1 dict begin %
/theV exch def % theV is our vector
theV 1 theV \fcVectorNorm div \fcVectorTimesScalar %
end %
} %pushes elements of array onto the stack

\newcommand{\fcArrayToStack}{ %
aload pop
} %pushes elements of array onto the stack

\newcommand{\fcSpliceArrayOperationArray}{ %
5 dict begin %
/theOp exch def %
/secondV exch def %
/firstV exch def %
/counter 0 def %
/dimension firstV length def %
[dimension {firstV counter get secondV counter get theOp /counter counter 1 add def } repeat] %
end %
} %splices two arrays and operation, for example [a b] [c d] {op} -> [a c op b d op]

\newcommand{\fcSpliceArrayOperation}{ %
4 dict begin %
/theOp exch def %
/firstV exch def %
/counter 0 def %
/dimension firstV length def %
[ dimension {firstV counter get theOp /counter counter 1 add def } repeat ] %
end %
} %splices array with operation. [a b] {op} -> [a op b op]

\newcommand{\fcArrayOperation}{ %
4 dict begin %
/theOp exch def %
/firstV exch def %
/counter 0 def%
/dimension firstV length def %
dimension {firstV counter get /counter counter 1 add def} repeat %
dimension 1 sub {theOp} repeat %
end %
} %applies operation n-1 times to array. Example: [a b c] {op} -> a b c op op

\newcommand{\fcVectorScalarVector}{%
{mul} \fcSpliceArrayOperationArray {add}\fcArrayOperation
} %Scalar product two vectors

\newcommand{\fcVectorPlusVector}{%
{add} \fcSpliceArrayOperationArray %
} %Adds two vectors

\newcommand{\fcVectorMinusVector}{%
{sub} \fcSpliceArrayOperationArray %
} %Adds two vectors

\newcommand{\fcVectorTimesScalar}{ %
2 dict begin %
/theScalar exch def %
/theV exch def %
theV {theScalar mul} \fcSpliceArrayOperation %
end %
} %

\newcommand{\fcVectorTripleProduct}{%
\fcVectorCrossVector \fcVectorScalarVector\space %
}

\newcommand{\fcVectorCrossVector}{ %
8 dict begin %
/vectB exch def %
/vectA exch def %
vectA \fcArrayToStack %
/a3 exch def %The three coordinates of Vector a
/a2 exch def %
/a1 exch def %
vectB \fcArrayToStack %
/b3 exch def %The three coordinates of Vector b
/b2 exch def %
/b1 exch def %
[a2 b3 mul a3 b2 mul sub a3 b1 mul a1 b3 mul sub a1 b2 mul a2 b1 mul sub] %the cross product of a and b
end %
}

\newcommand{\fcVectorNorm}{%
dup \fcVectorScalarVector sqrt %
} %

\newcommand{\fcVectorNormSquared}{%
dup \fcVectorScalarVector %
} %

\newcommand{\fcMarkClean}{
mark\space
}

\newcommand{\fcMarkCleanCheck}{
counttomark 0 ne {(ERROR: procedure did not clean up properly. Printing stack: ) print pstack == error}if pop
}

\newcommand{\fcProjectOntoScreen}{%
%(calling project onto plane with arguments:) == %
%dup == %
3 dict begin %
\fcScreen\space %
/theD exch def %
/theNormal exch def %
/theV exch def %
theV theNormal theD theV theNormal \fcVectorScalarVector sub theNormal \fcVectorNormSquared div \fcVectorTimesScalar \fcVectorPlusVector %
end %
} %Projection of point onto a plane. First argument is point, second argument is plane normal, third argument is the scalar product you need to have with the normal to be in the plane. Format: [1 2 3] [4 5 6] 7, corresponds to projecting the point (1,2,3) onto the plane 4x+5y+6z=7

\newcommand{\fcCoordsIIIdToPStricks}{%
5 dict begin %
/theV exch def %
/theVprojected theV \fcProjectOntoScreen [0 0 0] \fcProjectOntoScreen  \fcVectorMinusVector def%
/theNormalizedNormal \fcScreen\space pop \fcVectorNormalize def %
(\fcScreenStyle) (z) eq %
{ %
/theYUnitV [0 0 1] \fcProjectOntoScreen [0 0 0] \fcProjectOntoScreen \fcVectorMinusVector \fcVectorNormalize def %
/theXUnitV theNormalizedNormal theYUnitV \fcVectorCrossVector def %
} %
{ %
(\fcScreenStyle) (x) eq %
{
/theXUnitV [1 0 0] \fcProjectOntoScreen [0 0 0] \fcProjectOntoScreen \fcVectorMinusVector \fcVectorNormalize def %
/theYUnitV theXUnitV theNormalizedNormal \fcVectorCrossVector def%
}
{
/theYUnitV \fcScreenStyle \fcProjectOntoScreen [0 0 0] \fcProjectOntoScreen \fcVectorMinusVector \fcVectorNormalize def%
/theXUnitV theNormalizedNormal theYUnitV \fcVectorCrossVector def%
} ifelse%
}%
ifelse %
%(normalized normal: ) == theNormalizedNormal ==
%(y unit v) == theYUnitV ==
%(x unit v: ) == theXUnitV ==
theVprojected theXUnitV \fcVectorScalarVector theVprojected theYUnitV \fcVectorScalarVector
end %
}

\newcommand{\fcCoordsIIIdToPS}{%
[ exch \fcCoordsIIIdToPStricks ] \fcCoordsPStricksToPS
}

\newcommand{\fcBoxIIId}[5][]{%
\pstVerb{%
4 dict begin%
/visibleCorner #2 def%
/vectorOne #3 #2 \fcVectorMinusVector def%
/vectorTwo #4 #2 \fcVectorMinusVector def%
/vectorThree #5 #2 \fcVectorMinusVector def%
}%
\fcPolyLineIIId[#1]{visibleCorner dup vectorOne \fcVectorPlusVector dup vectorTwo \fcVectorPlusVector dup vectorOne \fcVectorMinusVector dup vectorTwo \fcVectorMinusVector visibleCorner}%
\fcPolyLineIIId[#1]{visibleCorner dup vectorOne \fcVectorPlusVector dup vectorThree \fcVectorPlusVector dup vectorOne \fcVectorMinusVector dup vectorThree \fcVectorMinusVector}%
\fcPolyLineIIId[#1]{visibleCorner vectorTwo \fcVectorPlusVector dup vectorThree \fcVectorPlusVector dup vectorTwo \fcVectorMinusVector}%
\fcPolyLineIIId[#1, linestyle=dashed]{visibleCorner vectorOne  vectorTwo vectorThree \fcVectorPlusVector \fcVectorPlusVector \fcVectorPlusVector dup vectorOne \fcVectorMinusVector}%
\fcPolyLineIIId[#1, linestyle=dashed]{visibleCorner vectorOne  vectorTwo vectorThree \fcVectorPlusVector \fcVectorPlusVector \fcVectorPlusVector dup vectorTwo \fcVectorMinusVector}%
\fcPolyLineIIId[#1, linestyle=dashed]{visibleCorner vectorOne  vectorTwo vectorThree \fcVectorPlusVector \fcVectorPlusVector \fcVectorPlusVector dup vectorThree \fcVectorMinusVector}%
\pstVerb{end}%
}

\newcommand{\fcParallelogramIIIdCode}{
4 dict begin
/v2 exch def
/v1 exch def
/v0 exch def
/secondRun false def
2 {
newpath 
v0 \fcCoordsPStricksToPS moveto
v0 v1 \fcVectorPlusVector \fcCoordsPStricksToPS lineto
v0 v1 v2 \fcVectorPlusVector \fcVectorPlusVector \fcCoordsPStricksToPS lineto
v0 v2 \fcVectorPlusVector \fcCoordsPStricksToPS lineto
v0 \fcCoordsPStricksToPS lineto
closepath
secondRun not {fill} if
stroke
/secondRun true def
}repeat
end
}

\newcommand{\fcPatchMakeFromThreeCorners}{
5 dict begin 
/options exch def
/v2 exch def
/v1 exch def 
/v0 exch def
/v3 v1 v2 \fcVectorPlusVector v0 \fcVectorMinusVector def
[v0 v1 v2 v3 [v0 v1 v3 v2 v0] options]
end
}

\newcommand{\fcZDepth}{
\fcScreen\space pop \fcVectorScalarVector
}

\newcommand{\fcBoxIIIdFilledCode}{ 
%input order
% corner0 corner1 corner2 corner3
15 dict begin
/colorSides exch def
/colorContour exch def
/options [colorSides colorSides true true colorContour] def
/corner3 exch def
/corner2 exch def
/corner1 exch def
/corner0 exch def
/v1 corner1 corner0 \fcVectorMinusVector def
/v2 corner2 corner0 \fcVectorMinusVector def
/v3 corner3 corner0 \fcVectorMinusVector def
[
corner0 corner1 corner2 options \fcPatchMakeFromThreeCorners
corner0 corner2 corner3 options \fcPatchMakeFromThreeCorners
corner0 corner3 corner1 options \fcPatchMakeFromThreeCorners
corner1 corner1 v2 \fcVectorPlusVector corner1 v3 \fcVectorPlusVector options \fcPatchMakeFromThreeCorners
corner2 corner2 v3 \fcVectorPlusVector corner2 v1 \fcVectorPlusVector options \fcPatchMakeFromThreeCorners
corner3 corner3 v1 \fcVectorPlusVector corner3 v2 \fcVectorPlusVector options \fcPatchMakeFromThreeCorners
]
/LeftGreaterThanRight {\fcPatchGetPoint \fcZDepth exch \fcPatchGetPoint \fcZDepth gt} def
\fcMergeSort
{dup \fcPatchPaintFilledDirectly \fcPatchPaintContourDirectly }forall 
end
}

\newcommand{\fcBoxIIIdFilledNew}[5][]{%
\setkeys{fcGraphics}{#1}%
\pscustom{%
\code{%
\fcSetUpGraphicsToScreen %
#2\space #3\space #4\space #5\space[\fcGetColorCode{\fcColorLine}] [\fcGetColorCode{\fcColorPatchUV}] \fcBoxIIIdFilledCode%
}%
}%
}

\newcommand{\fcBoxIIIdFilled}[5][]{%
\pscustom*[#1]{%
\fcPolyLineIIId{4 dict begin%
/visibleCorner #2 def%
/vectorOne #3 #2 \fcVectorMinusVector def%
/vectorTwo #4 #2 \fcVectorMinusVector def%
/vectorThree #5 #2 \fcVectorMinusVector def %
visibleCorner vectorOne \fcVectorPlusVector dup vectorTwo \fcVectorPlusVector dup vectorOne \fcVectorMinusVector dup vectorThree \fcVectorPlusVector dup vectorTwo \fcVectorMinusVector dup vectorOne \fcVectorPlusVector visibleCorner vectorOne \fcVectorPlusVector end %
}%
}%
}

\newcommand{\fcParallelogramIIId}[4][linecolor=cyan!30]{%
\pscustom*[#1]{%
\fcParallelogramHollowIIId{#2}{#3}{#4}%
}%
}

\newcommand{\fcParallelogramHollowIIId}[4][]{ %
\fcPolyLineIIId[#1]{3 dict begin /corner #2 def /vectorOne #3 #2 \fcVectorMinusVector def /vectorTwo #4 #2 \fcVectorMinusVector def corner dup vectorOne \fcVectorPlusVector dup vectorTwo \fcVectorPlusVector dup vectorOne \fcVectorMinusVector corner end
}%
}

\newcommand{\fcParallelogramHalfVisibleIIId}[4][]{%
\pstVerb{3 dict begin /corner #2 def /vectorOne #3 #2 \fcVectorMinusVector def /vectorTwo #4 #2 \fcVectorMinusVector def}%
\fcPolyLineIIId[#1]{corner vectorOne \fcVectorPlusVector corner dup vectorTwo \fcVectorPlusVector}%
\fcPolyLineIIId[#1,linestyle=dashed]{corner vectorOne \fcVectorPlusVector dup vectorTwo \fcVectorPlusVector dup vectorOne \fcVectorMinusVector}%
\pstVerb{end}%
}

\newcommand{\fcPolyLineIIId}[2][linecolor=black]{%
\listplot[#1]{ [#2] {\fcCoordsIIIdToPStricks} \fcSpliceArrayOperation \fcArrayToStack}%
}

%\newcommand{\fcCoordsPStricksToPS}{\fcArrayToStack \fcConvertPSYUnit exch \fcConvertPSXUnit exch\space }
\makeatletter
\newcommand{\fcCoordsPStricksToPS}{\fcArrayToStack \tx@ScreenCoor\space }
\makeatother

\newcommand{\fcLine}[3][]{%
\pscustom{%
\code{%
1 setlinewidth newpath %
#2\space \fcCoordsPStricksToPS moveto %
#3\space \fcCoordsPStricksToPS lineto %
stroke %
}%
}%
}

\newcommand{\fcEllipsoidInScene}[2][iterationsU=22, iterationsV=22]{
\setkeys{fcGraphics}{#1}%
\pstVerb{%
/theIIIdObjects% 
[theIIIdObjects \fcArrayToStack [0 0 180 360%
{ #2\space 6 dict begin%
  /c exch def%
  /b exch def%
  /a exch def%
  /z1 exch def%
  /y1 exch def%
  /x1 exch def%
  [ u sin v cos mul a mul x1 add %
    u sin v sin mul b mul y1 add %
    u cos c mul z1 add %
  ]%
  end%
}%
{true}
\fcIterationsU\space \fcIterationsV\space %
[\fcGetColorCode{\fcColorPatchUV}] 
[\fcGetColorCode{\fcColorPatchVU}] 
[false [\fcGetColorCode{\fcColorLine}] \fcLineWidth] 
false (surface)
]
]%
def%
}%
}

\newcommand{\fcLineFormatCode}{\fcDashesCode \fcLineWidth\space setlinewidth }

\newcommand{\fcCurveCode}{%
%(calling fcCurveCode) == %
5 dict begin %
%newpath 0 0 moveto 1000 1000 lineto stroke
/theCurve exch def %
%theCurve == %
/tMin exch def%
/tMax exch def%
/Delta tMax tMin sub \fcPlotPoints \space 1 sub div def %
/t tMin def %
\fcLineFormatCode %
newpath %
theCurve \fcCoordsPStricksToPS moveto %
\fcPlotPoints\space 1 sub {/t t Delta add def theCurve \fcCoordsPStricksToPS lineto %
} repeat %
stroke %
end\space%
}

\newcommand{\fcCurve}[4][]{%
\setkeys{fcGraphics}{#1}%
\pstVerb{#2\space #3\space {#4} \space \fcCurveCode}%
}

\newcommand{\fcLineIIId}[3][linecolor=black]{%
\psline[#1](! #2 \space \fcCoordsIIIdToPStricks)(! #3 \space \fcCoordsIIIdToPStricks)%
}

\newcommand{\fcAxesIIIdFull}[4][linecolor=black, arrows=->]{%
\fcAxesIIId[#1]{#2}{#3}{#4}%
\fcLineIIId[#1]{[0 0 0]}{[#2\space -1 mul 0 0]}%
\fcLineIIId[#1]{[0 0 0]}{[0 #3\space -1 mul 0]}%
\fcLineIIId[#1]{[0 0 0]}{[0 0 #4\space -1 mul]}%
} %

\newcommand{\fcAxesIIIdInScene}[4][linecolor=black, arrows=->]{%
\setkeys{fcGraphics}{#1}%
\fcLineIIIdInScene[#1]{[0 0 0]}{[#2 0 0]}%
\fcLineIIIdInScene[#1]{[0 0 0]}{[0 #3 0]}%
\fcLineIIIdInScene[#1]{[0 0 0]}{[0 0 #4]}%
}

\newcommand{\fcAxesIIIdFullInScene}[4][linecolor=black, arrows=->]{%
\setkeys{fcGraphics}{#1}%
\fcLineIIIdInScene[#1]{[0 0 0]}{[#2 0 0]}%
\fcLineIIIdInScene[#1]{[0 0 0]}{[0 #3 0]}%
\fcLineIIIdInScene[#1]{[0 0 0]}{[0 0 #4]}%
\fcLineIIIdInScene[#1]{[0 0 0]}{[#2\space-1 mul 0 0]}%
\fcLineIIIdInScene[#1]{[0 0 0]}{[0 #3\space-1 mul 0]}%
\fcLineIIIdInScene[#1]{[0 0 0]}{[0 0 #4\space-1 mul]}%
}

\newcommand{\fcAxesIIId}[4][linecolor=black, arrows=->]{%
\setkeys{fcGraphics}{#1}%
\fcLineIIId[#1]{[0 0 0]}{[#2 0 0]}%
\rput(! [#2 0 0] \fcCoordsIIIdToPStricks){\fcXLabel}%
\fcLineIIId[#1]{[0 0 0]}{[0 #3 0]}%
\rput(! [0 #3 0] \fcCoordsIIIdToPStricks){\fcYLabel}%
\fcLineIIId[#1]{[0 0 0]}{[0 0 #4]}%
\rput(! [0 0 #4] \fcCoordsIIIdToPStricks){\fcZLabel}%
}

\newcommand{\fcDotIIId}[2][linecolor=\fcColorGraph]{%
\pscircle*[#1](! #2 \fcCoordsIIIdToPStricks){0.07} %
} %

\newcommand{\fcPutIIId}[3][]{ \rput[#1](! #2 \fcCoordsIIIdToPStricks) {#3}%
} %

\newcommand{\fcPaintCone}{ %
\fcArrayToStack %
15 dict begin %
/c exch def %
/b exch def %
/a exch def %
/z1 exch def %
/y1 exch def %
/x1 exch def %
/zmax exch def %
/zmin exch def %
}

\newcommand{\fcZBufferRowColumn}{ %
%input: vector on the top of the stack.
%output: row column of point in the z-buffer.
\fcCoordsIIIdToPStricks %
2 dict begin %
/rowIndex exch \space getZBufferYmin sub getZBufferYmax getZBufferYmin sub div zBufferNumRows mul floor cvi def %
/columnIndex exch getZBufferXmin sub getZBufferXmax getZBufferXmin sub div zBufferNumCols mul floor cvi def %
rowIndex zBufferNumRows ge {/rowIndex rowIndex 1 sub def}if %
columnIndex zBufferNumCols ge {/columnIndex columnIndex 1 sub def}if %
rowIndex zBufferNumRows ge {(ERROR: bad row index!!!) == rowIndex ==}if %
columnIndex zBufferNumCols ge {(ERROR: bad column index: ) == columnIndex == }if %
rowIndex 0 lt {/rowIndex rowIndex 1 add def}if %
columnIndex 0 lt {/columnIndex columnIndex 1 add def}if %
rowIndex 0 lt {(ERROR: bad row index!!!) == rowIndex ==}if %
columnIndex 0 lt {(ERROR: bad column index: ) == columnIndex ==  }if %
rowIndex columnIndex %
end %
}

\newcommand{\fcPointIsBehindPatch}{ %
%(entering fcPointIsBehindPatch) ==
%a patch is assumed to be on the top of the stack
12 dict begin %
/thePatch exch def
/point exch def
thePatch \fcPatchGetInBounds
{
/v0 thePatch \fcPatchGetvZero def %
/v1 thePatch \fcPatchGetvOne def %
/v2 thePatch \fcPatchGetvTwo def %
/v3 thePatch \fcPatchGetvThree def %
/normalLeft v1 v0 \fcVectorMinusVector \fcScreen\space pop \fcVectorCrossVector def %
/normalRight v3 v2 \fcVectorMinusVector \fcScreen\space pop \fcVectorCrossVector def %
/normalBottom v2 v0 \fcVectorMinusVector \fcScreen\space pop \fcVectorCrossVector def %
/normalTop v3 v1 \fcVectorMinusVector \fcScreen\space pop \fcVectorCrossVector def %
/patchNormal v1 v0 \fcVectorMinusVector v2 v0 \fcVectorMinusVector \fcVectorCrossVector def %
point v0 \fcVectorMinusVector normalLeft \fcVectorScalarVector %
v2 point \fcVectorMinusVector normalRight \fcVectorScalarVector %
mul 0 ge { %
point v0 \fcVectorMinusVector normalBottom \fcVectorScalarVector %
v1 point \fcVectorMinusVector normalTop \fcVectorScalarVector %
mul 0 ge %
{ %
point v0 \fcVectorMinusVector patchNormal \fcVectorScalarVector %
\fcScreen\space pop patchNormal \fcVectorScalarVector %
mul 0 gt %
{true}{false}ifelse %
}{false}ifelse %
}{false}ifelse %
}{false}ifelse
end %
}

\newcommand{\fcIsInForeground}{ %
15 dict begin %
/theNeighborhood exch def %
/thePoint theNeighborhood 0 get def %
%(neighborhood: ) print
%theNeighborhood ==
%(thePoint:) print
%thePoint ==
thePoint \fcZBufferRowColumn %
/column exch def %
/row exch def %
/theZBuffEntry theZBuffer row get column get def %
/result true def %
/counterZBuff -1 def %
theZBuffEntry length { %
/counterZBuff counterZBuff 1 add def %
/theZbuffPatchIndex theZBuffEntry counterZBuff get def %
/theZbuffPatch thePatchCollection theZbuffPatchIndex get def %
theZbuffPatchIndex theNeighborhood \fcContains not{ %
%(patch) == theZbuffPatch == (is not contained in neighborhood ) ==
%theNeighborhood ==
thePoint theZbuffPatch \fcPointIsBehindPatch 
{/result false def  
exit
}
{ %(point is in front of patch) ==
}
ifelse
}
{ %(patch coincides with zbuff patch) == 
}
ifelse %
}repeat %
result %
end %
}

\newcommand{\fcZBufferBoundingBoxPatch}{ %
5 dict begin %
/thePatch exch def
/v3 thePatch \fcPatchGetvThree def %
/v2 thePatch \fcPatchGetvTwo def %
/v1 thePatch \fcPatchGetvOne def %
/v0 thePatch \fcPatchGetvZero def %
v0 \fcZBufferBoundingBoxPoint %
v1 \fcZBufferBoundingBoxPoint %
v2 \fcZBufferBoundingBoxPoint %
v3 \fcZBufferBoundingBoxPoint %
v1 v2 \fcVectorPlusVector v0 \fcVectorMinusVector \fcZBufferBoundingBoxPoint %
end %
}

\newcommand{\fcZBufferBoundingBoxPoint}{ %
%Account bounding box:
\fcCoordsIIIdToPStricks % 
dup dup getZBufferYmin lt {setZBufferYmin}{pop}ifelse %
dup getZBufferYmax gt {setZBufferYmax}{pop}ifelse %
dup dup getZBufferXmin lt {setZBufferXmin}{pop}ifelse %
dup getZBufferXmax gt {setZBufferXmax}{pop}ifelse \space%
}

\newcommand{\fcZBufferEllipsoid}{ %
%(calling fcZBufferEllipsoid with input: ) == dup == %
\fcArrayToStack
6 dict begin
/c exch def %
/b exch def %
/a exch def %
/z1 exch def %
/y1 exch def %
/x1 exch def %
[a -1 mul x1 add b -1 mul y1 add c -1 mul z1 add a x1 add b y1 add c z1 add] %
end
}

\newcommand{\fcSegmentBoundingBox}{ %
\fcZBufferBoundingBoxPoint %
\fcZBufferBoundingBoxPoint %
}

\newcommand{\fcZBufferPaintCellContainingPoint}{
10 dict begin
/thePoint exch def
thePoint \fcZBufferRowColumn
/column exch def
/row exch def
\fcZBufferComputeDeltaXDeltaY
/lowerLeftX getZBufferXmin DeltaX column mul add def
/lowerLeftY getZBufferYmin DeltaY row mul add def
gsave 
0.6 0.6 1 setrgbcolor
newpath 
[lowerLeftX lowerLeftY] \fcCoordsPStricksToPS moveto
[lowerLeftX DeltaX add lowerLeftY] \fcCoordsPStricksToPS lineto
[lowerLeftX DeltaX add lowerLeftY DeltaY add] \fcCoordsPStricksToPS lineto
[lowerLeftX lowerLeftY DeltaY add] \fcCoordsPStricksToPS lineto
[lowerLeftX lowerLeftY] \fcCoordsPStricksToPS lineto
stroke
grestore
end
}

\newcommand{\fcZBufferComputeDeltaXDeltaY}{
/DeltaX getZBufferXmax getZBufferXmin sub zBufferNumCols div def %
/DeltaY getZBufferYmax getZBufferYmin sub zBufferNumRows div def %
}

\newcommand{\fcPaintZbuffForDebug}{ %
6 dict begin %
\fcZBufferComputeDeltaXDeltaY
gsave %
0.1 setlinewidth %
/x getZBufferXmin def %
0.5 0.5 0.5 setrgbcolor %
zBufferNumRows {newpath [x getZBufferYmin] \fcCoordsPStricksToPS moveto [x getZBufferYmax] \fcCoordsPStricksToPS lineto stroke /x x DeltaX add def}repeat %
/y getZBufferYmin def %
zBufferNumCols { newpath [getZBufferXmin y] \fcCoordsPStricksToPS moveto [getZBufferXmax y] \fcCoordsPStricksToPS lineto stroke /y y DeltaY add def}repeat %
/y getZBufferYmin DeltaY 2 div add def %
/counterY 0 def %
zBufferNumRows { %
/x getZBufferXmin DeltaX 2 div add def %
/counterX 0 def %
zBufferNumCols { %
theZBuffer counterY get counterX get length 0 gt{ %
[x y] \fcFullDotCode %
} if %
/x x DeltaX add def %
/counterX counterX 1 add def %
}repeat %
/y y DeltaY add def %
/counterY counterY 1 add def %
}repeat %
grestore %
end %
}

\newcommand{\fcStartIIIdScene}{%
\pstVerb{%
1 dict begin%
/theIIIdObjects [] def %
}%
}

\newcommand{\fcZBufferPrint}{ %
(printing Zbuffer...) == %
getZBufferXmin == %
getZBufferXmax == %
getZBufferYmin == %
getZBufferYmax == %
theZBuffer == %
}

\newcommand{\fcZBufferLoad}{ %
\fcZBufferInitialize %
/theZBuffer exch def %
setZBufferYmax %
setZBufferYmin %
setZBufferXmax %
setZBufferXmin %
}

\newcommand{\fcZBufferInitialize}{ %
/ZBufferRectangle [0 0 0 0] def %
/setZBufferXmin {ZBufferRectangle exch 0 exch put} def %
/setZBufferYmin {ZBufferRectangle exch 1 exch put} def %
/setZBufferXmax {ZBufferRectangle exch 2 exch put} def %
/setZBufferYmax {ZBufferRectangle exch 3 exch put} def %
/getZBufferXmin {ZBufferRectangle 0 get} def %
/getZBufferYmin {ZBufferRectangle 1 get} def %
/getZBufferXmax {ZBufferRectangle 2 get} def %
/getZBufferYmax {ZBufferRectangle 3 get} def %
/zBufferNumCols \fcZBufferNumXIntervals\space def
/zBufferNumRows \fcZBufferNumYIntervals\space def
thePatchCollection length zBufferNumCols zBufferNumRows mul lt
{ /zBufferNumCols thePatchCollection length sqrt round cvi def
  zBufferNumCols 3 lt {/zBufferNumCols 3 def}if
  /zBufferNumRows zBufferNumCols def
  (There are only a few patches in the scene, I decreased z-buffer size to ) print zBufferNumCols == (rows and columns. ) print
}if 
/getZBufferDeltaX {getZBufferXmax getZBufferXmin sub zBufferNumCols div} def %
/getZBufferDeltaY {getZBufferYmax getZBufferYmin sub zBufferNumRows div} def %
/theZBuffer [zBufferNumRows {[zBufferNumCols{[]} repeat]}repeat] def %
}

\newcommand{\fcPaintCachedFile}{
graphicsFile run
}

\newcommand{\fcSetUpGraphicsToScreen}{
/movetoVirtual {moveto} def
/linetoVirtual {lineto} def
/strokeVirtual {stroke} def
/closepathVirtual {closepath} def
/newpathVirtual {newpath} def
/fillVirtual {fill} def
/arrowVirtual {} def
/setrgbcolorVirtual {setrgbcolor} def
/setlinewidthVirtual {setlinewidth} def
/plotArrowVirtual {\fcArrowPlot} def
/setdashVirtual {setdash} def
}

\newcommand{\fcSetUpGraphicsToFileAndScreen}{
graphicsFile ( /plotArrowVirtual {\fcArrowPlot} def ) writestring
/storeNumberPairToGraphicsFile{
\fcMarkClean 3 1 roll
20 string cvs exch 20 string cvs graphicsFile exch writestring graphicsFile ( ) writestring graphicsFile exch writestring graphicsFile ( ) writestring
\fcMarkCleanCheck
} def
/movetoVirtual {
2 copy moveto
storeNumberPairToGraphicsFile
graphicsFile (moveto ) writestring
} def
/setlinewidthVirtual {
dup setlinewidth
20 string cvs graphicsFile exch writestring graphicsFile ( setlinewidth ) writestring 
} def
/linetoVirtual {
2 copy lineto
storeNumberPairToGraphicsFile
graphicsFile (lineto ) writestring
} def
/strokeVirtual {
stroke
graphicsFile (stroke ) writestring
} def
/newpathVirtual {
newpath
graphicsFile (newpath ) writestring
} def
/closepathVirtual {
closepath
graphicsFile ( closepath ) writestring
} def
/fillVirtual {
fill
graphicsFile ( fill ) writestring
} def
/setrgbcolorVirtual {
3 copy
setrgbcolor
graphicsFile 4 -1 roll \fcToString writestring graphicsFile ( ) writestring
graphicsFile 3 -1 roll \fcToString writestring graphicsFile ( ) writestring
graphicsFile exch \fcToString writestring
graphicsFile ( setrgbcolor ) writestring
} def
/setdashVirtual {
2 copy setdash
20 string cvs exch \fcToString graphicsFile exch writestring graphicsFile ( ) writestring graphicsFile exch writestring graphicsFile ( setdash ) writestring 
} def
/plotArrowVirtual { 
2 copy \fcArrowPlot\space
\fcToString exch \fcToString graphicsFile exch writestring graphicsFile ( ) writestring graphicsFile exch writestring graphicsFile ( plotArrowVirtual ) writestring
}def
}

\newcommand{\fcSetupFiles}{
\fcSetUpGraphicsToScreen
/graphicsCached false def
/graphicsFileAvailable true def
/graphicsFileName (graphicsCacheSafeToDelete) (\fcScreen) [[1 0] \fcCoordsPStricksToPS] \fcToString [[0 1] \fcCoordsPStricksToPS] \fcToString 6 -1 roll \fcToString \fcHashString (.txt) 6 \fcConcatenateMultiple def
/graphicsFile (file not open) def
errordict begin
/invalidfileaccess 
{ userdict begin /graphicsFileAvailable false def end
(ERROR: failed to open file for caching large IIId rendering operations. ) print
(This is not fatal but will cause your graphics to compile incredibly slowly. ) print
(To fix this, compile with pdflatex --shell-escape. ) print
(Make sure the file is executed in a folder with write priviledges. \string\n) print
pop pop 
} def
/undefinedfilename{
(File doesn't exist. ) print
 pop pop
} def
end
(Opening file ) print graphicsFileName print (. ) print
/graphicsFile graphicsFileName (r) file def
graphicsFile type (filetype) eq {
/graphicsCached true def
\fcPaintCachedFile
graphicsFile closefile
}
{ /graphicsFile graphicsFileName (w) file def
  graphicsFile type (filetype) ne{
  /graphicsFileAvailable false def
  }
  { \fcSetUpGraphicsToFileAndScreen
  }
  ifelse
}ifelse
}

\newcommand{\fcComputePatchesAndContours}{
/totalNumPatches 0 def
/totalNumContours 0 def
\fcMarkClean
theIIIdObjects {\fcObjectGetNumPatches /totalNumPatches exch totalNumPatches add def} forall
\fcMarkCleanCheck
\fcMarkClean
theIIIdObjects {\fcObjectGetNumContours /totalNumContours exch totalNumContours add def} forall
\fcMarkCleanCheck
/thePatchCollection [totalNumPatches {(empty)}repeat] def
/theContourCollection [totalNumContours{(empty)} repeat] def
(\string\n) print (Expected number of patches, contours: ) print
thePatchCollection length 20 string cvs print (, ) print
theContourCollection length 20 string cvs print 
(. Computing patches and contours ...) print
/numPatchesComputedSoFar 0 def
/numContoursComputedSoFar 0 def
/counter -1 def
theIIIdObjects length {
/counter counter 1 add def
theIIIdObjects counter get \fcObjectComputePatchesAndContours 
theIIIdObjects counter get \fcObjectGetNumPatches 
/numPatchesComputedSoFar exch numPatchesComputedSoFar add def
theIIIdObjects counter get \fcObjectGetNumContours
/numContoursComputedSoFar exch numContoursComputedSoFar add def
} repeat
thePatchCollection{(empty) eq {(ERROR: declared patch not computed!)}if }forall
theContourCollection{(empty) eq {(ERROR: declared contour not computed!)}if }forall
(... computing patches and contours done!\string\n) print
}

\newcommand{\fcPaintPatches}{
thePatchIndices {\fcPaintPatchIndexFilledDirectly} forall
}

\newcommand{\fcPaintPatchLabels}{
/counter -1 def
0 0 0 setrgbcolorVirtual
thePatchCollection length 
{/counter counter 1 add def
counter thePatchCollection counter get \fcPatchPaintLabel
}repeat
}

\newcommand{\fcPaintPatchSortOrder}{
/counter -1 def
0 0 0 setrgbcolorVirtual
thePatchIndices length 
{/counter counter 1 add def
counter thePatchCollection thePatchIndices counter get get \fcPatchPaintLabel
}repeat
}


\newcommand{\fcPaintContours}{
theContourCollection{\fcPaintContour} forall %
}

\newcommand{\fcProcessCurrentZBuffer}{
/counterI -1 def
%(ere be i 1) ==
%(currentZBuffer is: ) ==
%currentZBuffer ==
currentZBuffer length {
/counterI counterI 1 add def
/counterJ -1 def
currentZBuffer length{
/counterJ counterJ 1 add def
counterI counterJ ne{
/leftIndex currentZBuffer counterI get def
/rightIndex currentZBuffer counterJ get def
rightIndex leftIndex \fcLeftPatchIsBehind{
rightIndex thePatchIncidenceGraph leftIndex get \fcContains not {
thePatchIncidenceGraph leftIndex
[ thePatchIncidenceGraph leftIndex get \fcArrayToStack rightIndex
]
put
}if
}if
}if
}repeat
}repeat
}

\newcommand{\fcComputePatchOrder}{
/thePatchIncidenceGraph [thePatchCollection length {[]}repeat] def
/rowCounter -1 def
(computing patch order... ) print
(processing z-buffer row, column:) print 
theZBuffer length {
/rowCounter rowCounter 1 add def
/columnCounter -1 def
theZBuffer rowCounter get length {
/columnCounter columnCounter 1 add def
/currentZBuffer theZBuffer rowCounter get columnCounter get def
% % % % %
(\string\n) print rowCounter == columnCounter ==
(out of: ) print theZBuffer length == theZBuffer rowCounter get length ==
% % % % %
\fcProcessCurrentZBuffer
}repeat
}repeat
(... computing patch order done ) print
}

\newcommand{\fcSortPatchIndices}{
(sorting a total of ) print thePatchCollection length == ( patches... ) print
fastPatchSort
{ (\string\n Sorting patches by their z-depth. This may be inaccurate but is fast. ) print 
  /counter -1 def
  /thePatchIndices [thePatchCollection length {/counter counter 1 add def counter} repeat] def
  20 dict begin
  /LeftGreaterThanRight
  { 4 dict begin
  	/rightPatch exch thePatchCollection exch get def
  	/leftPatch  exch thePatchCollection exch get def
  	leftPatch  \fcPatchGetPoint \fcScreen\space pop \fcVectorScalarVector
  	rightPatch \fcPatchGetPoint \fcScreen\space pop \fcVectorScalarVector
  	lt
    end
  } def
  thePatchIndices \fcMergeSort
  end
  /thePatchIndices exch def
  (\string\n Sorting patches done. ) print
}
{
(\string\n Sorting patches via the partial order induced by their visibility. This is slow but somewhat accurate. ) print
%thePatchIncidenceGraph shall have one entry for each patch.
%The entry will consist of a list of all patch indices of 
%patches that are behind our patch.
/thePatchIndices [thePatchCollection length {(empty)} repeat] def
20 dict begin
\fcComputePatchOrder
(patch incidence graph:) ==
thePatchIncidenceGraph ==
/accountPatch {
  /patchIndex exch def
  (accounting patch: ) print
  patchIndex ==
  /numAccountedLastCycle numAccountedLastCycle 1 add def
  accountedPatches patchIndex true put
  thePatchIndices numAccountedSoFar patchIndex put
  /numAccountedSoFar numAccountedSoFar 1 add def
} def
/accountedPatches [thePatchCollection length {false} repeat] def
/numAccountedSoFar 0 def
{
/numAccountedLastCycle 0 def
/patchIndex -1 def 
thePatchIncidenceGraph length {
/patchIndex patchIndex 1 add def
accountedPatches patchIndex get not
{/patchIsNext true def
/patchBehindIndex -1 def
/patchesBehindCurrent thePatchIncidenceGraph patchIndex get def
patchesBehindCurrent length{
/patchBehindIndex patchBehindIndex 1 add def
accountedPatches patchesBehindCurrent patchBehindIndex get get not{
/patchIsNext false def exit
}if
}repeat
patchIsNext{
patchIndex accountPatch
}if
}if
}repeat
numAccountedLastCycle 0 eq{
(We have cyclically overlapping patches!) ==
/patchIndex -1 def 
thePatchIncidenceGraph length {
/patchIndex patchIndex 1 add def
accountedPatches patchIndex get not
{ patchIndex accountPatch exit
}if
}repeat
}if
numAccountedSoFar thePatchIndices length eq{exit} if
}loop
(sorting patches done) print
%thePatchIndices ==
%(thePatchCollection: ) ==
%thePatchCollection ==
end
}ifelse
}

\newcommand{\fcFinishIIIdScene}[1][]{%
\setkeys{fcGraphics}{#1}
\pscustom{%
\code{%
%print the objects we are about to paint:
theIIIdObjects length 0 gt { %
%(about to process IIId scene given by: ) print %
%theIIIdObjects == %
} if %
60 dict begin %
theIIIdObjects \fcSetupFiles
graphicsCached not{
/fastPatchSort \fcFastPatchSort\space def
% % % % % % % % % % % % % % % % % % %
\fcComputePatchesAndContours
% % % % % % % % % % % % % % % % % % %
\fcZBufferInitialize %
(computing bounding box IIId scene... ) print %
theContourCollection {\fcZBufferBoundingBoxPatchContour} forall
thePatchCollection {\fcZBufferBoundingBoxPatch} forall
%extend slightly the bounding box to take care of floating point errors at the 
%border 
getZBufferXmin 0.1 sub setZBufferXmin %
getZBufferXmax 0.1 add setZBufferXmax %
getZBufferYmin 0.1 sub setZBufferYmin %
getZBufferYmax 0.1 add setZBufferYmax %
(bounding box computed: ) == ZBufferRectangle == %
% % % % % % % % % % % % % % % % % % % % % % % % % %
(computing z-buffer IIId scene... ) print %
/counter -1 def
thePatchCollection length { /counter counter 1 add def counter \fcZBufferPatchIndex} repeat %
(z buffer computed.) print %
% % % % % % % % % % % % % % % % % % % % % % % % % %
\fcSortPatchIndices
\fcPaintPatches
\fcPaintContours
%\fcPaintPatchSortOrder
%\fcPaintPatchLabels
%[
%thePatchCollection { \fcPatchGetPoint \fcScreen \space pop \fcVectorScalarVector } forall
%] ==
% % % % % %
%(z buffer sorted) print %
% % % % % % % % % % % % % % % % % % % % % % % % % %
%\fcZBufferPrint %
%(painting patches) ==
%\fcZBufferPaintPatches
% %
%\fcPaintZbuffForDebug %
% %
end %
(done, printing stack to make sure no trash is left) == %
pstack %
} %if graphics is not cached
if
}%
}%
\pstVerb{end} %
}%

\newcommand{\fcObjectGetNumContours}{%
\fcArrayToStack %
1 dict begin %
/HandlerNotFound true def %
HandlerNotFound{dup (surface) eq {pop \fcSurfaceGetNumContours /HandlerNotFound false def} if} if %
HandlerNotFound{dup (curve) eq {pop \fcCurveInit 1 /HandlerNotFound false def} if} if %
HandlerNotFound{== (ERROR: OBJECT GET NUMBER OF CONTOURS HANDLER NOT FOUND)} if %
end %
}%

\newcommand{\fcObjectGetNumPatches}{%
\fcArrayToStack %
1 dict begin %
/HandlerNotFound true def %
HandlerNotFound{dup (surface) eq {pop \fcSurfaceGetNumPatches /HandlerNotFound false def} if} if %
HandlerNotFound{dup (curve) eq {pop \fcCurveInit 0 /HandlerNotFound false def} if} if %
HandlerNotFound{== (ERROR: OBJECT NUMBER OF PATCHES HANDLER NOT FOUND)} if %
end %
}%

\newcommand{\fcObjectComputePatchesAndContours}{%
\fcMarkClean exch
\fcArrayToStack %
1 dict begin %
/HandlerNotFound true def %
HandlerNotFound{dup (surface) eq {pop \fcSurfaceComputePatchesAndContours /HandlerNotFound false def} if} if %
HandlerNotFound{dup (curve) eq {pop \fcCurveComputeContour /HandlerNotFound false def} if} if %
HandlerNotFound{== (ERROR: OBJECT PAINTING HANDLER NOT FOUND)} if %
end %
\fcMarkCleanCheck
}%

\newcommand{\fcZBufferBoundingBoxPatchContour}{ %
2 dict begin %
/theContour exch def %
/counter -1 def %
theContour length 1 sub { /counter counter 1 add def theContour counter get 0 get \fcZBufferBoundingBoxPoint}repeat %
end %
}

\newcommand{\fcPaintPointForegroundData}{
20 dict begin %
gsave
/theNeighborhood exch def %
/thePoint theNeighborhood 0 get def %
(theNeighborhood:)==
theNeighborhood ==
thePoint \fcZBufferRowColumn
/column exch def
/row exch def 
/theZBufferCurrent theZBuffer row get column get def
/counter 0 def
/numPatchesInNeighborhood 0 def %
theNeighborhood length 1 sub {
/counter counter 1 add def
1.8 setlinewidth
0.5 1 0.5 setrgbcolor
theNeighborhood counter get theZBufferCurrent \fcContains not
{3 setlinewidth 1 0 0 setrgbcolor
}if
theNeighborhood counter get \fcPatchPaintContourDirectly
theNeighborhood counter get type (arraytype) eq
{/numPatchesInNeighborhood numPatchesInNeighborhood 1 add def}if
}repeat
/counter -1 def
theZBufferCurrent length {
/counter counter 1 add def %
1.1 setlinewidth
1 0.7 0.7 setrgbcolor 
thePoint thePatchCollection theZBufferCurrent counter get get \fcPointIsBehindPatch
{1 0 0 setrgbcolor 
}if
thePatchCollection theZBufferCurrent counter get get \fcPatchPaintContourDirectly
}repeat
thePoint \fcZBufferPaintCellContainingPoint %
[thePoint \fcCoordsIIIdToPStricks] theNeighborhood \fcIsInForeground
{\fcFullDotCode}{\fcHollowDotCode}ifelse %
0 0 0 setrgbcolor 
(nsize: ) numPatchesInNeighborhood 20 string cvs \fcConcatenate [thePoint \fcCoordsIIIdToPStricks ] \fcTextCode
(bsize: ) theZBufferCurrent length 20 string cvs \fcConcatenate [thePoint \fcCoordsIIIdToPStricks 0.2 sub ] \fcTextCode
grestore
end
}

\newcommand{\fcZBufferRowColumnIsInvestigated}{
\fcZBufferRowColumnsUnderInvestigation\space column eq exch row eq and
}

\makeatletter
\newcommand{\fcArrowPlot}{
10 dict begin 
/pointRight exch def
/pointLeft exch def
 gsave
/directionVector [pointRight pointLeft \fcVectorMinusVector \fcArrayToStack] def 
directionVector \fcVectorNorm 0 ne{
/directionVector directionVector \fcVectorNormalize def
}if
/xPS directionVector 0 get def
/yPS directionVector 1 get def
[yPS  xPS -1 mul  -1 xPS mul -1 yPS mul pointRight \fcArrayToStack] concat
%[1 0 0 1  pointRight 0 get \fcCoordsIIIdToPS ] concat
 newpath
 false 0.4 1.5 0.4 0.5 \tx@Arrow 
 closepath
 stroke
 grestore
end
}
\makeatother

\newcommand{\fcPointOnContourGetVisibility}{
dup length 1 sub get\space
}

\newcommand{\fcPaintContour}{ %
20 dict begin %
/theContour exch def %
/numSegments theContour length 2 sub def %
/counter -1 def %
/rightIsInForeground theContour 0 get \fcIsInForeground def %
/style (none) def %
theContour theContour length 1 sub get \fcArrayToStack %formatting data is on top of stack
setlinewidthVirtual
\fcArrayToStack setrgbcolorVirtual
/useArrows exch def
numSegments{ %
  /counter counter 1 add def %
  /pointLeft theContour counter get def %
  /pointRight theContour counter 1 add get def %
  /leftIsInForeground rightIsInForeground def %
  /rightIsInForeground pointRight \fcIsInForeground def %
  /leftIsVisible pointLeft \fcPointOnContourGetVisibility def %
  /rightIsVisible pointRight \fcPointOnContourGetVisibility def %
  /oldStyle style def %
  /style leftIsInForeground rightIsInForeground or {(normal)}{(dashed)}ifelse def %
  /setStyle {style (normal) eq{[] 0 setdashVirtual}{[1 1]0 setdashVirtual}ifelse } def
  leftIsVisible rightIsVisible and{
	counter 0 eq{newpathVirtual}if
    style oldStyle ne{strokeVirtual setStyle %
    newpathVirtual pointLeft 0 get \fcCoordsIIIdToPS movetoVirtual %
    }if %
    pointRight 0 get \fcCoordsIIIdToPS linetoVirtual
  }if
  leftIsVisible rightIsVisible not and{
    strokeVirtual 
    /style (invisible) def
  }if
  leftIsVisible not rightIsVisible and{
    setStyle 
    newpathVirtual pointRight 0 get \fcCoordsIIIdToPS movetoVirtual %
  }if
}repeat %
strokeVirtual %
useArrows{[pointLeft 0 get \fcCoordsIIIdToPS] [pointRight 0 get \fcCoordsIIIdToPS] plotArrowVirtual}if %
end %
}

\newcommand{\fcCurveInit}{
/linewidth exch def
/colorContour [ 5 2 roll] def
/useArrows exch () ne def
/theCurve exch def %
/tMax exch def %
/tMin exch def %
/tIterations \fcPlotPoints\space def %
}

\newcommand{\fcCurveComputeContour}{
30 dict begin %
\fcCurveInit
/DeltaT tMax tMin sub tIterations div def %
/t tMin def %
theContourCollection numContoursComputedSoFar
[
tIterations { %
[theCurve true]
/t t DeltaT add def %
}repeat %
[useArrows colorContour linewidth]
] 
put
end %
}

\newcommand{\fcComputeSurfacePatch}{
/oldU u def %
/oldV v def %
/inBounds true def
[ %start of patch data structure
theSurface %(x(u,v), y(u,v), z(u,v))
theRestrictions not {/inBounds false def}if  
/u u DeltaU add def %
theSurface %(x(u+Delta,v), y(u+Delta,v), z(u+Delta,v))
theRestrictions not {/inBounds false def}if  
/u oldU def %
/v v DeltaV add def %
theSurface %(x(u,v+Delta), y(u,v+Delta), z(u,v+Delta))
theRestrictions not {/inBounds false def}if  
/u u DeltaU add def %
theSurface %(x(u+Delta,v+Delta), y(u+Delta,v+Delta), z(u+Delta,v+Delta))
theRestrictions not {/inBounds false def}if  
[
/u oldU def
/v oldV def
numContourUSegmentsPerPatch {theRestrictions{theSurface}if /u u DeltaDeltaU add def} repeat
/u oldU DeltaU add def
/v oldV def
numContourVSegmentsPerPatch {theRestrictions{theSurface}if /v v DeltaDeltaV add def} repeat
/v oldV DeltaV add def
numContourVSegmentsPerPatch {theRestrictions{theSurface}if /u u DeltaDeltaU sub def} repeat
/u oldU def
numContourVSegmentsPerPatch {theRestrictions{theSurface}if /v v DeltaDeltaV sub def} repeat
]
[colorUVpatch % front color of patch
colorVUpatch % back color of patch
forceForeground %
inBounds %
colorVUpatch
]
(patch) %
] %patch data structure complete
/u oldU def %
/v oldV def %
}

\newcommand{\fcSurfaceGetNumContours}{
30 dict begin
\fcSurfaceInit %
uIterations 1 add vIterations 1 add add
end
}

\newcommand{\fcSurfaceGetNumPatches}{
30 dict begin
\fcSurfaceInit %
uIterations vIterations mul
end
}

\newcommand{\fcSurfaceInit}{
/forceForeground exch def
/contourOptions exch def
/colorVUpatch exch def
/colorUVpatch exch def
/vIterations exch def %
/uIterations exch def %
/theRestrictions exch def
/theSurface exch def %
/vMax exch def %
/uMax exch def %
/vMin exch def %
/uMin exch def %
}

\newcommand{\fcSurfaceComputePatchesAndContours}{%
30 dict begin %
{ %begin loop, used to simulate a jump instruction 
%exiting the loop = jumping at loop end
\fcSurfaceInit
/u uMin def
/v vMin def
mark
theSurface type (arraytype) ne {(\string\n ERROR: surface must be an array. \string\n) print cleartomark exit}if cleartomark
\fcMarkClean
/DeltaU uMax uMin sub uIterations div def %
/DeltaV vMax vMin sub vIterations div def %
/getPatchIndex {exch vIterations mul add numPatchesComputedSoFar add} def
/accountPatch {getPatchIndex dup thePatchCollection exch get (empty) eq {thePatchCollection exch 3 -1 roll put}{pop pop}ifelse 
} def
/numContourVSegmentsPerPatch \fcNumCountourSegmentsPatchV \space def
/numContourUSegmentsPerPatch \fcNumCountourSegmentsPatchU \space def
/DeltaDeltaV DeltaV numContourVSegmentsPerPatch div def %
/DeltaDeltaU DeltaU numContourUSegmentsPerPatch div def %
% % % % % % % % % % % % % % % % % % % % %
%process uv-contours
/u uMin def %
/counterU -1 def %
uIterations 1 add{ %
/counterU counterU 1 add def %
/counterV -1 def %
/v vMin def %
/patchLeftIndex (empty) def %
/patchRightIndex (empty) def %
[
vIterations { %
/counterV counterV 1 add def
/patchLeftBackIndex patchLeftIndex def %
/patchRightBackIndex patchRightIndex def %
/patchLeftIndex counterU uIterations lt 
{\fcComputeSurfacePatch counterU counterV accountPatch counterU counterV getPatchIndex}
{(empty)}
ifelse def %
/patchRightIndex counterU 0 ne {counterU 1 sub counterV getPatchIndex}
{(empty)} ifelse def %
/vOld v def %
[theSurface patchLeftIndex patchRightIndex patchLeftBackIndex patchRightBackIndex theRestrictions]
numContourUSegmentsPerPatch 1 sub{/v v DeltaDeltaV add def [theSurface patchLeftIndex patchRightIndex theRestrictions]} repeat
/v vOld DeltaV add def %
}repeat %
[theSurface patchLeftIndex patchRightIndex theRestrictions]
contourOptions
]
/thePatchContour exch def %
%/contourIsUnderInvestigation \fcZBufferVparameterPointUnderInvestigation\space pop counterU eq def
%/indexPointUnderInvestigation
%\fcZBufferVparameterPointUnderInvestigation\space exch pop def
theContourCollection counterU numContoursComputedSoFar add thePatchContour put
/uOld u def %
/u u DeltaU add def %
} repeat %
% % % % % % % % % % % % % % % % % % % % %
%process vu-contours
/v vMin def %
/counterV -1 def %
vIterations 1 add{ %
  /counterV counterV 1 add def %
  /counterU -1 def
  /u uMin def %
  /patchLeftIndex (empty) def %
  /patchRightIndex (empty) def %
  [
  uIterations { %
  /counterU counterU 1 add def
  /patchLeftBackIndex patchLeftIndex def %
  /patchRightBackIndex patchRightIndex def %
  /patchLeftIndex counterV vIterations lt 
  {counterU counterV getPatchIndex}
  {(empty)}
  ifelse 
  def %
  /patchRightIndex counterV 0 ne {counterU counterV 1 sub getPatchIndex} {(empty)} ifelse def %
  /uOld u def %
  [theSurface patchLeftIndex patchRightIndex patchLeftBackIndex patchRightBackIndex theRestrictions]
  numContourVSegmentsPerPatch 1 sub{/u u DeltaDeltaU add def [theSurface patchLeftIndex patchRightIndex theRestrictions]} repeat
  /u uOld DeltaU add def %
  }repeat %
  [theSurface patchLeftIndex patchRightIndex theRestrictions] 
  contourOptions
  ]
  /thePatchContour exch def %
  %/contourIsUnderInvestigation \fcZBufferUparameterPointUnderInvestigation\space pop counterV  eq def
  %/indexPointUnderInvestigation
  %\fcZBufferUparameterPointUnderInvestigation\space exch pop def
  theContourCollection uIterations 1 add counterV add numContoursComputedSoFar add thePatchContour put
  /vOld v def %
  /v v DeltaV add def %
} repeat %
\fcMarkCleanCheck
exit
}loop %this loop is used to simulate a jump instruction
end %
}%

\newcommand{\fcGetColorCode}[1]{%
2 dict begin%
/theColor {0 0 0} def%
/colorNotFound true def%
(#1) (black) eq (#1) (black ) eq or{/theColor {0 0 0} def /colorNotFound false def}if%
(#1) (red) eq (#1) (red ) eq or{/theColor {1 0 0} def /colorNotFound false def}if%
(#1) (blue) eq (#1) (blue ) eq or{/theColor {0 0 1} def /colorNotFound false def}if%
(#1) (green) eq (#1) (green ) eq or{/theColor {0 1 0} def /colorNotFound false def}if%
(#1) (brown) eq (#1) (brown ) eq or{/theColor {0.6484375 0.1640625 0.1640625} def /colorNotFound false def}if%
(#1) (orange) eq (#1) (orange ) eq or{/theColor {1 0.647058824 0} def /colorNotFound false def}if%
(#1) (cyan) eq (#1) (cyan ) eq or {/theColor {0 1 1} def /colorNotFound false def}if %
(#1) (pink) eq (#1) (pink ) eq or {/theColor {1 0.75390625 0.796875} def /colorNotFound false def}if %
colorNotFound{/theColor {#1} def}if %
theColor %
end%
}%

\newcommand{\fcLineIIIdInScene}[3][arrows=,]{%
\fcCurveIIIdInScene[#1]{0}{1}{#3 t \fcVectorTimesScalar #2 1 t sub \fcVectorTimesScalar \fcVectorPlusVector}%
}

%Format of curve: we store the curve in the format [tmin tmax [x y z] arrows red green blue (curve)]
\newcommand{\fcCurveIIIdInScene}[4][]{%
\setkeys{fcGraphics}{#1}%
\pstVerb{%
[theIIIdObjects \fcArrayToStack [#2\space #3{#4} (\fcArrows) \fcGetColorCode{\fcColorLine} \fcLineWidth (curve)]]/theIIIdObjects exch def}%
}%


%Format of patch: we give the patch by its corners v0, v1, v2. The patch is spanned by v1-v0 and v2-v0
\newcommand{\fcPatchInScene}[4][]{%
\fcSurfaceInScene[#1, iterationsU=1, iterationsV=1]{0}{0}{1}{1}{%
3 dict begin %
/v0 #2\space def %
/t1 #3\space v0 \fcVectorMinusVector def %
/t2 #4\space v0 \fcVectorMinusVector def %
v0 %
t1 u \fcVectorTimesScalar %
t2 v \fcVectorTimesScalar %
\fcVectorPlusVector \fcVectorPlusVector %
end %
}{}%
}

%Format of surface: we store the surface in the format 
%[umin vmin umax vmax 
%[x(u,v) y(u,v) z(u,v)] coordinate functions 
%uIterations vIterations   %number of curvilinear u,v-segments
%[red green blue] %color of patches whose u,v-side is visible
%[red green blue] %color of patches whose v,u-side is visible
%[red green blue] %color of contours
% foregroundstatus %true or false 
%(surface)]. 
\newcommand{\fcSurfaceInScene}[7][]{%
\setkeys{fcGraphics}{#1}%
\pstVerb{%
[theIIIdObjects \fcArrayToStack [#2\space #3\space #4\space #5\space {#6} {#7} length (length restrictions: ) == dup == 0 ne {{#7}}{{true}}ifelse \fcIterationsU\space \fcIterationsV%
[\fcGetColorCode{\fcColorPatchUV}]% 
[\fcGetColorCode{\fcColorPatchVU}]%
[false [\fcGetColorCode{\fcColorLine}] \fcLineWidth]%
\fcForceForeground\space (surface)] ]/theIIIdObjects exch def}%
}%

\newcommand{\fcCurveIIIdNoSceneCode}{%
15 dict begin%
/theCurve exch def%
/tMax exch def%
/tMin exch def%
/numPoints \fcPlotPoints\space def%
/Delta tMax tMin sub numPoints 1 sub div def%
/t tMin def %
\fcLineFormatCode %
newpath %
theCurve \fcCoordsIIIdToPS moveto %
numPoints 1 sub {/t t Delta add def theCurve \fcCoordsIIIdToPS lineto } repeat %
stroke %
end %
}%

\newcommand{\fcZBufferBoundingBoxPolyline}{ %
{\fcZBufferBoundingBoxPoint} forall
}

\newcommand{\fcContains}{ %
%format: theElement theArray -> true if theElement is in the array, false else.
3 dict begin %
/theArray exch def %
/theElement exch def %
false %
/counter 0 def %
theArray length { %
theElement theArray counter get \fcAreEqual {pop true exit}if %
/counter counter 1 add def %
}repeat %
%(array: ) == theArray == 
%dup { (does contain) ==}{ (does NOT contain) ==}ifelse %
%theElement == %
end %
}

\newcommand{\fcAreEqual}{ %
1 dict begin
/areEqual
{5 dict begin 
/left exch def
/right exch def
left type  right type ne{false}
{ left type (arraytype) ne{ left right eq}
{ left length right length ne{false}
{ /counter 0 def %
true %
left length { left  counter get right counter get areEqual not{pop false exit }if /counter counter 1 add def }repeat
}ifelse
}ifelse
}ifelse
end
} def %
areEqual
end
}

\newcommand{\fcZBufferAccountPatchIndexAtXY}{ %
%(patch row col: ) print x == y ==
5 dict begin %
/currentArray theZBuffer row get column get def %
/counter 0 def %
thePatchIndex currentArray \fcContains not
{theZBuffer row get column [currentArray \fcArrayToStack thePatchIndex ] put}if
end %
}

\newcommand{\fcMergeSort}{
2 dict begin
/theArray exch def
/mergeSortStartIndexLength {
10 dict begin
/theLength exch def
/startIndex exch def
{ theLength 1 eq 
  { [theArray startIndex get]
  	exit
  } if
  theLength 2 eq 
  { theArray startIndex get theArray startIndex 1 add get
    LeftGreaterThanRight
    { [theArray startIndex 1 add get theArray startIndex get]
    } 
    { [theArray startIndex get theArray startIndex 1 add get]
    } ifelse
    exit  
  } if
  /leftLength theLength 2 div cvi def
  /rightLength theLength leftLength sub def
  /leftSorted startIndex leftLength mergeSortStartIndexLength def
  /rightSorted startIndex leftLength add rightLength mergeSortStartIndexLength def
  /counterLeft 0 def
  /counterRight 0 def
  [ theLength{ 
      counterLeft leftLength ge{
        /leftNext false def
      }{
        counterRight rightLength ge{ 
          /leftNext true def
        }{ 
          /leftNext leftSorted counterLeft get rightSorted counterRight get  LeftGreaterThanRight not def
        } ifelse
      } ifelse  
      leftNext{
        leftSorted counterLeft get /counterLeft counterLeft 1 add def
      }{
        rightSorted counterRight get /counterRight counterRight 1 add def        
      }ifelse
    } repeat 
  ]
  exit  
}loop
end
} def
theArray length 0 gt {
  0 theArray length mergeSortStartIndexLength
}{
  theArray
} ifelse
end
}

\newcommand{\fcBubbleSort}{
5 dict begin
/a exch def
/n a length 1 sub def
n 0 gt {
% at this point only the n+1 items in the bottom of a remain to be sorted
% the largest item in that block is to be moved up into position n
n {
0 1 n 1 sub {
/i exch def
a i get a i 1 add get LeftGreaterThanRight {
% if a[i] > a[i+1] swap a[i] and a[i+1]
a i 1 add
a i get
a i a i 1 add get
% set new a[i] = old a[i+1]
put
% set new a[i+1] = old a[i]
put
} if
} for
/n n 1 sub def
} repeat
} if
end 
}

\newcommand{\fcGaussianElimination}{
15 dict begin 
/theMatrix exch def
/numRows theMatrix length def
/numCols theMatrix 0 get length def
/rowIndex 0 def
/columnIndex -1 def
{ /columnIndex columnIndex 1 add def
  columnIndex numCols ge {exit}if
  /candidateIndex -1 def
  /counter rowIndex 1 sub def
  numRows rowIndex sub {
    /counter counter 1 add def
    theMatrix counter get columnIndex get 0 ne {/candidateIndex counter def exit}if
  }repeat
%  (candidateIndex: ) ==
%  candidateIndex ==
  candidateIndex -1 ne{
%  	(matrix before elimination: ) ==
%  	theMatrix ==
    /temp theMatrix rowIndex get def
    theMatrix rowIndex theMatrix candidateIndex get put
    theMatrix candidateIndex temp put
    /pivotRow theMatrix rowIndex get def
    /theCoeff 1 pivotRow columnIndex get div def
    /pivotRow pivotRow  theCoeff \fcVectorTimesScalar def
    theMatrix rowIndex pivotRow put
    /counter -1 def
    numRows {
      /counter counter 1 add def
      counter rowIndex ne{
      theMatrix counter get dup columnIndex get pivotRow exch \fcVectorTimesScalar \fcVectorMinusVector theMatrix exch counter exch put
      }if
    }repeat
    /rowIndex rowIndex 1 add def
  }if
  rowIndex numRows ge {exit}if
}loop
theMatrix
end\space
}

\newcommand{\fcLeftSegmentIsBehindSegmentsAreSkew}{
%Let l1 l2 be the endpoints of the left segment,
%r1, re - the endpoints of the right.
%Let pl1, pl2, pr1, pr2 denote the projections onto the viewing 
%screen of the corresponding endpoints.
%Let
%(a,c) be the vector pl1-pl2
%(b,d) be the vector pr2-pr1
%(e,f) be the vector pr2-pl2
%We need to solve the system
%(a b) (s)= (e)
%(c d) (t)= (f)
%The determinant of the system must be non-zero, else the segments are non-skew.
% the projections of the segments intersect if 0 <= s<=1 
% and 0<=t<=1.
%In that case the point on the left segment that projects onto the point of interest is s*l1 +(1-s)l2. The point on the right segment that projects onto the point of interest is t*r1 +(1-t)*r2
%
25 dict begin
\fcArrayToStack
/r1 exch def 
/r2 exch def
\fcArrayToStack
/l1 exch def
/l2 exch def
/pr1 [r1 \fcCoordsIIIdToPStricks] def
/pr2 [r2 \fcCoordsIIIdToPStricks] def
/pl1 [l1 \fcCoordsIIIdToPStricks] def
/pl2 [l2 \fcCoordsIIIdToPStricks] def
pl1 pl2 \fcVectorMinusVector \fcArrayToStack
/c exch def
/a exch def
pr2 pr1 \fcVectorMinusVector \fcArrayToStack
/d exch def
/b exch def
pr2 pl2 \fcVectorMinusVector \fcArrayToStack
/f exch def
/e exch def
/theMatrix [[a b e][c d f]] \fcGaussianElimination def
/a theMatrix 0 get 0 get def
/d theMatrix 1 get 1 get def
/e theMatrix 0 get 2 get def
/f theMatrix 1 get 2 get def
a 0 eq d 0 eq or {false}{
/s e a div def
/t f d div def
s 0 gt s 1 lt t 0 gt t 1 lt and and and
{
/leftPoint l1 s \fcVectorTimesScalar l2 1 s sub \fcVectorTimesScalar \fcVectorPlusVector def
/rightPoint r1 t \fcVectorTimesScalar r2 1 t sub \fcVectorTimesScalar \fcVectorPlusVector def
leftPoint  \fcScreen\space pop \fcVectorScalarVector
rightPoint \fcScreen\space pop \fcVectorScalarVector
ge
}
{false}
ifelse
}ifelse
end
}

\newcommand{\fcLeftPatchIsBehind}{
2 dict begin
/rightIndex exch def 
/leftIndex exch def 
leftIndex rightIndex \fcLeftPatchIsBehindOrPatchesIntersect
{ rightIndex leftIndex \fcLeftPatchIsBehindOrPatchesIntersect not
}
{false}ifelse
end
}

\newcommand{\fcLeftPatchIsBehindOrPatchesIntersect}{
%this function compares two patches:
40 dict begin 
/rightIndex exch def
/leftIndex exch def
/rightPatch thePatchCollection rightIndex get def
/leftPatch thePatchCollection leftIndex get def
rightPatch \fcPatchGetForcedForegroundStatus leftPatch \fcPatchGetForcedForegroundStatus not and {true}{
leftPatch \fcPatchGetForcedForegroundStatus rightPatch \fcPatchGetForcedForegroundStatus not and
{false}{
/lv0 leftPatch \fcPatchGetvZero def
/lv1 leftPatch \fcPatchGetvOne def
/lv2 leftPatch \fcPatchGetvTwo def
/lv3 leftPatch \fcPatchGetvThree def
/rv0 rightPatch \fcPatchGetvZero def
/rv1 rightPatch \fcPatchGetvOne def
/rv2 rightPatch \fcPatchGetvTwo def
/rv3 rightPatch \fcPatchGetvThree def
/ls0 [lv0 lv1] def 
/ls1 [lv1 lv3] def 
/ls2 [lv2 lv3] def 
/ls3 [lv0 lv2] def 
/rs0 [rv0 rv1] def 
/rs1 [rv1 rv3] def 
/rs2 [rv2 rv3] def 
/rs3 [rv0 rv2] def 
/result false def
{ lv0 rightPatch \fcPointIsBehindPatch {/result true def exit }if
  lv1 rightPatch \fcPointIsBehindPatch {/result true def exit }if
  lv2 rightPatch \fcPointIsBehindPatch {/result true def exit }if
  lv3 rightPatch \fcPointIsBehindPatch {/result true def exit }if
  [ls0 ls1 ls2 ls3] 
  { [rs0 rs1 rs2 rs3]
    { %(printint stack) == pstack (printing stack done ) == 
      exch dup 3 -1 roll \fcLeftSegmentIsBehindSegmentsAreSkew{/result true def exit}if 
    }forall 
    pop 
    result {exit}if
  }forall 
  exit
}loop
result
}ifelse
}ifelse
end
}

\newcommand{\fcZBufferPaintPatches}{
10 dict begin
gsave
/row -1 def %
theZBuffer length{ %
/row row 1 add def %
/column -1 def %
theZBuffer row get length{ %
/column column 1 add def %
/currentZBuffer theZBuffer row get column get def %
currentZBuffer {\fcPaintPatchIndexFilledDirectly} forall %
} repeat%
}repeat %
grestore
end
}

\newcommand{\fcPatchGetNormal}{
1 dict begin
/thePatch exch def
thePatch \fcPatchGetvOne thePatch \fcPatchGetvZero \fcVectorMinusVector
thePatch \fcPatchGetvTwo thePatch \fcPatchGetvZero \fcVectorMinusVector
\fcVectorCrossVector
end
}

\newcommand{\fcPatchGetvZero}{0 get\space}
\newcommand{\fcPatchGetvOne}{1 get\space}
\newcommand{\fcPatchGetvTwo}{2 get\space}
\newcommand{\fcPatchGetvThree}{3 get \space}
\newcommand{\fcPatchGetColorUV}{5 get 0 get \fcArrayToStack \space}
\newcommand{\fcPatchGetColorVU}{5 get 1 get \fcArrayToStack \space}
\newcommand{\fcPatchGetColorContour}{5 get 4 get \fcArrayToStack \space}
\newcommand{\fcPatchGetForcedForegroundStatus}{5 get 2 get\space}
\newcommand{\fcPatchGetInBounds}{5 get 3 get\space}
\newcommand{\fcPatchGetContour}{4 get\space}

\newcommand{\fcPaintPatchIndexFilledDirectly}{
thePatchCollection exch get \fcPatchPaintFilledDirectly
}

\newcommand{\fcPatchGetPoint}{
1 dict begin
/thePatch exch def %
thePatch \fcPatchGetvZero
thePatch \fcPatchGetvOne
thePatch \fcPatchGetvTwo
thePatch \fcPatchGetvThree
\fcVectorPlusVector
\fcVectorPlusVector
\fcVectorPlusVector
0.25 \fcVectorTimesScalar
end
}

\newcommand{\fcPatchPaintLabel}{
3 dict begin
/thePatch exch def
20 string cvs 
/Times-Roman findfont
4 scalefont
setfont
newpath
thePatch \fcPatchGetPoint \fcCoordsIIIdToPS moveto
show
stroke
end
}

\newcommand{\fcPatchPaintFilledDirectly}{
1 dict begin
/thePatch exch def %
%(thePatch: ) ==
%thePatch ==
%(PATCH TYPE: ) == thePatch type ==
thePatch type (arraytype) eq{
thePatch \fcPatchGetContour length 0 gt{
thePatch \fcPatchGetNormal \fcScreen\space pop \fcVectorScalarVector 0 gt
{ thePatch \fcPatchGetColorVU setrgbcolorVirtual}
{ thePatch \fcPatchGetColorUV setrgbcolorVirtual}
ifelse
0.5 setalpha
newpathVirtual
thePatch \fcPatchGetContour 0 get \fcCoordsIIIdToPS movetoVirtual
thePatch \fcPatchGetContour{\fcCoordsIIIdToPS linetoVirtual}forall
closepathVirtual
fillVirtual
strokeVirtual
}if
}if
end
}

\newcommand{\fcPatchPaintContourDirectly}{
1 dict begin
/thePatch exch def %
%(thePatch: ) ==
%thePatch ==
%(PATCH TYPE: ) == thePatch type ==
thePatch type (arraytype) eq{
thePatch \fcPatchGetContour length 0 gt{
thePatch \fcPatchGetColorContour setrgbcolorVirtual
newpathVirtual
thePatch \fcPatchGetContour 0 get \fcCoordsIIIdToPS movetoVirtual
thePatch \fcPatchGetContour{\fcCoordsIIIdToPS linetoVirtual}forall
closepathVirtual
strokeVirtual
}if
}if
end
}

\newcommand{\fcZBufferPatchIndex}{ %
15 dict begin %
/thePatchIndex exch def %
/thePatch thePatchCollection thePatchIndex get def
%thePatch \fcPatchPaintContourDirectly
/secondPoint thePatch \fcPatchGetvTwo def %
/firstPoint  thePatch \fcPatchGetvOne def %
/basePoint   thePatch \fcPatchGetvZero def %
/firstDirection firstPoint basePoint \fcVectorMinusVector def %
/secondDirection secondPoint basePoint \fcVectorMinusVector def %
/iterationsFirst [firstDirection \fcCoordsIIIdToPStricks\space pop getZBufferDeltaX div firstDirection \fcCoordsIIIdToPStricks\space exch pop getZBufferDeltaY div] \fcVectorNorm 2 mul 2 add round cvi def %
/iterationsSecond [secondDirection \fcCoordsIIIdToPStricks pop  getZBufferDeltaX div secondDirection \fcCoordsIIIdToPStricks exch pop getZBufferDeltaY div] \fcVectorNorm 2 mul 2 add round cvi def
/s 0 def %
iterationsFirst{ %
/firstComponent firstDirection s iterationsFirst 1 sub div  \space\fcVectorTimesScalar basePoint \fcVectorPlusVector def%
/t 0 def %
iterationsSecond{ %
secondDirection t iterationsSecond 1 sub div \fcVectorTimesScalar %
firstComponent \fcVectorPlusVector \fcZBufferRowColumn %
/column exch def %
/row exch def %
\fcZBufferAccountPatchIndexAtXY %
/t t 1 add def %
}repeat
/s s 1 add def %
}repeat
end %
}

\newcommand{\fcCurveIIId}[4][linecolor=\fcColorGraph]{%
\parametricplot[#1]{#2}{#3}{#4 \fcCoordsIIIdToPStricks}%
}

\newcommand{\fcZeroVector}{[exch {0} repeat]}

\newcommand{\fcPerpendicularComputeHeel}[3]{%
\pstVerb{%
7 dict begin%
/thePoint #1 def%
/heelSize #3 def %
mark #2 %
counttomark 1 eq {%
/directionUnitVector exch \fcVectorNormalize def%
/basePoint thePoint length \fcZeroVector def%
}{%
/basePoint exch def%
/directionUnitVector exch basePoint \fcVectorMinusVector \fcVectorNormalize def%
} ifelse %
pop%
/heel directionUnitVector thePoint basePoint \fcVectorMinusVector directionUnitVector \fcVectorScalarVector \fcVectorTimesScalar basePoint \fcVectorPlusVector def%
%heel == %
/perpendicularUnitVector thePoint heel \fcVectorMinusVector \fcVectorNormalize def %
%perpendicularUnitVector == %
/polyLineInput {%
heel directionUnitVector heelSize \fcVectorTimesScalar \fcVectorMinusVector %
%dup ==
dup perpendicularUnitVector heelSize \fcVectorTimesScalar \fcVectorPlusVector %
heel perpendicularUnitVector heelSize \fcVectorTimesScalar \fcVectorPlusVector%
} def%
}%
}

\newcommand{\fcPerpendicular}[4][]{%
\fcPerpendicularComputeHeel{#2}{#3}{#4}%
\psline[#1](! thePoint \fcArrayToStack)(! heel \fcArrayToStack)%
\listplot[linecolor=red]{ [polyLineInput] {\fcArrayToStack} \fcSpliceArrayOperation \fcArrayToStack}%
\pstVerb{end}%
}

\newcommand{\fcPerpendicularIIId}[4][]{%
\fcPerpendicularComputeHeel{#2}{#3}{#4}%
\fcLineIIId[#1]{thePoint}{heel}%
\fcPolyLineIIId[linecolor=red]{polyLineInput}%
\pstVerb{end}%
}%

\newcommand{\fcPlotIIId}[7][]{%
\fcPlotIIIdXconst[#1]{#2}{#3}{#4}{#5}{#6}{#7}%
\fcPlotIIIdYconst[#1]{#2}{#3}{#4}{#5}{#6}{#7}%
}
\newcommand{\fcPlotIIIdXconst}[7][]{%
\setkeys{fcGraphics}{#2}%
\multido{\ra=0+1}{\fcIterationsX}{%
\pstVerb{%
3 dict begin %
/x \ra \space #3 mul \fcIterationsX \space \ra \space sub 1 sub  #5\space mul add \fcIterationsX\space 1 sub div def%
/ymin #4 def%
/ymax #6 def%
}%
\parametricplot[#1]{ymin}{ymax}{%
1 dict begin /y t def  [x y #7] \fcCoordsIIIdToPStricks end%
}%
\pstVerb{end}%
}%end multido
}

\newcommand{\fcPlotIIIdYconst}[7][]{%
\setkeys{fcGraphics}{#2}%
\multido{\ra=0+1}{\fcIterationsY}{%
\pstVerb{%
3 dict begin%
/y \ra \space #4 mul \fcIterationsY \space \ra \space sub 1 sub  #6\space mul add \fcIterationsY\space 1 sub div def%
/xmin #3 def%
/xmax #5 def%
}%
\parametricplot[#1]{xmin}{xmax}{%
1 dict begin /x t def  [x y #7] \fcCoordsIIIdToPStricks end%
}%
\pstVerb{end}%
}%end multido
}

\newcommand{\fcSurfaceIIIdUConst}[7][]{%
\setkeys{fcGraphics}{#2}%
\multido{\ra=0+1}{\fcIterationsX}{%
\pstVerb{%
3 dict begin%
/u \ra \space #3 mul \fcIterationsX \space \ra \space sub 1 sub  #5\space mul add \fcIterationsX\space 1 sub div def%
/vmin #4 def%
/vmax #6 def%
}%
\parametricplot[#1]{vmin}{vmax}{%
1 dict begin /v t def #7 \fcCoordsIIIdToPStricks end%
}%
\pstVerb{end}%
}%end multido
}

\newcommand{\fcSurfaceIIIdVConst}[7][]{%
\setkeys{fcGraphics}{#2}%
\multido{\ra=0+1}{\fcIterationsY}{%
\pstVerb{%
3 dict begin%
/v \ra \space #4 mul \fcIterationsY \space \ra \space sub 1 sub  #6\space mul add \fcIterationsY\space 1 sub div def%
/umin #3 def%
/umax #5 def%
}%
\parametricplot[#1]{umin}{umax}{%
1 dict begin /u t def #7 \fcCoordsIIIdToPStricks end%
}%
\pstVerb{end}%
}%end multido
}

\newcommand{\fcSurfaceDirectDraw}[7][]{%
\fcSurfaceIIIdUConst[#1]{#2}{#3}{#4}{#5}{#6}{#7}%
\fcSurfaceIIIdVConst[#1]{#2}{#3}{#4}{#5}{#6}{#7}%
}%

%Example:\fcVectorField{startX= -2, startY=-2, iterationsX=9, iterationsY=9, Delta=0.5}{y -x}
\newcommand{\fcVectorField}[3][linecolor=blue]{%
\setkeys{fcGraphics}{#2}%
\multido{\ra=\fcStartXIId+\fcDelta}{\fcIterationsX}{%
\multido{\rb=\fcStartYIId+\fcDelta}{\fcIterationsY}{%
\pstVerb{%
4 dict begin%
/x \ra\space def%
/y \rb\space def %
#3\space%
/vY exch def%
/vX exch def%
}%
\psline[#1](! x vX 2 div sub y vY 2 div sub)(! x vX 2 div add y vY 2 div add)%
\pscircle*[linecolor=red](! x y){0.02}%
\pstVerb{end}%
}%end multido
}%end multido
}%

