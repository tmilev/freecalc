\ProvidesPackage{pstricks-commands}
\usepackage{etex, ifthen}
\usepackage{auto-pst-pdf}
\usepackage{pst-plot}
\usepackage{pst-math}
%WARNING THE FOLLOWING PACKAGE IS BROKEN use only with EXTREME CAUTION
%\usepackage{pst-3dplot}

\makeatletter
\begingroup
\catcode `P=12  % digits and punct. catcode
\catcode `T=12  % digits and punct. catcode
\lowercase{%
\def\x{\def\rem@pt##1.##2PT{##1\ifnum##2>\z@.##2\fi}}}
\expandafter\endgroup\x%
\newcommand{\stripPoints}[1]{\expandafter\rem@pt\the#1}
\makeatother

\newcommand{\fcShiftX}{0}
\newcommand{\fcShiftY}{0}
\newcommand{\fcXLabel}{$x$}
\newcommand{\fcYLabel}{$y$}
\newcommand{\fcZLabel}{$z$}
\newcommand{\fcDelta}{0.5}
\newcommand{\fcZBufferNumXIntervals}{200}
\newcommand{\fcZBufferNumYIntervals}{200}
\newcommand{\fcStartXIId}{0}
\newcommand{\fcStartYIId}{0}
\newcommand{\fcIterationsX}{9\space}
\newcommand{\fcIterationsY}{9\space}
\newcommand{\fcScreenStyle}{z}
\newcommand{\fcLineColor}{black}
\newcommand{\fcLineWidth}{1\space}
\newcommand{\fcArrows}{}
\newcommand{\fcPlotPoints}{200}
\newcommand{\fcLineStyle}{0}
\newcommand{\fcDashLength}{2}
\newcommand{\fcDashesCode}{%
(\fcLineStyle) (dashed) eq %
{[\fcDashLength\space \fcDashLength] 0 setdash}%
{[] 0 setdash}%
ifelse\space %
}
\newcommand{\fcScreen}{[-1 1 -0.5] -1} %default projection plane. Renew this command to change projection plane.
\newcommand{\fcScreenWithSpace}{\fcScreen\space } %Darned LaTeX...

\newcommand{\fcSet}[1]{\setkeys{fcGraphics}{#1}}

\makeatletter %needed for define@key command.
\define@key{pstricks,pst-plot}{xLabel}[]{}
\define@key{pstricks,pst-plot}{yLabel}[]{}
\define@key{pstricks,pst-plot}{zLabel}[]{}
\define@key{fcGraphics}{Delta}[\renewcommand{\fcDelta}{1}]{\renewcommand{\fcDelta}{#1}}
\define@key{fcGraphics}{shiftX}[\renewcommand{\fcShiftX}{0}]{\renewcommand{\fcShiftX}{#1}}
\define@key{fcGraphics}{shiftY}[\renewcommand{\fcShiftY}{0}]{\renewcommand{\fcShiftY}{#1}}
\define@key{fcGraphics}{startX}[\renewcommand{\fcStartXIId}{0}]{\renewcommand{\fcStartXIId}{#1}}
\define@key{fcGraphics}{startY}[\renewcommand{\fcStartYIId}{0}]{\renewcommand{\fcStartYIId}{#1}}
\define@key{fcGraphics}{iterationsX}[\renewcommand{\fcIterationsX}{9\space}]{\renewcommand{\fcIterationsX}{#1\space}}
\define@key{fcGraphics}{iterationsY}[\renewcommand{\fcIterationsY}{9\space}]{\renewcommand{\fcIterationsY}{#1\space}}
\define@key{fcGraphics}{screenStyle}[\renewcommand{\fcScreenStyle}{z}]{\renewcommand{\fcScreenStyle}{#1}}
\define@key{fcGraphics}{xLabel}[\renewcommand{\fcXLabel}{$x$}]{\renewcommand{\fcXLabel}{#1}}
\define@key{fcGraphics}{yLabel}[\renewcommand{\fcYLabel}{$y$}]{\renewcommand{\fcYLabel}{#1}}
\define@key{fcGraphics}{zLabel}[\renewcommand{\fcZLabel}{$z$}]{\renewcommand{\fcZLabel}{#1}}
\define@key{fcGraphics}{linecolor}[\renewcommand{\fcLineColor}{black}]{\renewcommand{\fcLineColor}{#1}}
\define@key{fcGraphics}{linestyle}[\renewcommand{\fcLineStyle}{0}]{\renewcommand{\fcLineStyle}{#1}}
\define@key{fcGraphics}{plotpoints}[\renewcommand{\fcPlotPoints}{200}]{\renewcommand{\fcPlotPoints}{#1}}
\define@key{fcGraphics}{dashes}[\renewcommand{\fcDashLength}{300}]{\renewcommand{\fcDashLength}{#1 \fcConvertPSXUnit\space}}
\define@key{fcGraphics}{arrows}[\renewcommand{\fcArrows}{}]{\renewcommand{\fcArrows}{#1}}
\makeatother %undoes \makeatletter.


\newcommand{\fcHollowDot}[2]{
\pscircle*[fillcolor=white, linecolor=red](#1, #2){0.07}
\pscircle*[fillcolor=white, linecolor=white](#1, #2){0.04}
}

\newcommand{\fcFullDot}[3][linecolor=red]{
\pscircle*[#1](! #2 #3){0.07}
}

\newcommand{\fcHollowDotBlue}[2]{
\pscircle*[fillcolor=white, linecolor=blue](#1, #2){0.07}
\pscircle*[fillcolor=white, linecolor=white](#1, #2){0.04}
}
\newcommand{\fcFullDotBlack}[2]{
\pscircle*[fillcolor=white, linecolor=black](#1, #2){0.07}
}
\newcommand{\fcFullDotBlue}[2]{
\pscircle*[fillcolor=white, linecolor=blue](#1, #2){0.07}
}
\newcommand{\fcXTickColored}[2]{\psline[linecolor=#1](#2, -0.1)(#2,0.1)}

\newcommand{\fcXTick}[1]{\psline(#1, -0.1)(#1,0.1)}
\newcommand{\fcYTick}[1]{\psline(-0.1, #1)(0.1, #1)}
\newcommand{\fcXYTick}[2]{\fcXTick{#1} \fcYTick{#2}}

\newcommand{\fcXTickWithLabel}[2]{\fcXTick{#1}\rput[t](#1,-0.2){#2}}
\newcommand{\fcYTickWithLabel}[2]{\fcYTick{#1}\rput[r](-0.2,#1){#2}}

\newcommand{\fcLabelNumberXaxis}[1]{\fcXTickWithLabel{#1}{#1}}
\newcommand{\fcLabelNumberYaxis}[1]{\fcYTickWithLabel{#1}{#1}}

\newcommand{\fcLabelNumberXYaxes}[2]{\fcLabelNumberXaxis{#1} \fcLabelNumberYaxis{#2} }

\newcommand{\fcLabelXOne}{\fcLabelNumberXaxis{1} }
\newcommand{\fcLabelYOne}{\fcLabelNumberYaxis{1} }

\newcommand{\fcLabelOnXaxis}[2]{\fcXTick{#1}\rput[t](#1,-0.2){#2}}
\newcommand{\fcLabelOnYaxis}[2]{\fcYTick{#1}\rput[r](-0.2, #1){#2}}

\newcommand{\fcLabels}[1][$x$]{%
  \def\ArgpsXAxisLabel{{#1}}%
  \fcLabelsRelay
}
\newcommand\fcLabelsRelay[3][$y$]{\rput[t](! #2 -0.1){\ArgpsXAxisLabel}\rput[r](! -0.1 #3){#1}}

\newcommand{\fcLabelsWithOnes}[2]{\psline(1, -0.1)(1,0.1) \rput[t](1, -0.2 ) { $1$} \psline(-0.1, 1)(0.1, 1) \rput[r](-0.2, 1 ) { $1$} \fcLabels{#1}{#2}}

\newcommand{\fcDefaultXLabel}{$x$}
\newcommand{\fcDefaultYLabel}{$y$}

\newcommand{\fcBoundingBox}[4]{%
\psframe*[linecolor=white](! #1\space #2)(! #3\space #4)%
\psline[linecolor=black!1](! #1 #2 )(! #1 #2 0.01 add)%
\psline[linecolor=black!1](! #3 #4 )(! #3 #4 0.01 add)%
}
\newcommand{\fcAxesStandardNoFrame}[4]{%
\psaxes[ticks=none, labels=none]{<->}(0,0)(#1,#2)(#3,#4)% \fcLabels[\fcDefaultXLabel][\fcDefaultYLabel]{#3}{#4}%
}%

\newcommand{\fcAxesStandard}[4]{%
\psframe*[linecolor=white](! #1\space #2)(! #3 \space 0.1 add #4 \space 0.1 add)%
\fcAxesStandardNoFrame{#1}{#2}{#3}{#4}%
}%
\newcommand{\fcColorTangent}{blue}
\newcommand{\fcColorGraph}{red}
\newcommand{\fcColorAreaUnderGraph}{cyan}
\newcommand{\fcColorNegativeAreaUnderGraph}{orange}

\newcommand{\fcMachine}[2]{
\pscustom*[linecolor=#2]{
\psline(1,1.1)(1,0.1)(1.5,0.1)(2, 0.6)(2.5, 0.6)(2.5, -0.6)(2, -0.6)(1.5,-0.1)(1,-0.1)(1,-1.1)(-1,-1.1)(-1,-0.1)(-1.5,-0.1)(-2, -0.6)(-2.5, -0.6)(-2.5, 0.6)(-2, 0.6)(-1.5,0.1)(-1,0.1)(-1,1.1)
}
\pscircle*[linecolor=white](0,0){0.3}
\rput(0,0){#1}
}

%command format
%first argument gives you formula for the direction field in
%postscript notation, for example x y add.
%second and third argument give the starting x,y coordinates
\newcommand{\fcDirectionFieldOneTangent}[6]{%
\pstVerb{%
3 dict begin%
/x #2 \space def%
/y #3 \space def%
/F #1 \space def%
}%
\psline[#6](! x F ATAN 57.295 mul cos #4 mul sub y F ATAN 57.295 mul sin #4 mul sub)(! x F ATAN 57.295 mul cos #4 mul add y F ATAN 57.295 mul sin #4 mul add)%
\pscircle*[linecolor=red!60](! x y){#5}%
\pstVerb{%
end%
}%
}

\newcommand{\fcDirectionFieldOneTangentDefault}[3]{%
\fcDirectionFieldOneTangent{#1}{#2}{#3}{0.3}{0.03}{linecolor=blue}%
}

%command format
%first argument gives you formula for the direction field in
%postscript notation, for example x y add.
%second and third argument give the starting x,y coordinates
%fourth coordinate gives the delta x=delta y
%fifth argument gives the number of iterations delta x
%sixth argument gives the number of iterations delta y
%seventh argument gives the length of the vector
%eighth  argument gives the circle radius
%ninth argument gives the arguments of the psline command
\newcommand{\fcDirectionFieldFull}[9]{%
\multido{\ra=#2+#4}{#5}{%
\multido{\rb=#3+#4}{#6}{%
\fcDirectionFieldOneTangent{#1}{\ra}{\rb}{#7}{#8}{#9}%
}%end multido
}%end multido
}%end newcommand

\newcommand{\fcDirectionFieldDefault}[5]{%
\fcDirectionFieldFull{#1}{#2}{#3}{#4}{#5}{#5}{0.2}{0.02}{linecolor=blue}%
}%
\newcommand{\fcDirectionFieldDefaultRange}[1]{%
\fcDirectionFieldFull{#1}{-4}{-4}{0.5}{21}{21}{0.2}{0.02}{linecolor=blue}%
}

\newcommand{\fcVectorProjectOntoVector}{%
\fcVectorNormalize dup 3 1 roll \fcVectorScalarVector \fcVectorTimesScalar%
} %

%fcAngleIIId Arguments:
%first optional: pstricks options
%second: vector describing arm of first angle
%third: vector describing arm of second angle
%fourth: radius of arc representing the angle
\newcommand{\fcAngleIIId}[4][]{%
\pstVerb{%
3 dict begin%
/firstV #2 \fcVectorNormalize def%
/orthonormalV #3 dup firstV  \fcVectorProjectOntoVector \fcVectorMinusVector \fcVectorNormalize def%
/theAngle firstV #3\space \fcVectorNormalize \fcVectorScalarVector arccos def%
}%
\parametricplot[#1]{0}{theAngle}{firstV t cos #4 mul \fcVectorTimesScalar orthonormalV t sin #4 mul \fcVectorTimesScalar \fcVectorPlusVector \fcCoordsIIIdToPStricks}%
\pstVerb{end}%
}

\makeatletter
\newcommand{\fcAngle}[5][linecolor=\fcColorGraph]{%
\ifPst@algebraic{%
\parametricplot[#1, algebraic=true]{#2}{#3}{#4*cos(t)| #4*sin(t)}%
\rput(! #2\space #3\space add 2 div 57.29578 mul cos #4\space 0.2 add mul #2\space #3\space add 2 div 57.29578 mul sin #4\space 0.2 add mul){#5}%
}%
\else%
\parametricplot[#1, algebraic=false]{#2}{#3}{t 57.29578 mul cos #4\space mul t 57.29578 mul sin #4\space mul}%
\rput(! #2\space #3\space add 2 div 57.29578 mul cos #4\space 0.2 add mul #2\space #3\space add 2 div 57.29578 mul sin #4\space 0.2 add mul){#5}%
\fi%
}
\makeatother

\newcommand{\fcDistance}{ \fcVectorMinusVector \fcVectorNorm\space}

\newcommand{\fcLengthIndicator}[5]{
\psline[arrows=<-, linecolor=red](! #1 #2)(! #1 0.58 mul #3 0.42 mul add #2 0.58 mul #4 0.42 mul add)
\psline[arrows=->, linecolor=red]{->}(! #1 0.42 mul #3 0.58 mul add #2 0.42 mul #4 0.58 mul add)(! #3 #4)
\rput(! #1 #3 add 0.5 mul #2 #4 add 0.5 mul){ #5}
}

\makeatletter
\newcommand{\fcDrawPolar}[4][linecolor=\fcColorGraph]{%
\ifPst@algebraic{%
\parametricplot[#1]{#2}{#3}{(#4) *cos(t) | (#4) * sin(t)}%
}%
\else%
\parametricplot[#1]{#2}{#3}{#4 t 57.29578 mul cos mul #4 t 57.29578 mul sin mul}%
\fi%
}
\makeatother

\newcommand{\fcPolarCurveEvaluateX}[2]{
1 dict begin /t #1 def #1 57.29578 mul cos #2 mul end
}

\newcommand{\fcPolarCurveEvaluateY}[2]{
1 dict begin /t #1 def #1 57.29578 mul sin #2 mul end
}

\newcommand{\fcPolarCurveEvaluateXY}[2]{
\fcPolarCurveEvaluateX{#1}{#2} \fcPolarCurveEvaluateY{#1}{#2}
}

\newcommand{\fcPolarWedge}[3]{%
\ifPst@algebraic{%
\rput(0,0){Set algebraic to FALSE}%
}%
\else%
\pstVerb{%
%/firstX 1 dict begin /t #1 def #1 57.29578 mul sin #2 mul end def%
/firstX \fcPolarCurveEvaluateX{#1}{#3} def%
/firstY \fcPolarCurveEvaluateY{#1}{#3} def%
/secondX \fcPolarCurveEvaluateX{#2}{#3} def%
/secondY \fcPolarCurveEvaluateY{#2}{#3} def%
}%
\pscustom[fillcolor=\fcColorAreaUnderGraph, fillstyle=solid, linecolor=blue]{%
\psline(0,0)(! \fcPolarCurveEvaluateXY{#1}{#3} )(! \fcPolarCurveEvaluateXY{#2}{#3})(0,0)%
}%
\fi%
}%

\newcommand{\fcPolarWedgeSequence}[4]{%
\multido{\ra=#1+#2}{#3}{%
\fcPolarWedge{\ra}{\ra\space #2 add}{#4}
}%
}

\newcommand{\fcRegularNgon}[3][linecolor=\fcColorGraph]{%
\multido{\ra=0+1}{#2}{%
\psline[#1](! \ra \space #2 div 360 mul cos #3 mul \ra \space #2 div 360 mul sin #3 mul)(! \ra \space 1 add #2 div 360 mul cos #3 mul \ra \space 1 add #2 div 360 mul sin #3 mul)%
}%end multido
}

\newcommand{\fcEvaluateT}[2]{%
1 dict begin /t #1 def #2 end
}

\newcommand{\fcPolylineAlongCurve}[5][linecolor=\fcColorGraph]{%
\multido{\ra=0+1}{#2}{%
\psline[#1](! \fcEvaluateT{\ra\space #2 div #3 mul 1 \ra \space #2 div sub #4 mul add}{#5})(! \fcEvaluateT{\ra\space 1 add #2 div #3 mul 1 \ra \space 1 add #2 div sub #4 mul add}{#5})%
\rput(! \fcEvaluateT{\ra\space #2 div #3 mul 1 \ra \space #2 div sub #4 mul add}{#5}){\fcFullDot{0}{0}}%
}%
\rput(! \fcEvaluateT{#3}{#5}){\fcFullDot{0}{0}}%
}

\newcommand{\fcPolylineAlongCurveWithLabels}[6][linecolor=\fcColorGraph]{%
\fcPolylineAlongCurve[#1]{#2}{#3}{#4}{#5}%
\multido{\ia=0+1}{#2}{%
\rput[b](! \fcEvaluateT{\ia\space #2 div #3 mul 1 \ia \space #2 div sub #4 mul add}{#5} 0.1 add){${#6}_{\ia}$}%
}%
\rput[b](! \fcEvaluateT{#3}{#5}){${#6}_{#2}$}%
}

\newcommand{\fcVectorNormalize}{ %
1 dict begin %
/theV exch def % theV is our vector
theV 1 theV \fcVectorNorm div \fcVectorTimesScalar %
end %
} %pushes elements of array onto the stack

\newcommand{\fcArrayToStack}{ %
\space %
1 dict begin %
/theArray exch def %put array in var.
0 1 theArray length 1 sub %loop parameters
{ theArray exch get %get array member
} for %
end \space%
} %pushes elements of array onto the stack

\newcommand{\fcSpliceArrayOperationArray}{ %
5 dict begin %
/theOp exch def %
/secondV exch def %
/firstV exch def %
/counter 0 def %
/dimension firstV length def %
[dimension {firstV counter get secondV counter get theOp /counter counter 1 add def } repeat] %
end %
} %splices two arrays and operation, for example [a b] [c d] {op} -> [a c op b d op]

\newcommand{\fcSpliceArrayOperation}{ %
4 dict begin %
/theOp exch def %
/firstV exch def %
/counter 0 def %
/dimension firstV length def %
[ dimension {firstV counter get theOp /counter counter 1 add def } repeat ] %
end %
} %splices array with operation. [a b] {op} -> [a op b op]

\newcommand{\fcArrayOperation}{ %
4 dict begin %
/theOp exch def %
/firstV exch def %
/counter 0 def%
/dimension firstV length def %
dimension {firstV counter get /counter counter 1 add def} repeat %
dimension 1 sub {theOp} repeat %
end %
} %applies operation n-1 times to array. Example: [a b c] {op} -> a b c op op

\newcommand{\fcVectorScalarVector}{%
{mul} \fcSpliceArrayOperationArray {add}\fcArrayOperation
} %Scalar product two vectors

\newcommand{\fcVectorPlusVector}{%
{add} \fcSpliceArrayOperationArray %
} %Adds two vectors

\newcommand{\fcVectorMinusVector}{%
{sub} \fcSpliceArrayOperationArray %
} %Adds two vectors

\newcommand{\fcVectorTimesScalar}{ %
2 dict begin %
/theScalar exch def %
/theV exch def %
theV {theScalar mul} \fcSpliceArrayOperation %
end %
} %

\newcommand{\fcVectorTripleProduct}{%
\fcVectorCrossVector \fcVectorScalarVector\space %
}

\newcommand{\fcVectorCrossVector}{ %
8 dict begin %
/vectB exch def %
/vectA exch def %
vectA \fcArrayToStack %
/a3 exch def %The three coordinates of Vector a
/a2 exch def %
/a1 exch def %
vectB \fcArrayToStack %
/b3 exch def %The three coordinates of Vector b
/b2 exch def %
/b1 exch def %
[a2 b3 mul a3 b2 mul sub a3 b1 mul a1 b3 mul sub a1 b2 mul a2 b1 mul sub] %the cross product of a and b
end %
}

\newcommand{\fcVectorNorm}{%
dup \fcVectorScalarVector sqrt %
} %

\newcommand{\fcVectorNormSquared}{%
dup \fcVectorScalarVector %
} %

\newcommand{\fcProjectOntoScreen}{%
%(calling project onto plane with arguments:) == %
%dup == %
3 dict begin %
\fcScreenWithSpace %
/theD exch def %
/theNormal exch def %
/theV exch def %
theV theNormal theD theV theNormal \fcVectorScalarVector sub theNormal \fcVectorNormSquared div \fcVectorTimesScalar \fcVectorPlusVector %
end %
} %Projection of point onto a plane. First argument is point, second argument is plane normal, third argument is the scalar product you need to have with the normal to be in the plane. Format: [1 2 3] [4 5 6] 7, corresponds to projecting the point (1,2,3) onto the plane 4x+5y+6z=7

\newcommand{\fcCoordsIIIdToPStricks}{%
5 dict begin %
/theV exch def %
/theVprojected theV \fcProjectOntoScreen [0 0 0] \fcProjectOntoScreen  \fcVectorMinusVector def%
/theNormalizedNormal \fcScreenWithSpace pop \fcVectorNormalize def %
(\fcScreenStyle) (z) eq %
{ %
/theYUnitV [0 0 1] \fcProjectOntoScreen [0 0 0] \fcProjectOntoScreen \fcVectorMinusVector \fcVectorNormalize def %
/theXUnitV theNormalizedNormal theYUnitV \fcVectorCrossVector def %
} %
{ %
(\fcScreenStyle) (x) eq %
{
/theXUnitV [1 0 0] \fcProjectOntoScreen [0 0 0] \fcProjectOntoScreen \fcVectorMinusVector \fcVectorNormalize def %
/theYUnitV theXUnitV theNormalizedNormal \fcVectorCrossVector def%
}
{
/theYUnitV \fcScreenStyle \fcProjectOntoScreen [0 0 0] \fcProjectOntoScreen \fcVectorMinusVector \fcVectorNormalize def%
/theXUnitV theNormalizedNormal theYUnitV \fcVectorCrossVector def%
} ifelse%
}%
ifelse %
%(normalized normal: ) == theNormalizedNormal ==
%(y unit v) == theYUnitV ==
%(x unit v: ) == theXUnitV ==
theVprojected theXUnitV \fcVectorScalarVector theVprojected theYUnitV \fcVectorScalarVector
end %
}

\newcommand{\fcCoordsIIIdToPS}{%
[ exch \fcCoordsIIIdToPStricks ] \fcCoordsPStricksToPS
}

\newcommand{\fcBoxIIId}[5][]{%
\pstVerb{%
4 dict begin%
/visibleCorner #2 def%
/vectorOne #3 #2 \fcVectorMinusVector def%
/vectorTwo #4 #2 \fcVectorMinusVector def%
/vectorThree #5 #2 \fcVectorMinusVector def%
}%
\fcPolyLineIIId[#1]{visibleCorner dup vectorOne \fcVectorPlusVector dup vectorTwo \fcVectorPlusVector dup vectorOne \fcVectorMinusVector dup vectorTwo \fcVectorMinusVector visibleCorner}%
\fcPolyLineIIId[#1]{visibleCorner dup vectorOne \fcVectorPlusVector dup vectorThree \fcVectorPlusVector dup vectorOne \fcVectorMinusVector dup vectorThree \fcVectorMinusVector}%
\fcPolyLineIIId[#1]{visibleCorner vectorTwo \fcVectorPlusVector dup vectorThree \fcVectorPlusVector dup vectorTwo \fcVectorMinusVector}%
\fcPolyLineIIId[#1, linestyle=dashed]{visibleCorner vectorOne  vectorTwo vectorThree \fcVectorPlusVector \fcVectorPlusVector \fcVectorPlusVector dup vectorOne \fcVectorMinusVector}%
\fcPolyLineIIId[#1, linestyle=dashed]{visibleCorner vectorOne  vectorTwo vectorThree \fcVectorPlusVector \fcVectorPlusVector \fcVectorPlusVector dup vectorTwo \fcVectorMinusVector}%
\fcPolyLineIIId[#1, linestyle=dashed]{visibleCorner vectorOne  vectorTwo vectorThree \fcVectorPlusVector \fcVectorPlusVector \fcVectorPlusVector dup vectorThree \fcVectorMinusVector}%
\pstVerb{end}%
}

\newcommand{\fcBoxIIIdFilled}[5][]{%
\pscustom*[#1]{%
\fcPolyLineIIId{4 dict begin%
/visibleCorner #2 def%
/vectorOne #3 #2 \fcVectorMinusVector def%
/vectorTwo #4 #2 \fcVectorMinusVector def%
/vectorThree #5 #2 \fcVectorMinusVector def %
visibleCorner vectorOne \fcVectorPlusVector dup vectorTwo \fcVectorPlusVector dup vectorOne \fcVectorMinusVector dup vectorThree \fcVectorPlusVector dup vectorTwo \fcVectorMinusVector dup vectorOne \fcVectorPlusVector visibleCorner vectorOne \fcVectorPlusVector end %
}%
}%
}

\newcommand{\fcParallelogramIIId}[4][linecolor=cyan!30]{%
\pscustom*[#1]{%
\fcParallelogramHollowIIId{#2}{#3}{#4}%
}%
}

\newcommand{\fcParallelogramHollowIIId}[4][]{ %
\fcPolyLineIIId[#1]{3 dict begin /corner #2 def /vectorOne #3 #2 \fcVectorMinusVector def /vectorTwo #4 #2 \fcVectorMinusVector def corner dup vectorOne \fcVectorPlusVector dup vectorTwo \fcVectorPlusVector dup vectorOne \fcVectorMinusVector corner end
}%
}

\newcommand{\fcParallelogramHalfVisibleIIId}[4][]{%
\pstVerb{3 dict begin /corner #2 def /vectorOne #3 #2 \fcVectorMinusVector def /vectorTwo #4 #2 \fcVectorMinusVector def}%
\fcPolyLineIIId[#1]{corner vectorOne \fcVectorPlusVector corner dup vectorTwo \fcVectorPlusVector}%
\fcPolyLineIIId[#1,linestyle=dashed]{corner vectorOne \fcVectorPlusVector dup vectorTwo \fcVectorPlusVector dup vectorOne \fcVectorMinusVector}%
\pstVerb{end}%
}

\newcommand{\fcPolyLineIIId}[2][linecolor=black]{%
\listplot[#1]{ [#2] {\fcCoordsIIIdToPStricks} \fcSpliceArrayOperation \fcArrayToStack}%
}

\makeatletter %makes the @ symbol usable temporarily

\newcommand{\fcConvertPSXYUnit}{\fcShiftX\space sub \stripPoints{\psxunit} 72.27 div 8000 mul mul\space %
\pst@number\pst@dima\space %3 sub 
72.27 div 8000 mul sub  %
}%I have no clue why this works. Since the pstricks.tex code is a cesspool of filth, it is not possible for me to decode what it does, so this is the best I could do.
\newcommand{\fcConvertPSYUnit}{\fcShiftY\space sub \stripPoints{\psyunit} 72.27 div -8000 mul mul\space %
\pst@number\pst@dimb\space 72.27 div -8000 mul sub %
}%I have no clue why this works. Since the pstricks.tex code is a cesspool of filth, it is not possible for me to decode what it does, so this is the best I could do.
\makeatother

%\newcommand{\fcCoordsPStricksToPS}{\fcArrayToStack \fcConvertPSYUnit exch \fcConvertPSXUnit exch\space }
\makeatletter
\newcommand{\fcCoordsPStricksToPS}{\fcArrayToStack \tx@ScreenCoor\space }
\makeatother

\newcommand{\fcLine}[3][]{%
\pscustom{%
\code{%
1 setlinewidth newpath %
#2\space \fcCoordsPStricksToPS moveto %
#3\space \fcCoordsPStricksToPS lineto %
stroke %
}%
}%
}

\newcommand{\fcLineFormatCode}{\fcDashesCode \fcLineWidth\space setlinewidth }

\newcommand{\fcCurveCode}{%
%(calling fcCurveCode) == %
5 dict begin %
%newpath 0 0 moveto 1000 1000 lineto stroke
/theCurve exch def %
%theCurve == %
/tMin exch def%
/tMax exch def%
/Delta tMax tMin sub \fcPlotPoints \space 1 sub div def %
/t tMin def %
\fcLineFormatCode %
newpath %
theCurve \fcCoordsPStricksToPS moveto %
\fcPlotPoints\space 1 sub {/t t Delta add def theCurve \fcCoordsPStricksToPS lineto %
} repeat %
stroke %
end\space%
}

\newcommand{\fcCurve}[4][]{%
\setkeys{fcGraphics}{#1}%
\pstVerb{#2\space #3\space {#4} \space \fcCurveCode}%
}

\newcommand{\fcLineIIId}[3][linecolor=black]{%
\psline[#1](! #2 \space \fcCoordsIIIdToPStricks)(! #3 \space \fcCoordsIIIdToPStricks)%
}
\newcommand{\fcAxesIIIdFull}[4][linecolor=black, arrows=->]{%
\fcAxesIIId[#1]{#2}{#3}{#4}%
\fcLineIIId[#1]{[0 0 0]}{[#2\space -1 mul 0 0]}%
\fcLineIIId[#1]{[0 0 0]}{[0 #3\space -1 mul 0]}%
\fcLineIIId[#1]{[0 0 0]}{[0 0 #4\space -1 mul]}%
} %

\newcommand{\fcAxesIIId}[4][linecolor=black, arrows=->]{%
\setkeys{fcGraphics}{#1}%
\fcLineIIId[#1]{[0 0 0]}{[#2 0 0]}%
\rput(! [#2 0 0] \fcCoordsIIIdToPStricks){\fcXLabel}%
\fcLineIIId[#1]{[0 0 0]}{[0 #3 0]}%
\rput(! [0 #3 0] \fcCoordsIIIdToPStricks){\fcYLabel}%
\fcLineIIId[#1]{[0 0 0]}{[0 0 #4]}%
\rput(! [0 0 #4] \fcCoordsIIIdToPStricks){\fcZLabel}%
}

\newcommand{\fcDotIIId}[2][linecolor=\fcColorGraph]{%
\pscircle*[#1](! #2 \fcCoordsIIIdToPStricks){0.07} %
} %

\newcommand{\fcPutIIId}[3][]{ \rput[#1](! #2 \fcCoordsIIIdToPStricks) {#3}%
} %

\newcommand{\fcPaintCone}{ %
\fcArrayToStack %
15 dict begin %
/c exch def %
/b exch def %
/a exch def %
/z1 exch def %
/y1 exch def %
/x1 exch def %
/zmax exch def %
/zmin exch def %
}

\newcommand{\fcAccountBoundingBox}{ %
%(accounting bounding box) == dup == %
\fcArrayToStack %
11 dict begin %
/zmin exch def %
/ymin exch def %
/xmin exch def %
/zmax exch def %
/ymax exch def %
/xmax exch def %
/AccountOneVertex { %
\fcCoordsIIIdToPStricks % 
dup dup ZbufferYmin lt {/ZbufferYmin exch def}{pop}ifelse %
dup ZbufferYmax gt {/ZbufferYmax exch def}{pop}ifelse %
dup dup ZbufferXmin lt {/ZbufferXmin exch def}{pop}ifelse %
dup ZbufferXmax gt {/ZbufferXmax exch def}{pop}ifelse %
} def %
[xmin ymin zmin] AccountOneVertex %
[xmin ymin zmax] AccountOneVertex %
[xmin ymax zmin] AccountOneVertex %
[xmin ymax zmax] AccountOneVertex %
[xmax ymin zmin] AccountOneVertex %
[xmax ymin zmax] AccountOneVertex %
[xmax ymax zmin] AccountOneVertex %
[xmax ymax zmax] AccountOneVertex %
ZbufferXmin ZbufferYmin ZbufferXmax ZbufferYmax %
end %
}

\newcommand{\fcBoundingBoxEllipsoid}{ %
%(calling fcBoundingBoxEllipsoid with input: ) == dup == %
\fcArrayToStack
6 dict begin
/c exch def %
/b exch def %
/a exch def %
/z1 exch def %
/y1 exch def %
/x1 exch def %
[a -1 mul x1 add b -1 mul y1 add c -1 mul z1 add a x1 add b y1 add c z1 add] %
end
}

\newcommand{\fcBoundingBoxCone}{ %
%(calling fcBoundingBoxCone with input: ) == dup ==
\fcArrayToStack %
9 dict begin %
/c exch def %
/b exch def %
/a exch def %
/z1 exch def %
/y1 exch def %
/x1 exch def %
/zmax exch abs def %
abs dup zmax gt {/zmax exch def}{pop}ifelse %
[a c div zmax sqrt div -1 mul b c div zmax sqrt div -1 mul zmax -1 mul  
a c div zmax sqrt div b c div zmax sqrt div zmax
] %
end %
}

\newcommand{\fcPaintObject}{%
(painting object) == \fcArrayToStack dup == 
1 dict begin
4 1 roll setrgbcolor %
/HandlerNotFound true def %
HandlerNotFound{dup (ellipsoid) eq{pop \fcPaintEllipsoid /HandlerNotFound false def}  if} if %
HandlerNotFound{dup (cone) eq {pop \fcPaintCone /HandlerNotFound false def} if} if %
HandlerNotFound{== (ERROR: OBJECT PAINTING HANDLER NOT FOUND)} if %
(passed without crash ) ==
pstack %
end %
}%

\newcommand{\fcStartIIIdScene}{%
\pstVerb{%
1 dict begin %
/theIIIdObjects [] def %
}%
}

\newcommand{\fcComputeBoundingBoxObject}{%
\fcArrayToStack %
4 1 roll pop pop pop %<- remove the color data
%(computing bounding box for) ==  dup == %
1 dict begin %
/HandlerNotFound true def %
dup (ellipsoid) eq{pop \fcBoundingBoxEllipsoid /HandlerNotFound false def} if
dup (cone) eq {pop \fcBoundingBoxCone /HandlerNotFound false def} if %
HandlerNotFound {== (ERROR: OBJECT PAINTING HANDLER NOT FOUND)[0 0 0 0 0 0]} if %
\fcAccountBoundingBox %
end %
/ZbufferYmax exch def %
/ZbufferXmax exch def %
/ZbufferYmin exch def %
/ZbufferXmin exch def %
%(recomputed bounding box, current box: ) print %
%ZbufferXmin == ZbufferYmin == %
%ZbufferXmax == ZbufferYmax == %
}

\newcommand{\fcFinishIIIdScene}{%
\pscustom{%
\code{%
%print the objects we are about to paint:
theIIIdObjects length 0 gt { %
(about to process IIId scene given by: ) print %
theIIIdObjects == %
} if %
5 dict begin %
/ZbufferXmin 0 def %
/ZbufferYmin 0 def %
/ZbufferXmax 0 def %
/ZbufferYmax 0 def %
(computing bounding box for the IIId scene... ) print
theIIIdObjects \fcArrayToStack theIIIdObjects length {\fcComputeBoundingBoxObject } repeat %
(bounding box computed: ) print %
ZbufferXmin == ZbufferYmin == %
ZbufferXmax == ZbufferYmax == %
%/theZBuffer [ \fcZBufferNumYIntervals {\fcZBufferNumXIntervals array}repeat  ] def %
theIIIdObjects \fcArrayToStack theIIIdObjects length {\fcPaintObject } repeat %
end %
}%
}%
\pstVerb{end}
}%

\newcommand{\fcSurfaceIIIdUConstCode}{%
10 dict begin %
/theSurface exch def %
/vMax exch def %
/uMax exch def %
/vMin exch def %
/uMin exch def %
/DeltaU uMax uMin sub \fcIterationsX\space 1 sub div def %
/u uMin def %
/v {t} def %
\fcIterationsX {vMin vMax {theSurface} \fcCurveIIIdCode /u u DeltaU add def} repeat %
end %
}

\newcommand{\fcSurfaceIIIdVConstCode}{%
10 dict begin%
/theSurface exch def %
/vMax exch def %
/uMax exch def %
/vMin exch def %
/uMin exch def %
/DeltaV vMax vMin sub \fcIterationsY\space 1 sub div def %
/v vMin def %
/u {t} def %
\fcIterationsY {uMin uMax {theSurface} \fcCurveIIIdCode /v v DeltaV add def} repeat %
end %
}

\newcommand{\fcSurfaceIIIdCode}{%
5 copy \fcSurfaceIIIdUConstCode \fcSurfaceIIIdVConstCode (got here2) == %
}%

\newcommand{\fcPaintEllipsoid}{%
(painting ellipsoid: ) == %
dup == %
\fcArrayToStack %
15 dict begin %
/c exch def %
/b exch def %
/a exch def %
/z1 exch def %
/y1 exch def %
/x1 exch def %
/theSurfaceNormal {[v cos u cos a mul mul v sin u cos b mul mul u sin -1 mul c mul] [v sin -1 mul u sin a mul mul v cos u sin b mul mul 0] \fcVectorCrossVector} def %
0 0 180 360 {[v cos u sin a mul mul x1 add v sin u sin b mul mul y1 add u cos c mul z1 add]} \fcSurfaceIIIdCode %
end %
(got here3) ==
}

\newcommand{\fcGetCurrentColorCode}{
2 dict begin
/theColor {0 0 0} def %
/colorNotFound true def %
(\fcLineColor) (red) eq{/theColor {1 0 0} def /colorNotFound false def}if %
(\fcLineColor) (blue) eq{/theColor {0 0 1} def /colorNotFound false def}if %
(\fcLineColor) (green) eq{/theColor {0 1 0} def /colorNotFound false def}if %
colorNotFound{/theColor {\fcLineColor} def}if %
theColor %
end %
}

%Let the ellipsoid be given by the set of points  (x,y,z), for which (x-x1)^2/a^2+ (y-y1)/b^2 +(z-z1)^2/c^2=1, where x1, y1, z1, a, b, c are the parameters of the ellipsoid. We store the ellipsoid as the data a, b, c in the data structure [ [x1 y1 z1 a b c] (ellipsoid)]
\newcommand{\fcEllipsoid}[2][linecolor=red]{%
\setkeys{fcGraphics}{#1}%
\pstVerb{%
9 dict begin %
%default 
mark #2\space %
/c exch def %
/b exch def %
/a exch def %
/x1 0 def %
/y1 0 def %
/z1 0 def %
counttomark 0 gt{ %
/z1 exch def %
/y1 exch def %
/x1 exch def %
}if %
pop %remove the mark
[theIIIdObjects \fcArrayToStack [[x1 y1 z1 a b c] \fcGetCurrentColorCode (ellipsoid)] ] %
end %
/theIIIdObjects exch def %
}%
}

%Let the cone be given by the set of points  (x,y,z), for which (x-x1)^2/a^2+ (y-y1)/b^2 =(z-z1)^2/c^2, where x1, y1, z1, a, b, c are the parameters of the cone. We plot the cone from zmin to zmax We store the ellipsoid as the data a, b, c in the data structure [ [zmin zmax x1 y1 z1 a b c] (ellipsoid)]
\newcommand{\fcCone}[2][linecolor=red]{%
\setkeys{fcGraphics}{#1}%
\pstVerb{%
11 dict begin %
%default 
mark #2\space %
/c exch def %
/b exch def %
/a exch def %
/x1 0 def %
/y1 0 def %
/z1 0 def %
counttomark 2 gt{ %
/x1 exch def %
/y1 exch def %
/z1 exch def %
}if %
counttomark 1 gt{ %
/zmax exch def %
/zmin exch def %
}if %
pop %remove the mark
[theIIIdObjects \fcArrayToStack [[zmin zmax x1 y1 z1 a b c] \fcGetCurrentColorCode (cone)] ] %
end %
/theIIIdObjects exch def %
}%
}

\newcommand{\fcCurveIIIdBlockingScreenCode}{%
10 dict begin %
/currentStyle (empty) def %
theBlockingScreen %
/theBlockingScreenDepth exch def %
/theBlockingScreenNormal exch def %
/getStyle { %
firstPoint  theBlockingScreenNormal \fcVectorScalarVector theBlockingScreenDepth lt %
secondPoint theBlockingScreenNormal \fcVectorScalarVector theBlockingScreenDepth lt %
or {(normal)}{(dashed)} ifelse %
} def %
/setDashes {currentStyle (dashed) eq {[\fcDashLength \space \fcDashLength] 0 setdash}{[] 0 setdash} ifelse} def %
/firstPoint theCurve def %
/t t Delta add def %
/secondPoint theCurve def %
/currentStyle getStyle def %
setDashes %
newpath %
firstPoint \fcCoordsIIIdToPS moveto %
/remainingCycles numPoints 1 sub def %
remainingCycles {% 
  /remainingCycles remainingCycles 1 sub def %
  secondPoint \fcCoordsIIIdToPS lineto %
  /firstPoint secondPoint def %
  remainingCycles 0 gt { %
    /t t Delta add def %
    /secondPoint theCurve def %
    getStyle currentStyle ne %
    {stroke /currentStyle getStyle def setDashes newpath firstPoint \fcCoordsIIIdToPS moveto %
    }if %
  }if %
} repeat %
stroke %
end %
}

\newcommand{\fcCurveIIIdStandardCode}{%
newpath %
theCurve \fcCoordsIIIdToPS moveto %
numPoints 1 sub {/t t Delta add def theCurve \fcCoordsIIIdToPS lineto } repeat %
stroke %
}%

\newcommand{\fcCurveIIIdNormalVectorCode}{%
10 dict begin %
/firstPoint theCurve def %
/firstNormal theSurfaceNormal def %
/t t Delta add def %
/secondPoint theCurve def %
/secondNormal theSurfaceNormal def %
/currentStyle (normal) def %
/previousStyle (normal) def %
/screenNormal \fcScreenWithSpace pop def %
/computeStyle { %
firstNormal  screenNormal \fcVectorScalarVector 0 le  %
secondNormal screenNormal \fcVectorScalarVector 0 le  %
or %
{/currentStyle (normal) def} %
{/currentStyle (dashed) def} %
ifelse %
} def %
/applyStyle {currentStyle (dashed) eq {%setting style for lines that are not visible under orthographic projection (usually drawing them with a dashed line)
[\fcDashLength\space \fcDashLength] 0 setdash %
}{%
[] 0 setdash %
} ifelse} def %
newpath %
firstPoint \fcCoordsIIIdToPS moveto %
/remainingCycles numPoints 1 sub def %
remainingCycles {% 
  /remainingCycles remainingCycles 1 sub def %
  secondPoint \fcCoordsIIIdToPS  lineto %
  /firstPoint secondPoint def %
  /firstNormal secondNormal def %
  remainingCycles 0 gt { %
    /t t Delta add def %
    /secondPoint theCurve def %
    /secondNormal theSurfaceNormal def %
	/previousStyle currentStyle def %
	computeStyle %
	previousStyle currentStyle ne %
    {stroke applyStyle newpath firstPoint \fcCoordsIIIdToPS moveto %
    }if %
  }if %
} repeat %
stroke %
end %
}

\newcommand{\fcCurveIIIdCode}{%
15 dict begin%
/theCurve exch def%
/tMax exch def%
/tMin exch def%
/numPoints \fcPlotPoints\space def%
/Delta tMax tMin sub numPoints 1 sub div def%
/t tMin def %
\fcLineFormatCode %
/theSurfaceNormal where %
{ %surfaceNormal is defined 
pop % remove dictionary from the stack
\fcCurveIIIdNormalVectorCode %
} %
{ %
/theBlockingScreen where %
{%theBlockingScreen is defined
pop %remove dictionary from stack
\fcCurveIIIdBlockingScreenCode %
} %
{ %
\fcCurveIIIdStandardCode %
}ifelse %
}ifelse %
end %
}


\newcommand{\fcCurveIIId}[4][linecolor=\fcColorGraph]{%
\parametricplot[#1]{#2}{#3}{#4 \fcCoordsIIIdToPStricks}%
}

\newcommand{\fcCurveIIIdBlockedByScreen}[5][linecolor=\fcColorGraph]{%
\setkeys{fcGraphics}{#1}%
\pstVerb{%
1 dict begin
/theBlockingScreen {#5} def %
#2\space #3 \space {#4} \fcCurveIIIdCode %
end%
}%
}

\newcommand{\fcZeroVector}{%
[ exch { 0 } repeat ]
}

\newcommand{\fcPerpendicularComputeHeel}[3]{%
\pstVerb{%
7 dict begin%
/thePoint #1 def%
/heelSize #3 def %
mark #2 %
counttomark 1 eq {%
/directionUnitVector exch \fcVectorNormalize def%
/basePoint thePoint length \fcZeroVector def%
}{%
/basePoint exch def%
/directionUnitVector exch basePoint \fcVectorMinusVector \fcVectorNormalize def%
} ifelse %
pop%
/heel directionUnitVector thePoint basePoint \fcVectorMinusVector directionUnitVector \fcVectorScalarVector \fcVectorTimesScalar basePoint \fcVectorPlusVector def%
%heel == %
/perpendicularUnitVector thePoint heel \fcVectorMinusVector \fcVectorNormalize def %
%perpendicularUnitVector == %
/polyLineInput {%
heel directionUnitVector heelSize \fcVectorTimesScalar \fcVectorMinusVector %
%dup ==
dup perpendicularUnitVector heelSize \fcVectorTimesScalar \fcVectorPlusVector %
heel perpendicularUnitVector heelSize \fcVectorTimesScalar \fcVectorPlusVector%
} def%
}%
}

\newcommand{\fcPerpendicular}[4][]{%
\fcPerpendicularComputeHeel{#2}{#3}{#4}%
\psline[#1](! thePoint \fcArrayToStack)(! heel \fcArrayToStack)%
\listplot[linecolor=red]{ [polyLineInput] {\fcArrayToStack} \fcSpliceArrayOperation \fcArrayToStack}%
\pstVerb{end}%
}

\newcommand{\fcPerpendicularIIId}[4][]{%
\fcPerpendicularComputeHeel{#2}{#3}{#4}%
\fcLineIIId[#1]{thePoint}{heel}%
\fcPolyLineIIId[linecolor=red]{polyLineInput}%
\pstVerb{end}%
}%

\newcommand{\fcPlotIIId}[7][]{%
\fcPlotIIIdXconst[#1]{#2}{#3}{#4}{#5}{#6}{#7}%
\fcPlotIIIdYconst[#1]{#2}{#3}{#4}{#5}{#6}{#7}%
}
\newcommand{\fcPlotIIIdXconst}[7][]{%
\setkeys{fcGraphics}{#2}%
\multido{\ra=0+1}{\fcIterationsX}{%
\pstVerb{%
3 dict begin %
/x \ra \space #3 mul \fcIterationsX \space \ra \space sub 1 sub  #5\space mul add \fcIterationsX\space 1 sub div def%
/ymin #4 def%
/ymax #6 def%
}%
\parametricplot[#1]{ymin}{ymax}{%
1 dict begin /y t def  [x y #7] \fcCoordsIIIdToPStricks end%
}%
\pstVerb{end}%
}%end multido
}

\newcommand{\fcPlotIIIdYconst}[7][]{%
\setkeys{fcGraphics}{#2}%
\multido{\ra=0+1}{\fcIterationsY}{%
\pstVerb{%
3 dict begin%
/y \ra \space #4 mul \fcIterationsY \space \ra \space sub 1 sub  #6\space mul add \fcIterationsY\space 1 sub div def%
/xmin #3 def%
/xmax #5 def%
}%
\parametricplot[#1]{xmin}{xmax}{%
1 dict begin /x t def  [x y #7] \fcCoordsIIIdToPStricks end%
}%
\pstVerb{end}%
}%end multido
}

\newcommand{\fcSurfaceIIIdUConst}[7][]{%
\setkeys{fcGraphics}{#2}%
\multido{\ra=0+1}{\fcIterationsX}{%
\pstVerb{%
3 dict begin%
/u \ra \space #3 mul \fcIterationsX \space \ra \space sub 1 sub  #5\space mul add \fcIterationsX\space 1 sub div def%
/vmin #4 def%
/vmax #6 def%
}%
\parametricplot[#1]{vmin}{vmax}{%
1 dict begin /v t def #7 \fcCoordsIIIdToPStricks end%
}%
\pstVerb{end}%
}%end multido
}

\newcommand{\fcSurfaceIIIdVConst}[7][]{%
\setkeys{fcGraphics}{#2}%
\multido{\ra=0+1}{\fcIterationsY}{%
\pstVerb{%
3 dict begin%
/v \ra \space #4 mul \fcIterationsY \space \ra \space sub 1 sub  #6\space mul add \fcIterationsY\space 1 sub div def%
/umin #3 def%
/umax #5 def%
}%
\parametricplot[#1]{umin}{umax}{%
1 dict begin /u t def #7 \fcCoordsIIIdToPStricks end%
}%
\pstVerb{end}%
}%end multido
}

\newcommand{\fcSurfaceIIId}[7][]{%
\fcSurfaceIIIdUConst[#1]{#2}{#3}{#4}{#5}{#6}{#7}%
\fcSurfaceIIIdVConst[#1]{#2}{#3}{#4}{#5}{#6}{#7}%
}%

\newcommand{\fcVectorField}[3][linecolor=blue]{%
\setkeys{fcGraphics}{#2}%
\multido{\ra=\fcStartXIId+\fcDelta}{\fcIterationsX}{%
\multido{\rb=\fcStartYIId+\fcDelta}{\fcIterationsY}{%
\pstVerb{%
4 dict begin%
/x \ra\space def%
/y \rb\space def %
#3\space%
/vY exch def%
/vX exch def%
}%
\psline[#1](! x vX 2 div sub y vY 2 div sub)(! x vX 2 div add y vY 2 div add)%
\pscircle*[linecolor=red](! x y){0.02}%
\pstVerb{end}%
}%end multido
}%end multido
}%

