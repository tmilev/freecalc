\ProvidesPackage{pstricks-commands}
\usepackage{etex, ifthen}
\usepackage{auto-pst-pdf}
\usepackage{pst-plot}
\usepackage{pst-math}
%WARNING THE FOLLOWING PACKAGE IS BROKEN use only with EXTREME CAUTION
%\usepackage{pst-3dplot}

\makeatletter
\begingroup
\catcode `P=12  % digits and punct. catcode
\catcode `T=12  % digits and punct. catcode
\lowercase{%
\def\x{\def\rem@pt##1.##2PT{##1\ifnum##2>\z@.##2\fi}}}
\expandafter\endgroup\x%
\newcommand{\stripPoints}[1]{\expandafter\rem@pt\the#1}
\makeatother

\newcommand{\fcShiftX}{0}
\newcommand{\fcShiftY}{0}
\newcommand{\fcXLabel}{$x$}
\newcommand{\fcYLabel}{$y$}
\newcommand{\fcZLabel}{$z$}
\newcommand{\fcDelta}{0.5}
\newcommand{\fcZBufferNumXIntervals}{5}
\newcommand{\fcZBufferNumYIntervals}{5}
\newcommand{\fcZBufferRowColumnsUnderInvestigation}{1 3}
\newcommand{\fcStartXIId}{0}
\newcommand{\fcStartYIId}{0}
\newcommand{\fcIterationsX}{9\space}
\newcommand{\fcIterationsY}{9\space}
\newcommand{\fcIterationsU}{4\space}
\newcommand{\fcIterationsV}{4\space}
\newcommand{\fcNumCountourSegmentsPatchU}{4\space}
\newcommand{\fcNumCountourSegmentsPatchV}{4\space}
\newcommand{\fcScreenStyle}{z}
\newcommand{\fcLineColor}{black}
\newcommand{\fcLineWidth}{1\space}
\newcommand{\fcArrows}{}
\newcommand{\fcPlotPoints}{200}
\newcommand{\fcLineStyle}{0}
\newcommand{\fcDashLength}{2}
\newcommand{\fcDashesCode}{%
(\fcLineStyle) (dashed) eq %
{[\fcDashLength\space \fcDashLength] 0 setdash}%
{[] 0 setdash}%
ifelse\space %
}
\newcommand{\fcScreen}{[-1 1 -0.5] -1} %default projection plane. Renew this command to change projection plane.

\newcommand{\fcSet}[1]{\setkeys{fcGraphics}{#1}}

\makeatletter %needed for define@key command.
\define@key{pstricks,pst-plot}{xLabel}[]{}
\define@key{pstricks,pst-plot}{yLabel}[]{}
\define@key{pstricks,pst-plot}{zLabel}[]{}
\define@key{fcGraphics}{Delta}[\renewcommand{\fcDelta}{1}]{\renewcommand{\fcDelta}{#1}}
\define@key{fcGraphics}{shiftX}[\renewcommand{\fcShiftX}{0}]{\renewcommand{\fcShiftX}{#1}}
\define@key{fcGraphics}{shiftY}[\renewcommand{\fcShiftY}{0}]{\renewcommand{\fcShiftY}{#1}}
\define@key{fcGraphics}{startX}[\renewcommand{\fcStartXIId}{0}]{\renewcommand{\fcStartXIId}{#1}}
\define@key{fcGraphics}{startY}[\renewcommand{\fcStartYIId}{0}]{\renewcommand{\fcStartYIId}{#1}}
\define@key{fcGraphics}{iterationsU}[\renewcommand{\fcIterationsU}{9\space}]{\renewcommand{\fcIterationsU}{#1\space}}
\define@key{fcGraphics}{iterationsV}[\renewcommand{\fcIterationsU}{9\space}]{\renewcommand{\fcIterationsV}{#1\space}}
\define@key{fcGraphics}{iterationsX}[\renewcommand{\fcIterationsX}{9\space}]{\renewcommand{\fcIterationsX}{#1\space}}
\define@key{fcGraphics}{iterationsY}[\renewcommand{\fcIterationsY}{9\space}]{\renewcommand{\fcIterationsY}{#1\space}}
\define@key{fcGraphics}{screenStyle}[\renewcommand{\fcScreenStyle}{z}]{\renewcommand{\fcScreenStyle}{#1}}
\define@key{fcGraphics}{xLabel}[\renewcommand{\fcXLabel}{$x$}]{\renewcommand{\fcXLabel}{#1}}
\define@key{fcGraphics}{yLabel}[\renewcommand{\fcYLabel}{$y$}]{\renewcommand{\fcYLabel}{#1}}
\define@key{fcGraphics}{zLabel}[\renewcommand{\fcZLabel}{$z$}]{\renewcommand{\fcZLabel}{#1}}
\define@key{fcGraphics}{linecolor}[\renewcommand{\fcLineColor}{black}]{\renewcommand{\fcLineColor}{#1}}
\define@key{fcGraphics}{linestyle}[\renewcommand{\fcLineStyle}{0}]{\renewcommand{\fcLineStyle}{#1}}
\define@key{fcGraphics}{plotpoints}[\renewcommand{\fcPlotPoints}{200}]{\renewcommand{\fcPlotPoints}{#1}}
\define@key{fcGraphics}{dashes}[\renewcommand{\fcDashLength}{300}]{\renewcommand{\fcDashLength}{#1 \fcConvertPSXUnit\space}}
\define@key{fcGraphics}{arrows}[\renewcommand{\fcArrows}{}]{\renewcommand{\fcArrows}{#1}}
\makeatother %undoes \makeatletter.


\newcommand{\fcHollowDot}[2]{
\pscircle*[fillcolor=white, linecolor=red](#1, #2){0.07}
\pscircle*[fillcolor=white, linecolor=white](#1, #2){0.04}
}

\newcommand{\fcFullDot}[3][linecolor=red]{
\pscircle*[#1](! #2 #3){0.07}
}

\newcommand{\fcFullDotCode}{
gsave
\fcCoordsPStricksToPS [0.02 0] \fcCoordsPStricksToPS pop 0 360 arc 1 0 0 setrgbcolor fill stroke
grestore
}

\newcommand{\fcHollowDotCode}{
gsave
\fcCoordsPStricksToPS [0.04 0] \fcCoordsPStricksToPS pop 0 360 arc 0 1 0 setrgbcolor stroke
grestore
}

\newcommand{\fcHollowDotBlue}[2]{
\pscircle*[fillcolor=white, linecolor=blue](#1, #2){0.07}
\pscircle*[fillcolor=white, linecolor=white](#1, #2){0.04}
}
\newcommand{\fcFullDotBlack}[2]{
\pscircle*[fillcolor=white, linecolor=black](#1, #2){0.07}
}
\newcommand{\fcFullDotBlue}[2]{
\pscircle*[fillcolor=white, linecolor=blue](#1, #2){0.07}
}
\newcommand{\fcXTickColored}[2]{\psline[linecolor=#1](#2, -0.1)(#2,0.1)}

\newcommand{\fcXTick}[1]{\psline(#1, -0.1)(#1,0.1)}
\newcommand{\fcYTick}[1]{\psline(-0.1, #1)(0.1, #1)}
\newcommand{\fcXYTick}[2]{\fcXTick{#1} \fcYTick{#2}}

\newcommand{\fcXTickWithLabel}[2]{\fcXTick{#1}\rput[t](#1,-0.2){#2}}
\newcommand{\fcYTickWithLabel}[2]{\fcYTick{#1}\rput[r](-0.2,#1){#2}}

\newcommand{\fcLabelNumberXaxis}[1]{\fcXTickWithLabel{#1}{#1}}
\newcommand{\fcLabelNumberYaxis}[1]{\fcYTickWithLabel{#1}{#1}}

\newcommand{\fcLabelNumberXYaxes}[2]{\fcLabelNumberXaxis{#1} \fcLabelNumberYaxis{#2} }

\newcommand{\fcLabelXOne}{\fcLabelNumberXaxis{1} }
\newcommand{\fcLabelYOne}{\fcLabelNumberYaxis{1} }

\newcommand{\fcLabelOnXaxis}[2]{\fcXTick{#1}\rput[t](#1,-0.2){#2}}
\newcommand{\fcLabelOnYaxis}[2]{\fcYTick{#1}\rput[r](-0.2, #1){#2}}

\newcommand{\fcLabels}[1][$x$]{%
  \def\ArgpsXAxisLabel{{#1}}%
  \fcLabelsRelay
}
\newcommand\fcLabelsRelay[3][$y$]{\rput[t](! #2 -0.1){\ArgpsXAxisLabel}\rput[r](! -0.1 #3){#1}}

\newcommand{\fcLabelsWithOnes}[2]{\psline(1, -0.1)(1,0.1) \rput[t](1, -0.2 ) { $1$} \psline(-0.1, 1)(0.1, 1) \rput[r](-0.2, 1 ) { $1$} \fcLabels{#1}{#2}}

\newcommand{\fcDefaultXLabel}{$x$}
\newcommand{\fcDefaultYLabel}{$y$}

\newcommand{\fcBoundingBox}[4]{%
\psframe*[linecolor=white](! #1\space #2)(! #3\space #4)%
\psline[linecolor=black!1](! #1 #2 )(! #1 #2 0.01 add)%
\psline[linecolor=black!1](! #3 #4 )(! #3 #4 0.01 add)%
}
\newcommand{\fcAxesStandardNoFrame}[4]{%
\psaxes[ticks=none, labels=none]{<->}(0,0)(#1,#2)(#3,#4)% \fcLabels[\fcDefaultXLabel][\fcDefaultYLabel]{#3}{#4}%
}%

\newcommand{\fcAxesStandard}[4]{%
\psframe*[linecolor=white](! #1\space #2)(! #3 \space 0.1 add #4 \space 0.1 add)%
\fcAxesStandardNoFrame{#1}{#2}{#3}{#4}%
}%
\newcommand{\fcColorTangent}{blue}
\newcommand{\fcColorGraph}{red}
\newcommand{\fcColorAreaUnderGraph}{cyan}
\newcommand{\fcColorNegativeAreaUnderGraph}{orange}

\newcommand{\fcMachine}[2]{
\pscustom*[linecolor=#2]{
\psline(1,1.1)(1,0.1)(1.5,0.1)(2, 0.6)(2.5, 0.6)(2.5, -0.6)(2, -0.6)(1.5,-0.1)(1,-0.1)(1,-1.1)(-1,-1.1)(-1,-0.1)(-1.5,-0.1)(-2, -0.6)(-2.5, -0.6)(-2.5, 0.6)(-2, 0.6)(-1.5,0.1)(-1,0.1)(-1,1.1)
}
\pscircle*[linecolor=white](0,0){0.3}
\rput(0,0){#1}
}

%command format
%first argument gives you formula for the direction field in
%postscript notation, for example x y add.
%second and third argument give the starting x,y coordinates
\newcommand{\fcDirectionFieldOneTangent}[6]{%
\pstVerb{%
3 dict begin%
/x #2 \space def%
/y #3 \space def%
/F #1 \space def%
}%
\psline[#6](! x F ATAN 57.295 mul cos #4 mul sub y F ATAN 57.295 mul sin #4 mul sub)(! x F ATAN 57.295 mul cos #4 mul add y F ATAN 57.295 mul sin #4 mul add)%
\pscircle*[linecolor=red!60](! x y){#5}%
\pstVerb{%
end%
}%
}

\newcommand{\fcDirectionFieldOneTangentDefault}[3]{%
\fcDirectionFieldOneTangent{#1}{#2}{#3}{0.3}{0.03}{linecolor=blue}%
}

%command format
%first argument gives you formula for the direction field in
%postscript notation, for example x y add.
%second and third argument give the starting x,y coordinates
%fourth coordinate gives the delta x=delta y
%fifth argument gives the number of iterations delta x
%sixth argument gives the number of iterations delta y
%seventh argument gives the length of the vector
%eighth  argument gives the circle radius
%ninth argument gives the arguments of the psline command
\newcommand{\fcDirectionFieldFull}[9]{%
\multido{\ra=#2+#4}{#5}{%
\multido{\rb=#3+#4}{#6}{%
\fcDirectionFieldOneTangent{#1}{\ra}{\rb}{#7}{#8}{#9}%
}%end multido
}%end multido
}%end newcommand

\newcommand{\fcDirectionFieldDefault}[5]{%
\fcDirectionFieldFull{#1}{#2}{#3}{#4}{#5}{#5}{0.2}{0.02}{linecolor=blue}%
}%
\newcommand{\fcDirectionFieldDefaultRange}[1]{%
\fcDirectionFieldFull{#1}{-4}{-4}{0.5}{21}{21}{0.2}{0.02}{linecolor=blue}%
}

\newcommand{\fcVectorProjectOntoVector}{%
\fcVectorNormalize dup 3 1 roll \fcVectorScalarVector \fcVectorTimesScalar%
} %

%fcAngleIIId Arguments:
%first optional: pstricks options
%second: vector describing arm of first angle
%third: vector describing arm of second angle
%fourth: radius of arc representing the angle
\newcommand{\fcAngleIIId}[4][]{%
\pstVerb{%
3 dict begin%
/firstV #2 \fcVectorNormalize def%
/orthonormalV #3 dup firstV  \fcVectorProjectOntoVector \fcVectorMinusVector \fcVectorNormalize def%
/theAngle firstV #3\space \fcVectorNormalize \fcVectorScalarVector arccos def%
}%
\parametricplot[#1]{0}{theAngle}{firstV t cos #4 mul \fcVectorTimesScalar orthonormalV t sin #4 mul \fcVectorTimesScalar \fcVectorPlusVector \fcCoordsIIIdToPStricks}%
\pstVerb{end}%
}

\makeatletter
\newcommand{\fcAngle}[5][linecolor=\fcColorGraph]{%
\ifPst@algebraic{%
\parametricplot[#1, algebraic=true]{#2}{#3}{#4*cos(t)| #4*sin(t)}%
\rput(! #2\space #3\space add 2 div 57.29578 mul cos #4\space 0.2 add mul #2\space #3\space add 2 div 57.29578 mul sin #4\space 0.2 add mul){#5}%
}%
\else%
\parametricplot[#1, algebraic=false]{#2}{#3}{t 57.29578 mul cos #4\space mul t 57.29578 mul sin #4\space mul}%
\rput(! #2\space #3\space add 2 div 57.29578 mul cos #4\space 0.2 add mul #2\space #3\space add 2 div 57.29578 mul sin #4\space 0.2 add mul){#5}%
\fi%
}
\makeatother

\newcommand{\fcDistance}{ \fcVectorMinusVector \fcVectorNorm\space}

\newcommand{\fcLengthIndicator}[5]{
\psline[arrows=<-, linecolor=red](! #1 #2)(! #1 0.58 mul #3 0.42 mul add #2 0.58 mul #4 0.42 mul add)
\psline[arrows=->, linecolor=red]{->}(! #1 0.42 mul #3 0.58 mul add #2 0.42 mul #4 0.58 mul add)(! #3 #4)
\rput(! #1 #3 add 0.5 mul #2 #4 add 0.5 mul){ #5}
}

\makeatletter
\newcommand{\fcDrawPolar}[4][linecolor=\fcColorGraph]{%
\ifPst@algebraic{%
\parametricplot[#1]{#2}{#3}{(#4) *cos(t) | (#4) * sin(t)}%
}%
\else%
\parametricplot[#1]{#2}{#3}{#4 t 57.29578 mul cos mul #4 t 57.29578 mul sin mul}%
\fi%
}
\makeatother

\newcommand{\fcPolarCurveEvaluateX}[2]{
1 dict begin /t #1 def #1 57.29578 mul cos #2 mul end
}

\newcommand{\fcPolarCurveEvaluateY}[2]{
1 dict begin /t #1 def #1 57.29578 mul sin #2 mul end
}

\newcommand{\fcPolarCurveEvaluateXY}[2]{
\fcPolarCurveEvaluateX{#1}{#2} \fcPolarCurveEvaluateY{#1}{#2}
}

\newcommand{\fcPolarWedge}[3]{%
\ifPst@algebraic{%
\rput(0,0){Set algebraic to FALSE}%
}%
\else%
\pstVerb{%
%/firstX 1 dict begin /t #1 def #1 57.29578 mul sin #2 mul end def%
/firstX \fcPolarCurveEvaluateX{#1}{#3} def%
/firstY \fcPolarCurveEvaluateY{#1}{#3} def%
/secondX \fcPolarCurveEvaluateX{#2}{#3} def%
/secondY \fcPolarCurveEvaluateY{#2}{#3} def%
}%
\pscustom[fillcolor=\fcColorAreaUnderGraph, fillstyle=solid, linecolor=blue]{%
\psline(0,0)(! \fcPolarCurveEvaluateXY{#1}{#3} )(! \fcPolarCurveEvaluateXY{#2}{#3})(0,0)%
}%
\fi%
}%

\newcommand{\fcPolarWedgeSequence}[4]{%
\multido{\ra=#1+#2}{#3}{%
\fcPolarWedge{\ra}{\ra\space #2 add}{#4}
}%
}

\newcommand{\fcRegularNgon}[3][linecolor=\fcColorGraph]{%
\multido{\ra=0+1}{#2}{%
\psline[#1](! \ra \space #2 div 360 mul cos #3 mul \ra \space #2 div 360 mul sin #3 mul)(! \ra \space 1 add #2 div 360 mul cos #3 mul \ra \space 1 add #2 div 360 mul sin #3 mul)%
}%end multido
}

\newcommand{\fcEvaluateT}[2]{%
1 dict begin /t #1 def #2 end
}

\newcommand{\fcPolylineAlongCurve}[5][linecolor=\fcColorGraph]{%
\multido{\ra=0+1}{#2}{%
\psline[#1](! \fcEvaluateT{\ra\space #2 div #3 mul 1 \ra \space #2 div sub #4 mul add}{#5})(! \fcEvaluateT{\ra\space 1 add #2 div #3 mul 1 \ra \space 1 add #2 div sub #4 mul add}{#5})%
\rput(! \fcEvaluateT{\ra\space #2 div #3 mul 1 \ra \space #2 div sub #4 mul add}{#5}){\fcFullDot{0}{0}}%
}%
\rput(! \fcEvaluateT{#3}{#5}){\fcFullDot{0}{0}}%
}

\newcommand{\fcPolylineAlongCurveWithLabels}[6][linecolor=\fcColorGraph]{%
\fcPolylineAlongCurve[#1]{#2}{#3}{#4}{#5}%
\multido{\ia=0+1}{#2}{%
\rput[b](! \fcEvaluateT{\ia\space #2 div #3 mul 1 \ia \space #2 div sub #4 mul add}{#5} 0.1 add){${#6}_{\ia}$}%
}%
\rput[b](! \fcEvaluateT{#3}{#5}){${#6}_{#2}$}%
}

\newcommand{\fcVectorNormalize}{ %
1 dict begin %
/theV exch def % theV is our vector
theV 1 theV \fcVectorNorm div \fcVectorTimesScalar %
end %
} %pushes elements of array onto the stack

\newcommand{\fcArrayToStack}{ %
aload pop
} %pushes elements of array onto the stack

\newcommand{\fcSpliceArrayOperationArray}{ %
5 dict begin %
/theOp exch def %
/secondV exch def %
/firstV exch def %
/counter 0 def %
/dimension firstV length def %
[dimension {firstV counter get secondV counter get theOp /counter counter 1 add def } repeat] %
end %
} %splices two arrays and operation, for example [a b] [c d] {op} -> [a c op b d op]

\newcommand{\fcSpliceArrayOperation}{ %
4 dict begin %
/theOp exch def %
/firstV exch def %
/counter 0 def %
/dimension firstV length def %
[ dimension {firstV counter get theOp /counter counter 1 add def } repeat ] %
end %
} %splices array with operation. [a b] {op} -> [a op b op]

\newcommand{\fcArrayOperation}{ %
4 dict begin %
/theOp exch def %
/firstV exch def %
/counter 0 def%
/dimension firstV length def %
dimension {firstV counter get /counter counter 1 add def} repeat %
dimension 1 sub {theOp} repeat %
end %
} %applies operation n-1 times to array. Example: [a b c] {op} -> a b c op op

\newcommand{\fcVectorScalarVector}{%
{mul} \fcSpliceArrayOperationArray {add}\fcArrayOperation
} %Scalar product two vectors

\newcommand{\fcVectorPlusVector}{%
{add} \fcSpliceArrayOperationArray %
} %Adds two vectors

\newcommand{\fcVectorMinusVector}{%
{sub} \fcSpliceArrayOperationArray %
} %Adds two vectors

\newcommand{\fcVectorTimesScalar}{ %
2 dict begin %
/theScalar exch def %
/theV exch def %
theV {theScalar mul} \fcSpliceArrayOperation %
end %
} %

\newcommand{\fcVectorTripleProduct}{%
\fcVectorCrossVector \fcVectorScalarVector\space %
}

\newcommand{\fcVectorCrossVector}{ %
8 dict begin %
/vectB exch def %
/vectA exch def %
vectA \fcArrayToStack %
/a3 exch def %The three coordinates of Vector a
/a2 exch def %
/a1 exch def %
vectB \fcArrayToStack %
/b3 exch def %The three coordinates of Vector b
/b2 exch def %
/b1 exch def %
[a2 b3 mul a3 b2 mul sub a3 b1 mul a1 b3 mul sub a1 b2 mul a2 b1 mul sub] %the cross product of a and b
end %
}

\newcommand{\fcVectorNorm}{%
dup \fcVectorScalarVector sqrt %
} %

\newcommand{\fcVectorNormSquared}{%
dup \fcVectorScalarVector %
} %

\newcommand{\fcProjectOntoScreen}{%
%(calling project onto plane with arguments:) == %
%dup == %
3 dict begin %
\fcScreen\space %
/theD exch def %
/theNormal exch def %
/theV exch def %
theV theNormal theD theV theNormal \fcVectorScalarVector sub theNormal \fcVectorNormSquared div \fcVectorTimesScalar \fcVectorPlusVector %
end %
} %Projection of point onto a plane. First argument is point, second argument is plane normal, third argument is the scalar product you need to have with the normal to be in the plane. Format: [1 2 3] [4 5 6] 7, corresponds to projecting the point (1,2,3) onto the plane 4x+5y+6z=7

\newcommand{\fcCoordsIIIdToPStricks}{%
5 dict begin %
/theV exch def %
/theVprojected theV \fcProjectOntoScreen [0 0 0] \fcProjectOntoScreen  \fcVectorMinusVector def%
/theNormalizedNormal \fcScreen\space pop \fcVectorNormalize def %
(\fcScreenStyle) (z) eq %
{ %
/theYUnitV [0 0 1] \fcProjectOntoScreen [0 0 0] \fcProjectOntoScreen \fcVectorMinusVector \fcVectorNormalize def %
/theXUnitV theNormalizedNormal theYUnitV \fcVectorCrossVector def %
} %
{ %
(\fcScreenStyle) (x) eq %
{
/theXUnitV [1 0 0] \fcProjectOntoScreen [0 0 0] \fcProjectOntoScreen \fcVectorMinusVector \fcVectorNormalize def %
/theYUnitV theXUnitV theNormalizedNormal \fcVectorCrossVector def%
}
{
/theYUnitV \fcScreenStyle \fcProjectOntoScreen [0 0 0] \fcProjectOntoScreen \fcVectorMinusVector \fcVectorNormalize def%
/theXUnitV theNormalizedNormal theYUnitV \fcVectorCrossVector def%
} ifelse%
}%
ifelse %
%(normalized normal: ) == theNormalizedNormal ==
%(y unit v) == theYUnitV ==
%(x unit v: ) == theXUnitV ==
theVprojected theXUnitV \fcVectorScalarVector theVprojected theYUnitV \fcVectorScalarVector
end %
}

\newcommand{\fcCoordsIIIdToPS}{%
[ exch \fcCoordsIIIdToPStricks ] \fcCoordsPStricksToPS
}

\newcommand{\fcBoxIIId}[5][]{%
\pstVerb{%
4 dict begin%
/visibleCorner #2 def%
/vectorOne #3 #2 \fcVectorMinusVector def%
/vectorTwo #4 #2 \fcVectorMinusVector def%
/vectorThree #5 #2 \fcVectorMinusVector def%
}%
\fcPolyLineIIId[#1]{visibleCorner dup vectorOne \fcVectorPlusVector dup vectorTwo \fcVectorPlusVector dup vectorOne \fcVectorMinusVector dup vectorTwo \fcVectorMinusVector visibleCorner}%
\fcPolyLineIIId[#1]{visibleCorner dup vectorOne \fcVectorPlusVector dup vectorThree \fcVectorPlusVector dup vectorOne \fcVectorMinusVector dup vectorThree \fcVectorMinusVector}%
\fcPolyLineIIId[#1]{visibleCorner vectorTwo \fcVectorPlusVector dup vectorThree \fcVectorPlusVector dup vectorTwo \fcVectorMinusVector}%
\fcPolyLineIIId[#1, linestyle=dashed]{visibleCorner vectorOne  vectorTwo vectorThree \fcVectorPlusVector \fcVectorPlusVector \fcVectorPlusVector dup vectorOne \fcVectorMinusVector}%
\fcPolyLineIIId[#1, linestyle=dashed]{visibleCorner vectorOne  vectorTwo vectorThree \fcVectorPlusVector \fcVectorPlusVector \fcVectorPlusVector dup vectorTwo \fcVectorMinusVector}%
\fcPolyLineIIId[#1, linestyle=dashed]{visibleCorner vectorOne  vectorTwo vectorThree \fcVectorPlusVector \fcVectorPlusVector \fcVectorPlusVector dup vectorThree \fcVectorMinusVector}%
\pstVerb{end}%
}

\newcommand{\fcBoxIIIdFilled}[5][]{%
\pscustom*[#1]{%
\fcPolyLineIIId{4 dict begin%
/visibleCorner #2 def%
/vectorOne #3 #2 \fcVectorMinusVector def%
/vectorTwo #4 #2 \fcVectorMinusVector def%
/vectorThree #5 #2 \fcVectorMinusVector def %
visibleCorner vectorOne \fcVectorPlusVector dup vectorTwo \fcVectorPlusVector dup vectorOne \fcVectorMinusVector dup vectorThree \fcVectorPlusVector dup vectorTwo \fcVectorMinusVector dup vectorOne \fcVectorPlusVector visibleCorner vectorOne \fcVectorPlusVector end %
}%
}%
}

\newcommand{\fcParallelogramIIId}[4][linecolor=cyan!30]{%
\pscustom*[#1]{%
\fcParallelogramHollowIIId{#2}{#3}{#4}%
}%
}

\newcommand{\fcParallelogramHollowIIId}[4][]{ %
\fcPolyLineIIId[#1]{3 dict begin /corner #2 def /vectorOne #3 #2 \fcVectorMinusVector def /vectorTwo #4 #2 \fcVectorMinusVector def corner dup vectorOne \fcVectorPlusVector dup vectorTwo \fcVectorPlusVector dup vectorOne \fcVectorMinusVector corner end
}%
}

\newcommand{\fcParallelogramHalfVisibleIIId}[4][]{%
\pstVerb{3 dict begin /corner #2 def /vectorOne #3 #2 \fcVectorMinusVector def /vectorTwo #4 #2 \fcVectorMinusVector def}%
\fcPolyLineIIId[#1]{corner vectorOne \fcVectorPlusVector corner dup vectorTwo \fcVectorPlusVector}%
\fcPolyLineIIId[#1,linestyle=dashed]{corner vectorOne \fcVectorPlusVector dup vectorTwo \fcVectorPlusVector dup vectorOne \fcVectorMinusVector}%
\pstVerb{end}%
}

\newcommand{\fcPolyLineIIId}[2][linecolor=black]{%
\listplot[#1]{ [#2] {\fcCoordsIIIdToPStricks} \fcSpliceArrayOperation \fcArrayToStack}%
}

\makeatletter %makes the @ symbol usable temporarily

\newcommand{\fcConvertPSXYUnit}{\fcShiftX\space sub \stripPoints{\psxunit} 72.27 div 8000 mul mul\space %
\pst@number\pst@dima\space %3 sub 
72.27 div 8000 mul sub  %
}%I have no clue why this works. Since the pstricks.tex code is a cesspool of filth, it is not possible for me to decode what it does, so this is the best I could do.
\newcommand{\fcConvertPSYUnit}{\fcShiftY\space sub \stripPoints{\psyunit} 72.27 div -8000 mul mul\space %
\pst@number\pst@dimb\space 72.27 div -8000 mul sub %
}%I have no clue why this works. Since the pstricks.tex code is a cesspool of filth, it is not possible for me to decode what it does, so this is the best I could do.
\makeatother

%\newcommand{\fcCoordsPStricksToPS}{\fcArrayToStack \fcConvertPSYUnit exch \fcConvertPSXUnit exch\space }
\makeatletter
\newcommand{\fcCoordsPStricksToPS}{\fcArrayToStack \tx@ScreenCoor\space }
\makeatother

\newcommand{\fcLine}[3][]{%
\pscustom{%
\code{%
1 setlinewidth newpath %
#2\space \fcCoordsPStricksToPS moveto %
#3\space \fcCoordsPStricksToPS lineto %
stroke %
}%
}%
}

\newcommand{\fcLineFormatCode}{\fcDashesCode \fcLineWidth\space setlinewidth }

\newcommand{\fcCurveCode}{%
%(calling fcCurveCode) == %
5 dict begin %
%newpath 0 0 moveto 1000 1000 lineto stroke
/theCurve exch def %
%theCurve == %
/tMin exch def%
/tMax exch def%
/Delta tMax tMin sub \fcPlotPoints \space 1 sub div def %
/t tMin def %
\fcLineFormatCode %
newpath %
theCurve \fcCoordsPStricksToPS moveto %
\fcPlotPoints\space 1 sub {/t t Delta add def theCurve \fcCoordsPStricksToPS lineto %
} repeat %
stroke %
end\space%
}

\newcommand{\fcCurve}[4][]{%
\setkeys{fcGraphics}{#1}%
\pstVerb{#2\space #3\space {#4} \space \fcCurveCode}%
}

\newcommand{\fcLineIIId}[3][linecolor=black]{%
\psline[#1](! #2 \space \fcCoordsIIIdToPStricks)(! #3 \space \fcCoordsIIIdToPStricks)%
}
\newcommand{\fcAxesIIIdFull}[4][linecolor=black, arrows=->]{%
\fcAxesIIId[#1]{#2}{#3}{#4}%
\fcLineIIId[#1]{[0 0 0]}{[#2\space -1 mul 0 0]}%
\fcLineIIId[#1]{[0 0 0]}{[0 #3\space -1 mul 0]}%
\fcLineIIId[#1]{[0 0 0]}{[0 0 #4\space -1 mul]}%
} %

\newcommand{\fcAxesIIId}[4][linecolor=black, arrows=->]{%
\setkeys{fcGraphics}{#1}%
\fcLineIIId[#1]{[0 0 0]}{[#2 0 0]}%
\rput(! [#2 0 0] \fcCoordsIIIdToPStricks){\fcXLabel}%
\fcLineIIId[#1]{[0 0 0]}{[0 #3 0]}%
\rput(! [0 #3 0] \fcCoordsIIIdToPStricks){\fcYLabel}%
\fcLineIIId[#1]{[0 0 0]}{[0 0 #4]}%
\rput(! [0 0 #4] \fcCoordsIIIdToPStricks){\fcZLabel}%
}

\newcommand{\fcDotIIId}[2][linecolor=\fcColorGraph]{%
\pscircle*[#1](! #2 \fcCoordsIIIdToPStricks){0.07} %
} %

\newcommand{\fcPutIIId}[3][]{ \rput[#1](! #2 \fcCoordsIIIdToPStricks) {#3}%
} %

\newcommand{\fcPaintCone}{ %
\fcArrayToStack %
15 dict begin %
/c exch def %
/b exch def %
/a exch def %
/z1 exch def %
/y1 exch def %
/x1 exch def %
/zmax exch def %
/zmin exch def %
}

\newcommand{\fcZBufferRowColumn}{ %
%input: vector on the top of the stack.
%output: row column of point in the z-buffer.
\fcCoordsIIIdToPStricks %
2 dict begin %
/rowIndex exch \space getZBufferYmin sub getZBufferYmax getZBufferYmin sub div \fcZBufferNumYIntervals\space mul floor cvi def %
/columnIndex exch getZBufferXmin sub getZBufferXmax getZBufferXmin sub div\space \fcZBufferNumXIntervals\space mul floor cvi def %
rowIndex \fcZBufferNumYIntervals\space ge {/rowIndex rowIndex 1 sub def}if %
columnIndex \fcZBufferNumXIntervals\space ge {/columnIndex columnIndex 1 sub def}if %
rowIndex \fcZBufferNumYIntervals\space ge {(ERROR: bad row index!!!) == rowIndex ==}if %
columnIndex \fcZBufferNumXIntervals\space ge {(ERROR: bad column index: ) == columnIndex == }if %
rowIndex 0 lt {/rowIndex rowIndex 1 add def}if %
columnIndex 0 lt {/columnIndex columnIndex 1 add def}if %
rowIndex 0 lt {(ERROR: bad row index!!!) == rowIndex ==}if %
columnIndex 0 lt {(ERROR: bad column index: ) == columnIndex ==  }if %
rowIndex columnIndex %
end %
}

\newcommand{\fcPointIsBehindPatch}{ %
%a patch is assumed to be on the top of the stack
7 dict begin %
\fcArrayToStack %
pop %
/v2 exch def %
/v1 exch def %
/v0 exch def %
/normal1 v1 v0 \fcVectorMinusVector \fcScreen\space pop \fcVectorCrossVector def %
/normal2 v2 v0 \fcVectorMinusVector \fcScreen\space pop \fcVectorCrossVector def %
/patchNormal v1 v0 \fcVectorMinusVector v2 v0 \fcVectorMinusVector \fcVectorCrossVector def %
thePoint v0 \fcVectorMinusVector normal1 \fcVectorScalarVector %
v2 thePoint \fcVectorMinusVector normal1 \fcVectorScalarVector %
mul 0 ge { %
thePoint v0 \fcVectorMinusVector normal2 \fcVectorScalarVector %
v1 thePoint \fcVectorMinusVector normal2 \fcVectorScalarVector %
mul 0 ge %
{false}{ %
thePoint v0 \fcVectorMinusVector patchNormal \fcVectorScalarVector %
\fcScreen\space pop patchNormal \fcVectorScalarVector %
mul 0 le %
{false}{true}ifelse %
}ifelse %
}{false}ifelse %
end %
}

\newcommand{\fcIsInForeground}{ %
15 dict begin %
/theNeighborhood exch def %
/thePoint theNeighborhood 0 get def %
%(neighborhood: ) print
%theNeighborhood ==
%(thePoint:) print
%thePoint ==
thePoint \fcZBufferRowColumn %
/column exch def %
/row exch def %
/theZBuffEntry theZBuffer row get column get def %
theZBuffEntry length 0 eq {( <br>ERROR: z-buffer not computed properly, row, column: ) print row == column ==} if %
/result true def %
%/counterZBuff -1 def %
%/numCoincidingPatches 0 def %
%(got to main cycle) ==
%theZBuffEntry length { %
%/counterZBuff counterZBuff 1 add def %
%/theZbuffPatch theZBuffEntry counterZBuff get def %
%theZbuffPatch theNeighborhood \fcContains { /numCoincidingPatches numCoincidingPatches 1 add def }if %
%}repeat %
%(Num coinciding patches: )== numCoincidingPatches ==
%(theNeighborhood:) == theNeighborhood ==
%(thePoint:) == thePoint ==
/counterZBuff -1 def %
theZBuffEntry length { %
/counterZBuff counterZBuff 1 add def %
/theZbuffPatch theZBuffEntry counterZBuff get def %
theZbuffPatch theNeighborhood \fcContains not{ %
%(patch) == theZbuffPatch == (is not contained in neighborhood ) ==
%theNeighborhood ==
theZbuffPatch \fcPointIsBehindPatch 
{/result false def  
exit
}
{ %(point is in front of patch) ==
}
ifelse
}
{ %(patch coincides with zbuff patch) == 
}
ifelse %
}repeat %
result %
end %
}

\newcommand{\fcZBufferAccountPoint}{ %
5 dict begin %
/thePoint exch def %
thePoint \fcZBufferRowColumn %
/currentColumn exch def %
/currentRow exch def %
/Zdepth theZBuffer currentRow get currentColumn get def %
/currentZdepth thePoint \fcScreen\space pop \fcVectorScalarVector def %
Zdepth (infty) eq {theZBuffer currentRow get currentColumn currentZdepth put }{ currentZdepth Zdepth lt {theZBuffer currentRow get currentColumn currentZdepth put} if %
}ifelse %
end %
}

\newcommand{\fcZBufferBoundingBoxPatch}{ %
\fcArrayToStack pop % 
3 dict begin %
/v2 exch def %
/v1 exch def %
/v0 exch def %
v0 \fcZBufferBoundingBoxPoint %
v1 \fcZBufferBoundingBoxPoint %
v2 \fcZBufferBoundingBoxPoint %
v1 v2 \fcVectorPlusVector v0 \fcVectorMinusVector \fcZBufferBoundingBoxPoint %
end %
}

\newcommand{\fcZBufferBoundingBoxPoint}{ %
%Account bounding box:
\fcCoordsIIIdToPStricks % 
dup dup getZBufferYmin lt {setZBufferYmin}{pop}ifelse %
dup getZBufferYmax gt {setZBufferYmax}{pop}ifelse %
dup dup getZBufferXmin lt {setZBufferXmin}{pop}ifelse %
dup getZBufferXmax gt {setZBufferXmax}{pop}ifelse \space%
}

\newcommand{\fcZBufferSurface}{ %
(computing z buffer surface) == %
pstack
/theSurface exch def %
/vmax exch def %
/umax exch def %
/vmin exch def %
/umin exch def %
0 0 0 0
}

\newcommand{\fcZBufferEllipsoid}{ %
%(calling fcZBufferEllipsoid with input: ) == dup == %
\fcArrayToStack
6 dict begin
/c exch def %
/b exch def %
/a exch def %
/z1 exch def %
/y1 exch def %
/x1 exch def %
[a -1 mul x1 add b -1 mul y1 add c -1 mul z1 add a x1 add b y1 add c z1 add] %
end
}

\newcommand{\fcSegmentBoundingBox}{ %
\fcZBufferBoundingBoxPoint %
\fcZBufferBoundingBoxPoint %
}

\newcommand{\fcZBufferPaintCellContainingPoint}{
10 dict begin
/thePoint exch def
thePoint \fcZBufferRowColumn
/column exch def
/row exch def
\fcZBufferComputeDeltaXDeltaY
/lowerLeftX getZBufferXmin DeltaX column mul add def
/lowerLeftY getZBufferYmin DeltaY row mul add def
gsave 
0.6 0.6 1 setrgbcolor
newpath 
[lowerLeftX lowerLeftY] \fcCoordsPStricksToPS moveto
[lowerLeftX DeltaX add lowerLeftY] \fcCoordsPStricksToPS lineto
[lowerLeftX DeltaX add lowerLeftY DeltaY add] \fcCoordsPStricksToPS lineto
[lowerLeftX lowerLeftY DeltaY add] \fcCoordsPStricksToPS lineto
[lowerLeftX lowerLeftY] \fcCoordsPStricksToPS lineto
stroke
grestore
end
}

\newcommand{\fcZBufferComputeDeltaXDeltaY}{
/DeltaX getZBufferXmax getZBufferXmin sub \fcZBufferNumXIntervals\space div def %
/DeltaY getZBufferYmax getZBufferYmin sub \fcZBufferNumYIntervals\space div def %
}

\newcommand{\fcPaintZbuffForDebug}{ %
6 dict begin %
\fcZBufferComputeDeltaXDeltaY
gsave %
0.1 setlinewidth %
/x getZBufferXmin def %
0.5 0.5 0.5 setrgbcolor %
\fcZBufferNumYIntervals {newpath [x getZBufferYmin] \fcCoordsPStricksToPS moveto [x getZBufferYmax] \fcCoordsPStricksToPS lineto stroke /x x DeltaX add def}repeat %
/y getZBufferYmin def %
\fcZBufferNumXIntervals { newpath [getZBufferXmin y] \fcCoordsPStricksToPS moveto [getZBufferXmax y] \fcCoordsPStricksToPS lineto stroke /y y DeltaY add def}repeat %
/y getZBufferYmin DeltaY 2 div add def %
/counterY 0 def %
\fcZBufferNumYIntervals { %
/x getZBufferXmin DeltaX 2 div add def %
/counterX 0 def %
\fcZBufferNumXIntervals { %
theZBuffer counterY get counterX get length 0 gt{ %
[x y] \fcFullDotCode %
} if %
/x x DeltaX add def %
/counterX counterX 1 add def %
}repeat %
/y y DeltaY add def %
/counterY counterY 1 add def %
}repeat %
grestore %
end %
}

\newcommand{\fcStartIIIdScene}{%
\pstVerb{%
1 dict begin %
/theIIIdObjects [] def %
}%
}

\newcommand{\fcZBufferPrint}{ %
(printing Zbuffer...) == %
getZBufferXmin == %
getZBufferXmax == %
getZBufferYmin == %
getZBufferYmax == %
theZBuffer == %
}

\newcommand{\fcZBufferLoad}{ %
\fcZBufferInitialize %
/theZBuffer exch def %
setZBufferYmax %
setZBufferYmin %
setZBufferXmax %
setZBufferXmin %
}

\newcommand{\fcZBufferInitialize}{ %
/ZBufferRectangle [0 0 0 0] def %
/setZBufferXmin {ZBufferRectangle exch 0 exch put} def %
/setZBufferYmin {ZBufferRectangle exch 1 exch put} def %
/setZBufferXmax {ZBufferRectangle exch 2 exch put} def %
/setZBufferYmax {ZBufferRectangle exch 3 exch put} def %
/getZBufferXmin {ZBufferRectangle 0 get} def %
/getZBufferYmin {ZBufferRectangle 1 get} def %
/getZBufferXmax {ZBufferRectangle 2 get} def %
/getZBufferYmax {ZBufferRectangle 3 get} def %
/getZBufferDeltaX {getZBufferXmax getZBufferXmin sub \fcZBufferNumXIntervals\space div} def %
/getZBufferDeltaY {getZBufferYmax getZBufferYmin sub \fcZBufferNumYIntervals\space div} def %
}

\newcommand{\fcFinishIIIdScene}{%
\pscustom{%
\code{%
%print the objects we are about to paint:
theIIIdObjects length 0 gt { %
(about to process IIId scene given by: ) print %
theIIIdObjects == %
} if %
25 dict begin %
\fcZBufferInitialize %
/theZBuffer [\fcZBufferNumYIntervals {[\fcZBufferNumXIntervals{[]} repeat]}repeat] def %
/doTraverseContour true def %
/processPatch {\fcZBufferBoundingBoxPatch} def %
/processContour {\fcZBufferBoundingBoxPatchContour} def %
(computing bounding box IIId scene... ) print %
theIIIdObjects \fcArrayToStack theIIIdObjects length {\fcProcessObject } repeat %
%extend slightly the bounding box to take care of floating point errors at the 
%border 
getZBufferXmin 0.1 sub setZBufferXmin %
getZBufferXmax 0.1 add setZBufferXmax %
getZBufferYmin 0.1 sub setZBufferYmin %
getZBufferYmax 0.1 add setZBufferYmax %
(bounding box computed: ) == ZBufferRectangle == %
/processPatch {\fcZBufferPatch} def %
/doTraverseContour false def %
(computing z-buffer IIId scene... ) print %
theIIIdObjects \fcArrayToStack theIIIdObjects length {\fcProcessObject (z buffer partially done) == } repeat %
(z buffer computed) == %
%\fcZBufferPrint %
\fcPaintZbuffForDebug %
(buffer is painted) == %
/doTraverseContour true def %
/processPatch {pop} def %
/processContour {\fcPatchContour} def %
(painting IIId scene... ) print %
theIIIdObjects \fcArrayToStack theIIIdObjects length {\fcProcessObject } repeat %
end %
(done, printing stack to make sure no trash is left) == %
pstack %
}%
}%
\pstVerb{end} %
}%

\newcommand{\fcProcessObject}{%
(processing object) == \fcArrayToStack dup == %
1 dict begin %
4 1 roll setrgbcolor %
/HandlerNotFound true def %
HandlerNotFound{dup (surface) eq {pop \fcProcessSurface /HandlerNotFound false def} if} if %
HandlerNotFound{== (ERROR: OBJECT PAINTING HANDLER NOT FOUND)} if %
end %
}%

\newcommand{\fcZBufferBoundingBoxPatchContour}{ %
2 dict begin %
/theContour exch def %
/counter -1 def %
theContour length { /counter counter 1 add def theContour counter get 0 get \fcZBufferBoundingBoxPoint}repeat %
end %
}

\newcommand{\fcPaintPointForegroundData}{
20 dict begin %
gsave
/theNeighborhood exch def %
/thePoint theNeighborhood 0 get def %
thePoint \fcZBufferPaintCellContainingPoint %
[thePoint \fcCoordsIIIdToPStricks] theNeighborhood \fcIsInForeground
{\fcFullDotCode}{\fcHollowDotCode}ifelse %
/counter 0 def
(theNeighborhood:)==
theNeighborhood ==
theNeighborhood \fcIsInForeground not{
theNeighborhood length 1 sub {
/counter counter 1 add def
3 setlinewidth
0.5 1 0.5 setrgbcolor 
theNeighborhood counter get \fcPaintPatchDirectly
}repeat
thePoint \fcZBufferRowColumn
/column exch def
/row exch def 
/theZBufferCurrent theZBuffer row get column get def
/counter -1 def
theZBufferCurrent length {
/counter counter 1 add def %
1 setlinewidth
1 0.5 0.5 setrgbcolor 
theZBufferCurrent counter get \fcPaintPatchDirectly
}repeat
}if
grestore
end
}

\newcommand{\fcPatchContour}{ %
15 dict begin %
/theContour exch def %
/numSegments theContour length 1 sub def %
/counter -1 def %
/rightIsInForeground theContour 0 get \fcIsInForeground def %
/style (none) def %
newpath %
numSegments{ %
  /counter counter 1 add def %
  /pointLeft theContour counter get def %
  /pointRight theContour counter 1 add get def %
  /leftIsInForeground rightIsInForeground def %
  /rightIsInForeground pointRight \fcIsInForeground def %
  /oldStyle style def %
  /style leftIsInForeground rightIsInForeground or {(normal)}{(dashed)}ifelse def %
  style oldStyle ne{ %
  stroke style (normal) eq{[] 0 setdash}{[1 1]0 setdash}ifelse %
  newpath pointLeft 0 get \fcCoordsIIIdToPS moveto %
  }if %
  pointRight 0 get \fcCoordsIIIdToPS lineto %  
}repeat %
stroke %
/counter -1 def
theContour length {/counter counter 1 add def
/currentNeighborhood theContour counter get def
/currentPoint currentNeighborhood 0 get def
currentPoint \fcZBufferRowColumn
/column exch def
/row exch def 
\fcZBufferRowColumnsUnderInvestigation\space column eq exch row eq and
{ currentNeighborhood \fcPaintPointForegroundData
}if
}repeat
end %
}

\newcommand{\fcComputeSurfacePatch}{
/oldU u def %
/oldV v def %
[ %start of patch data structure
theSurface %(x(u,v), y(u,v), z(u,v))
/u u DeltaU add def %
theSurface %(x(u+Delta,v), y(u+Delta,v), z(u+Delta,v))
/u oldU def %
/v v DeltaV add def %
theSurface %(x(u,v+Delta), y(u,v+Delta), z(u,v+Delta))
(patch) %
] %patch data structure complete
/v oldV def %
}

\newcommand{\fcProcessSurfaceContour}{ %
/DeltaDeltaV DeltaV \fcNumCountourSegmentsPatchV\space div def %
/DeltaDeltaU DeltaU \fcNumCountourSegmentsPatchU\space div def %
/u uMin def %
/counterU 0 def %
uIterations 1 add{ %
/counterU counterU 1 add def %
/v vMin def %
/patchLeft (empty) def %
/patchRight (empty) def %
[
vIterations { %
/patchLeftBack patchLeft def %
/patchRightBack patchRight def %
/patchLeft counterU uIterations lt {\fcComputeSurfacePatch}{(empty)}ifelse def %
/patchRight u uMin ne {/uTemp u def /u uOld def  \fcComputeSurfacePatch /u uTemp def}{(empty)}ifelse def %
/vOld v def %
[theSurface patchLeft patchRight patchLeftBack patchRightBack]
\fcNumCountourSegmentsPatchU\space 1 sub{/v v DeltaDeltaV add def [theSurface patchLeft patchRight]} repeat
/v vOld DeltaV add def %
}repeat %
[theSurface patchLeft patchRight]
]
/thePatchContour exch def %
thePatchContour processContour
/uOld u def %
/u u DeltaU add def %
} repeat %
/v vMin def %
/counterV 0 def %
vIterations 1 add{ %
/counterV counterV 1 add def %
/u uMin def %
/patchLeft (empty) def %
/patchRight (empty) def %
[
uIterations { %
/patchLeftBack patchLeft def %
/patchRightBack patchRight def %
/patchLeft counterV vIterations lt  {\fcComputeSurfacePatch}{(empty)}ifelse def %
/patchRight v vMin ne {/vTemp v def /v vOld def  \fcComputeSurfacePatch /v vTemp def}{(empty)}ifelse def %
/uOld u def %
[theSurface patchLeft patchRight patchLeftBack patchRightBack]
\fcNumCountourSegmentsPatchV\space 1 sub{/u u DeltaDeltaU add def [theSurface patchLeft patchRight]} repeat
/u uOld DeltaU add def %
}repeat %
[theSurface patchLeft patchRight]
]
/thePatchContour exch def %
thePatchContour processContour
/vOld v def %
/v v DeltaV add def %
} repeat %
}

\newcommand{\fcProcessSurface}{%
30 dict begin %
(processing Surface: ) ==
pstack
/theSurface exch def %
/vMax exch def %
/uMax exch def %
/vMin exch def %
/uMin exch def %
/uIterations \fcIterationsU\space def %
/vIterations \fcIterationsV\space def %
/DeltaU uMax uMin sub uIterations div def %
/DeltaV vMax vMin sub vIterations div def %
%/theFile (/home/todor/math/freecalc/lectures/surfaceData.txt) (w) file def
%theFile (hello file) writestring pop
doTraverseContour{ %
\fcProcessSurfaceContour
} if %
%theFile closefile
/u uMin def %
uIterations { %
/v vMin def %
vIterations{ %
\fcComputeSurfacePatch
processPatch %
/v v DeltaV add def %
}repeat %
/u u DeltaU add def %
}repeat %
end %
}%

\newcommand{\fcPaintEllipsoid}{%
(painting ellipsoid: ) == %
dup == %
\fcArrayToStack %
15 dict begin %
/c exch def %
/b exch def %
/a exch def %
/z1 exch def %
/y1 exch def %
/x1 exch def %
/theSurfaceNormal {[v cos u cos a mul mul v sin u cos b mul mul u sin -1 mul c mul] [v sin -1 mul u sin a mul mul v cos u sin b mul mul 0] \fcVectorCrossVector} def %
0 0 180 360 {[v cos u sin a mul mul x1 add v sin u sin b mul mul y1 add u cos c mul z1 add]} \fcSurfaceIIIdCode %
end %
}

\newcommand{\fcGetCurrentColorCode}{
2 dict begin
/theColor {0 0 0} def %
/colorNotFound true def %
(\fcLineColor) (black) eq{/theColor {0 0 0} def /colorNotFound false def}if %
(\fcLineColor) (red) eq{/theColor {1 0 0} def /colorNotFound false def}if %
(\fcLineColor) (blue) eq{/theColor {0 0 1} def /colorNotFound false def}if %
(\fcLineColor) (green) eq{/theColor {0 1 0} def /colorNotFound false def}if %
colorNotFound{/theColor {\fcLineColor} def}if %
theColor %
end %
}

%Let the ellipsoid be given by the set of points  (x,y,z), for which (x-x1)^2/a^2+ (y-y1)/b^2 +(z-z1)^2/c^2=1, where x1, y1, z1, a, b, c are the parameters of the ellipsoid. We store the ellipsoid as the data a, b, c in the data structure [ [x1 y1 z1 a b c] red green blue (ellipsoid)]
\newcommand{\fcEllipsoid}[2][linecolor=red]{%
\setkeys{fcGraphics}{#1}%
\pstVerb{%
9 dict begin %
%default 
mark #2\space %
/c exch def %
/b exch def %
/a exch def %
/x1 0 def %
/y1 0 def %
/z1 0 def %
counttomark 0 gt{ %
/z1 exch def %
/y1 exch def %
/x1 exch def %
}if %
pop %remove the mark
[theIIIdObjects \fcArrayToStack [[x1 y1 z1 a b c] \fcGetCurrentColorCode (ellipsoid)] ] %
end %
/theIIIdObjects exch def %
}%
}

%Let the cone be given by the set of points  (x,y,z), for which (x-x1)^2/a^2+ (y-y1)/b^2 =(z-z1)^2/c^2, where x1, y1, z1, a, b, c are the parameters of the cone. We plot the cone from zmin to zmax We store the ellipsoid as the data a, b, c in the data structure [ [zmin zmax x1 y1 z1 a b c] red green blue (ellipsoid)]
\newcommand{\fcCone}[2][linecolor=red]{%
\setkeys{fcGraphics}{#1}%
\pstVerb{%
11 dict begin %
%default 
mark #2\space %
/c exch def %
/b exch def %
/a exch def %
/x1 0 def %
/y1 0 def %
/z1 0 def %
counttomark 2 gt{ %
/x1 exch def %
/y1 exch def %
/z1 exch def %
}if %
counttomark 1 gt{ %
/zmax exch def %
/zmin exch def %
}if %
pop %remove the mark
[theIIIdObjects \fcArrayToStack [[zmin zmax x1 y1 z1 a b c] \fcGetCurrentColorCode (cone)] ] %
end %
/theIIIdObjects exch def %
}%
}

%Format of surface: we store the surface in the format [umin vmin umax vmax [fx fy fz] red green blue (surface)]
\newcommand{\fcSurfaceInScene}[6][]{%
\setkeys{fcGraphics}{#1}%
\pstVerb{[theIIIdObjects \fcArrayToStack [#2\space #3\space #4\space #5\space {#6} \fcGetCurrentColorCode (surface)] ]/theIIIdObjects exch def}
}%

\newcommand{\fcCurveIIIdNoSceneCode}{%
15 dict begin%
/theCurve exch def%
/tMax exch def%
/tMin exch def%
/numPoints \fcPlotPoints\space def%
/Delta tMax tMin sub numPoints 1 sub div def%
/t tMin def %
\fcLineFormatCode %
newpath %
theCurve \fcCoordsIIIdToPS moveto %
numPoints 1 sub {/t t Delta add def theCurve \fcCoordsIIIdToPS lineto } repeat %
stroke %
end %
}%

\newcommand{\fcZBufferBoundingBoxPolyline}{ %
{\fcZBufferBoundingBoxPoint} forall
}

\newcommand{\fcZBufferPolyline}{ %
{\fcZBufferAccountPoint} \fcSpliceArrayOperation pop
}

\newcommand{\fcContains}{ %
3 dict begin %
/theArray exch def %
/theElement exch def %
false %
/counter 0 def %
theArray length { %
theElement theArray counter get \fcAreEqual {pop true exit}if %
/counter counter 1 add def %
}repeat %
%(array: ) == theArray == 
%dup { (does contain) ==}{ (does NOT contain) ==}ifelse %
%theElement == %
end %
}

\newcommand{\fcAreEqual}{ %
1 dict begin
/areEqual
{5 dict begin 
/left exch def
/right exch def
left type  right type ne{false}
{ left type (arraytype) ne{ left right eq}
{ left length right length ne{false}
{ /counter 0 def %
true %
left length { left  counter get right counter get areEqual not{pop false exit }if /counter counter 1 add def }repeat
}ifelse
}ifelse
}ifelse
end
} def %
areEqual
end
}

\newcommand{\fcZBufferAccountPatchXY}{ %
%(patch row col: ) print x == y ==
5 dict begin %
/currentArray theZBuffer row get column get def %
/counter 0 def %
true %
currentArray length {currentArray counter get thePatch \fcAreEqual {pop false exit}if /counter counter 1 add def} repeat
{ theZBuffer row get column [currentArray \fcArrayToStack thePatch ] put}if
end %
}

\newcommand{\fcPaintPatchDirectly}{
2 dict begin
/thePatch exch def %
(thePatch: ) ==
thePatch ==
(PATCH TYPE: ) == thePatch type ==
thePatch type (arraytype) eq{
newpath
thePatch 0 get \fcCoordsIIIdToPS moveto 
thePatch 1 get \fcCoordsIIIdToPS lineto 
thePatch 1 get thePatch 2 get \fcVectorPlusVector thePatch 0 get \fcVectorMinusVector \fcCoordsIIIdToPS lineto 
thePatch 2 get \fcCoordsIIIdToPS lineto 
thePatch 0 get \fcCoordsIIIdToPS lineto
stroke
}if
end
}

\newcommand{\fcZBufferPatch}{ %
15 dict begin %
/thePatch exch def %
%thePatch \fcPaintPatchDirectly
/secondPoint thePatch 2 get def %
/firstPoint  thePatch 1 get def %
/basePoint   thePatch 0 get def %
/firstDirection firstPoint basePoint \fcVectorMinusVector def %
/secondDirection secondPoint basePoint \fcVectorMinusVector def %
/iterationsFirst [firstDirection \fcCoordsIIIdToPStricks\space pop getZBufferDeltaX div firstDirection \fcCoordsIIIdToPStricks\space exch pop getZBufferDeltaY div] \fcVectorNorm 2 mul 1 add round cvi def %
/iterationsSecond [secondDirection \fcCoordsIIIdToPStricks pop  getZBufferDeltaX div secondDirection \fcCoordsIIIdToPStricks exch pop getZBufferDeltaY div] \fcVectorNorm 2 mul 1 add round cvi def
/s 0 def %
iterationsFirst{ %
/firstComponent firstDirection s iterationsFirst 1 sub div  \space\fcVectorTimesScalar basePoint \fcVectorPlusVector def%
/t 0 def %
iterationsSecond{ %
secondDirection t iterationsSecond 1 sub div \fcVectorTimesScalar %
firstComponent \fcVectorPlusVector \fcZBufferRowColumn %
/column exch def %
/row exch def %
\fcZBufferAccountPatchXY %
/t t 1 add def %
}repeat
/s s 1 add def %
}repeat
end %
}

\newcommand{\fcCurveIIId}[4][linecolor=\fcColorGraph]{%
\parametricplot[#1]{#2}{#3}{#4 \fcCoordsIIIdToPStricks}%
}

\newcommand{\fcZeroVector}{[exch {0} repeat]}

\newcommand{\fcPerpendicularComputeHeel}[3]{%
\pstVerb{%
7 dict begin%
/thePoint #1 def%
/heelSize #3 def %
mark #2 %
counttomark 1 eq {%
/directionUnitVector exch \fcVectorNormalize def%
/basePoint thePoint length \fcZeroVector def%
}{%
/basePoint exch def%
/directionUnitVector exch basePoint \fcVectorMinusVector \fcVectorNormalize def%
} ifelse %
pop%
/heel directionUnitVector thePoint basePoint \fcVectorMinusVector directionUnitVector \fcVectorScalarVector \fcVectorTimesScalar basePoint \fcVectorPlusVector def%
%heel == %
/perpendicularUnitVector thePoint heel \fcVectorMinusVector \fcVectorNormalize def %
%perpendicularUnitVector == %
/polyLineInput {%
heel directionUnitVector heelSize \fcVectorTimesScalar \fcVectorMinusVector %
%dup ==
dup perpendicularUnitVector heelSize \fcVectorTimesScalar \fcVectorPlusVector %
heel perpendicularUnitVector heelSize \fcVectorTimesScalar \fcVectorPlusVector%
} def%
}%
}

\newcommand{\fcPerpendicular}[4][]{%
\fcPerpendicularComputeHeel{#2}{#3}{#4}%
\psline[#1](! thePoint \fcArrayToStack)(! heel \fcArrayToStack)%
\listplot[linecolor=red]{ [polyLineInput] {\fcArrayToStack} \fcSpliceArrayOperation \fcArrayToStack}%
\pstVerb{end}%
}

\newcommand{\fcPerpendicularIIId}[4][]{%
\fcPerpendicularComputeHeel{#2}{#3}{#4}%
\fcLineIIId[#1]{thePoint}{heel}%
\fcPolyLineIIId[linecolor=red]{polyLineInput}%
\pstVerb{end}%
}%

\newcommand{\fcPlotIIId}[7][]{%
\fcPlotIIIdXconst[#1]{#2}{#3}{#4}{#5}{#6}{#7}%
\fcPlotIIIdYconst[#1]{#2}{#3}{#4}{#5}{#6}{#7}%
}
\newcommand{\fcPlotIIIdXconst}[7][]{%
\setkeys{fcGraphics}{#2}%
\multido{\ra=0+1}{\fcIterationsX}{%
\pstVerb{%
3 dict begin %
/x \ra \space #3 mul \fcIterationsX \space \ra \space sub 1 sub  #5\space mul add \fcIterationsX\space 1 sub div def%
/ymin #4 def%
/ymax #6 def%
}%
\parametricplot[#1]{ymin}{ymax}{%
1 dict begin /y t def  [x y #7] \fcCoordsIIIdToPStricks end%
}%
\pstVerb{end}%
}%end multido
}

\newcommand{\fcPlotIIIdYconst}[7][]{%
\setkeys{fcGraphics}{#2}%
\multido{\ra=0+1}{\fcIterationsY}{%
\pstVerb{%
3 dict begin%
/y \ra \space #4 mul \fcIterationsY \space \ra \space sub 1 sub  #6\space mul add \fcIterationsY\space 1 sub div def%
/xmin #3 def%
/xmax #5 def%
}%
\parametricplot[#1]{xmin}{xmax}{%
1 dict begin /x t def  [x y #7] \fcCoordsIIIdToPStricks end%
}%
\pstVerb{end}%
}%end multido
}

\newcommand{\fcSurfaceIIIdUConst}[7][]{%
\setkeys{fcGraphics}{#2}%
\multido{\ra=0+1}{\fcIterationsX}{%
\pstVerb{%
3 dict begin%
/u \ra \space #3 mul \fcIterationsX \space \ra \space sub 1 sub  #5\space mul add \fcIterationsX\space 1 sub div def%
/vmin #4 def%
/vmax #6 def%
}%
\parametricplot[#1]{vmin}{vmax}{%
1 dict begin /v t def #7 \fcCoordsIIIdToPStricks end%
}%
\pstVerb{end}%
}%end multido
}

\newcommand{\fcSurfaceIIIdVConst}[7][]{%
\setkeys{fcGraphics}{#2}%
\multido{\ra=0+1}{\fcIterationsY}{%
\pstVerb{%
3 dict begin%
/v \ra \space #4 mul \fcIterationsY \space \ra \space sub 1 sub  #6\space mul add \fcIterationsY\space 1 sub div def%
/umin #3 def%
/umax #5 def%
}%
\parametricplot[#1]{umin}{umax}{%
1 dict begin /u t def #7 \fcCoordsIIIdToPStricks end%
}%
\pstVerb{end}%
}%end multido
}

\newcommand{\fcSurfaceDirectDraw}[7][]{%
\fcSurfaceIIIdUConst[#1]{#2}{#3}{#4}{#5}{#6}{#7}%
\fcSurfaceIIIdVConst[#1]{#2}{#3}{#4}{#5}{#6}{#7}%
}%

\newcommand{\fcVectorField}[3][linecolor=blue]{%
\setkeys{fcGraphics}{#2}%
\multido{\ra=\fcStartXIId+\fcDelta}{\fcIterationsX}{%
\multido{\rb=\fcStartYIId+\fcDelta}{\fcIterationsY}{%
\pstVerb{%
4 dict begin%
/x \ra\space def%
/y \rb\space def %
#3\space%
/vY exch def%
/vX exch def%
}%
\psline[#1](! x vX 2 div sub y vY 2 div sub)(! x vX 2 div add y vY 2 div add)%
\pscircle*[linecolor=red](! x y){0.02}%
\pstVerb{end}%
}%end multido
}%end multido
}%

