\usepackage{etex, ifthen}
\usepackage [dvips={-o -Ppdf}, pspdf={-dNOSAFER -dAutoRotatePages=/None}, pdfcrop={}]
{auto-pst-pdf}
\usepackage{pst-plot}
\usepackage{pst-math}
%WARNING THE FOLLOWING PACKAGE IS BROKEN use only with EXTREME CAUTION
%\usepackage{pst-3dplot}

\makeatletter
\begingroup
\catcode `P=12  % digits and punct. catcode
\catcode `T=12  % digits and punct. catcode
\lowercase{%
\def\x{\def\rem@pt##1.##2PT{##1\ifnum##2>\z@.##2\fi}}}
\expandafter\endgroup\x%
\newcommand{\stripPoints}[1]{\expandafter\rem@pt\the#1}
\makeatother

\definecolor{darkgreen}{rgb}{0,0.5,0}
\newcommand{\fcShiftX}{0}
\newcommand{\fcShiftY}{0}
\newcommand{\fcXLabel}{$x$}
\newcommand{\fcYLabel}{$y$}
\newcommand{\fcZLabel}{$z$}
\newcommand{\fcDelta}{0.5}
\newcommand{\fcZBufferNumXIntervals}{20}
\newcommand{\fcZBufferNumYIntervals}{20}
\newcommand{\fcZBufferRowColumnsUnderInvestigation}{(empty) (empty)}
\newcommand{\fcZBufferUparameterPointUnderInvestigation}{(empty) (empty)}
\newcommand{\fcZBufferVparameterPointUnderInvestigation}{(empty) (empty)}
%\newcommand{\fcContourDebugged}{-1}
\newcommand{\fcStartXIId}{0}
\newcommand{\fcStartYIId}{0}
\newcommand{\fcIterationsX}{9\space}
\newcommand{\fcIterationsY}{9\space}
\newcommand{\fcIterationsU}{9\space}
\newcommand{\fcIterationsV}{9\space}
\newcommand{\fcNumCountourSegmentsPatchU}{10\space}
\newcommand{\fcNumCountourSegmentsPatchV}{10\space}
\newcommand{\fcScreenStyle}{z}
\newcommand{\fcColorLine}{black}
\newcommand{\fcColorAngle}{red}
\newcommand{\fcForceForeground}{false}
\newcommand{\fcLineWidth}{1}
\newcommand{\fcAngleLineWidth}{1pt}
\newcommand{\fcScale}{1\space}
\newcommand{\fcArrows}{}
\newcommand{\fcPlotPoints}{200}
\newcommand{\fcLineStyle}{0}
\newcommand{\fcDashLength}{1}
\newcommand{\fcContourOptions}{
[(\fcArrows) (->) eq (\fcArrows) (<-) eq (\fcArrows) (<->) eq or or [\fcGetColorCode{\fcColorLine}] \fcLineWidth [\fcDashes] (\fcLineStyle)]
}
\newcommand{\fcShowGridImplicitIId}{false}
\newcommand{\fcDashes}{[\fcDashLength\space \fcDashLength] 0}
\newcommand{\fcColorPatchUV}{1 0.5 0.5}
\newcommand{\fcColorPatchVU}{0.7 0.2 0.2}
\newcommand{\fcFastPatchSort}{false}
\newcommand{\fcDashesCode}{%
(\fcLineStyle) (dashed) eq (\fcLineStyle) (dashed ) eq or %
{\fcDashes\space setdash}%
{[] 0 setdash}%
ifelse\space %
}
\newcommand{\fcDashesCodeVirtual}{%
(\fcLineStyle) (dashed) eq (\fcLineStyle) (dashed ) eq or %
{\fcDashes\space setdashVirtual}%
{[] 0 setdashVirtual}%
ifelse\space %
}
\newcommand{\fcScreen}{[-1 1 -0.75] -1} %default projection plane. Renew this command to change projection plane.

\newcommand{\fcSet}[1]{\setkeys{fcGraphics}{#1}}

\makeatletter %needed for define@key command.
\define@key{pstricks,pst-plot}{xLabel}[]{}
\define@key{pstricks,pst-plot}{yLabel}[]{}
\define@key{pstricks,pst-plot}{zLabel}[]{}
\define@key{fcGraphics}{Delta}[\renewcommand{\fcDelta}{1}]{\renewcommand{\fcDelta}{#1}}
\define@key{fcGraphics}{shiftX}[\renewcommand{\fcShiftX}{0}]{\renewcommand{\fcShiftX}{#1}}
\define@key{fcGraphics}{shiftY}[\renewcommand{\fcShiftY}{0}]{\renewcommand{\fcShiftY}{#1}}
\define@key{fcGraphics}{startX}[\renewcommand{\fcStartXIId}{0}]{\renewcommand{\fcStartXIId}{#1}}
\define@key{fcGraphics}{startY}[\renewcommand{\fcStartYIId}{0}]{\renewcommand{\fcStartYIId}{#1}}
\define@key{fcGraphics}{colorUV}[\renewcommand{\fcColorPatchUV}{1 0.5 0.5}]{\renewcommand{\fcColorPatchUV}{#1\space}}
\define@key{fcGraphics}{colorVU}[\renewcommand{\fcColorPatchVU}{0.7 0.2 0.2}]{\renewcommand{\fcColorPatchVU}{#1\space}}
\define@key{fcGraphics}{iterationsU}[\renewcommand{\fcIterationsU}{9\space}]{\renewcommand{\fcIterationsU}{#1\space}}
\define@key{fcGraphics}{iterationsV}[\renewcommand{\fcIterationsU}{9\space}]{\renewcommand{\fcIterationsV}{#1\space}}
\define@key{fcGraphics}{forceForeground}[\renewcommand{\fcForceForeground}{false\space}]{\renewcommand{\fcForceForeground}{#1\space}}
\define@key{fcGraphics}{showGridImplicitIId}[\renewcommand{\fcShowGridImplicitIId}{false\space}]{\renewcommand{\fcShowGridImplicitIId}{#1\space}}
\define@key{fcGraphics}{iterationsX}[\renewcommand{\fcIterationsX}{9\space}]{\renewcommand{\fcIterationsX}{#1\space}}
\define@key{fcGraphics}{scale}[\renewcommand{\fcScale}{1}]{\renewcommand{\fcScale}{#1\space}}
%\define@key{fcGraphics}{debugContour}[\renewcommand{\fcContourDebugged}{-1\space}]{\renewcommand{\fcContourDebugged}{#1\space}}
\define@key{fcGraphics}{iterationsY}[\renewcommand{\fcIterationsY}{9\space}]{\renewcommand{\fcIterationsY}{#1\space}}
\define@key{fcGraphics}{screenStyle}[\renewcommand{\fcScreenStyle}{z}]{\renewcommand{\fcScreenStyle}{#1}}
\define@key{fcGraphics}{xLabel}[\renewcommand{\fcXLabel}{$x$}]{\renewcommand{\fcXLabel}{#1}}
\define@key{fcGraphics}{yLabel}[\renewcommand{\fcYLabel}{$y$}]{\renewcommand{\fcYLabel}{#1}}
\define@key{fcGraphics}{zLabel}[\renewcommand{\fcZLabel}{$z$}]{\renewcommand{\fcZLabel}{#1}}
\define@key{fcGraphics}{linecolor}[\renewcommand{\fcColorLine}{black}]{\renewcommand{\fcColorLine}{#1}}
\define@key{fcGraphics}{anglecolor}[\renewcommand{\fcColorAngle}{red}]{\renewcommand{\fcColorAngle}{#1}}
\define@key{fcGraphics}{linewidth}[\renewcommand{\fcLineWidth}{1}]{\renewcommand{\fcLineWidth}{#1}}
\define@key{fcGraphics}{anglelinewidth}[\renewcommand{\fcAngleLineWidth}{1pt}]{\renewcommand{\fcAngleLineWidth}{#1}}
\define@key{fcGraphics}{linestyle}[\renewcommand{\fcLineStyle}{0}]{\renewcommand{\fcLineStyle}{#1\space}}
\define@key{fcGraphics}{fastsort}[\renewcommand{\fcFastPatchSort}{false}]{\renewcommand{\fcFastPatchSort}{#1}}
\define@key{fcGraphics}{dashes}[\renewcommand{\fcDashes}{[\fcDashLength\space \fcDashLength] 0}]{\renewcommand{\fcDashes}{#1}}
\define@key{fcGraphics}{arrows}[\renewcommand{\fcArrows}{}]{\renewcommand{\fcArrows}{#1}}
\makeatother %undoes \makeatletter.


\newcommand{\fcHollowDot}[2]{
\pscircle*[fillcolor=white, linecolor=red](#1, #2){0.07}
\pscircle*[fillcolor=white, linecolor=white](#1, #2){0.04}
}

\newcommand{\fcFullDot}[3][linecolor=red]{
\setkeys{fcGraphics}{#1}
\pscircle*[#1](! #2 #3){! 0.07 \fcScale\space mul}
}

\newcommand{\fcFullDotCode}{
gsave
\fcCoordsPStricksToPS [0.02 0] \fcCoordsPStricksToPS pop 0 360 arc 1 0 0 setrgbcolor fill stroke
grestore
}

\newcommand{\fcHollowDotCode}{
gsave
\fcCoordsPStricksToPS [0.04 0] \fcCoordsPStricksToPS pop 0 360 arc 0 1 0 setrgbcolor stroke
grestore
}

\newcommand{\fcHashString}{
2 dict begin
/theString exch def
/counter -1 def
0
theString length {
/counter counter 1 add def
theString counter get cvi counter 1 add mul add
}repeat
20 string cvs
end
}

\newcommand{\fcToString}{
1 dict begin
/ToString
{
5 dict begin
cvlit
/theData exch def
theData type (arraytype) eq{
([)
theData{ToString ( )} forall
(])
theData length 2 mul 2 add \fcConcatenateMultiple
}
{theData 20 string cvs}
ifelse
end
} def %
ToString
end\space
}

\newcommand{\fcConcatenate}{ %Code taken from stackexchange, many thanks!
exch dup length
2 index length add string
dup dup 4 2 roll copy length
4 -1 roll putinterval
}

\newcommand{\fcConcatenateMultiple}{ %Code taken from stackexchange, many thanks!
%Usage: (s1) (s2) (s3) ... (sN) n  \fcConcatenateMultiple  (s1s2s3...sN)
% s1 s2 s3 .. sN n                   % first sum the lengths
dup 1 add  % s1 s2 s3 .. sN n n+1
copy       % s1 s2 s3 .. sN n  s1 s2 s3 .. sN n
0 exch     % s1 s2 s3 .. sN n  s1 s2 s3 .. sN 0 n
{exch length add} repeat % s1 s2 s3 .. sN  n   len  % then allocate string
string exch          % s1 s2 s3 .. sN str   n
0 exch               % s1 s2 s3 .. sN str  off  n
-1 1 {               % s1 s2 s3 .. sN str  off  n  % copy each string
  2 add -1 roll       % s2 s3 .. sN str  off s1  % bottom to top
  3 copy putinterval  % s2 s3 .. sN str' off s1
  length add          % s2 s3 .. sN str' off+len(s1)
                      % s2 s3 .. sN str' off'
} for                               % str' off'
pop  % str'
}

\newcommand{\fcRiemannSum}[6][linecolor=\fcColorGraph]{%
\pstVerb{%
15 dict begin 
/numIntervals #5\space def
/leftEnd #2\space def
/rightEnd #3\space def
/pointRatio #6\space def
/DeltaX rightEnd leftEnd sub numIntervals div def
/function {#4} def
}%
\multido{\ra=0+1}{#5}{%
\pstVerb{/iteration \ra\space def
/currentLeft iteration DeltaX mul leftEnd add def
/x pointRatio DeltaX mul currentLeft add def
}%
\psline*[linecolor=cyan](! currentLeft 0)(! currentLeft DeltaX add 0)(! currentLeft DeltaX add function)(! currentLeft function) (! currentLeft 0)%
\psline[linecolor=blue](! currentLeft 0)(! currentLeft DeltaX add 0)(! currentLeft DeltaX add function)(! currentLeft function) (! currentLeft 0)%
}%
\psplot[#1]{leftEnd}{rightEnd}{function}%
\pstVerb{end}%
}

\newcommand{\fcRectangularRiemannSumCode}{
/theRiemannSumFigure exch def
theRiemannSumFigure \fcSetupFiles
graphicsCached not{
theRiemannSumFigure \fcArrayToStack
20 dict begin
/theFunction exch def
/yIterations exch def
/xIterations exch def
/yMax exch def
/xMax exch def
/yMin exch def
/xMin exch def
/DeltaX xMax xMin sub xIterations div def
/DeltaY yMax yMin sub yIterations div def
/theSideColor exch def
/theContourColor exch def
/x xMin def
xIterations{
/y yMin def
yIterations{
/xOld x def
/yOld y def
/x x DeltaX 2 div add def
/y y DeltaY 2 div add def
/z theFunction def
[xOld yOld 0]
[xOld DeltaX add yOld 0]
[xOld yOld DeltaY add 0]
[xOld yOld z]
theContourColor
theSideColor
true
false
[\fcDashes]
\fcBoxIIIdFilledCode
/x xOld def
/y yOld DeltaY add def
}repeat
/x x DeltaX add def
}repeat
end
}if
}

\newcommand{\fcRectangularRiemannSum}[8][]{%
\setkeys{fcGraphics}{#1}%
\pscustom{%
\code{%
[[\fcGetColorCode{\fcColorLine}] [\fcGetColorCode{\fcColorPatchUV}]  #2\space #3\space #4\space #5 \space #6\space #7\space {#8}\space]
\fcRectangularRiemannSumCode
}%
}%
}

\newcommand{\fcTextCode}{
/Times-Roman findfont
4 scalefont
setfont
newpath
\fcCoordsPStricksToPS moveto
show
stroke
}

\newcommand{\fcHollowDotBlue}[2]{
\pscircle*[fillcolor=white, linecolor=blue](#1, #2){0.07}
\pscircle*[fillcolor=white, linecolor=white](#1, #2){0.04}
}
\newcommand{\fcFullDotBlack}[2]{
\pscircle*[fillcolor=white, linecolor=black](#1, #2){0.07}
}
\newcommand{\fcFullDotBlue}[2]{
\pscircle*[fillcolor=white, linecolor=blue](#1, #2){0.07}
}
\newcommand{\fcXTickColored}[2]{\psline[linecolor=#1](#2, -0.1)(#2,0.1)}

\newcommand{\fcXTick}[1]{\psline(! #1\space -0.1)(! #1 \space 0.1)}
\newcommand{\fcYTick}[1]{\psline(! -0.1 #1)(! 0.1 #1)}
\newcommand{\fcXYTick}[2]{\fcXTick{#1} \fcYTick{#2}}

\newcommand{\fcXTickWithLabel}[2]{\fcXTick{#1}\rput[t](! #1\space -0.2){#2}}
\newcommand{\fcYTickWithLabel}[2]{\fcYTick{#1}\rput[r](! -0.2 #1){#2}}

\newcommand{\fcLabelNumberXaxis}[1]{\fcXTickWithLabel{#1}{#1}}
\newcommand{\fcLabelNumberYaxis}[1]{\fcYTickWithLabel{#1}{#1}}

\newcommand{\fcLabelNumberXYaxes}[2]{\fcLabelNumberXaxis{#1} \fcLabelNumberYaxis{#2} }

\newcommand{\fcLabelXOne}{\fcLabelNumberXaxis{1} }
\newcommand{\fcLabelYOne}{\fcLabelNumberYaxis{1} }

\newcommand{\fcLabelOnXaxis}[2]{\fcXTick{#1}\rput[t](#1,-0.2){#2}}
\newcommand{\fcLabelOnYaxis}[2]{\fcYTick{#1}\rput[r](-0.2, #1){#2}}

\newcommand{\fcLabels}[1][$x$]{%
  \def\ArgpsXAxisLabel{{#1}}%
  \fcLabelsRelay
}
\newcommand\fcLabelsRelay[3][$y$]{\rput[t](! #2 -0.1){\ArgpsXAxisLabel}\rput[r](! -0.1 #3){#1}}

\newcommand{\fcLabelsWithOnes}[2]{\psline(1, -0.1)(1,0.1) \rput[t](1, -0.2 ) { $1$} \psline(-0.1, 1)(0.1, 1) \rput[r](-0.2, 1 ) { $1$} \fcLabels{#1}{#2}}

\newcommand{\fcDefaultXLabel}{$x$}
\newcommand{\fcDefaultYLabel}{$y$}

\newcommand{\fcBoundingBox}[4]{%
\psframe*[linecolor=white](! #1\space #2)(! #3\space #4)%
\psline[linecolor=black!1](! #1 #2 )(! #1 #2 0.01 add)%
\psline[linecolor=black!1](! #3 #4 )(! #3 #4 0.01 add)%
}
\newcommand{\fcAxesStandardNoFrame}[5][]{%
\psline[arrows=<->, linecolor=black, linewidth=1pt, #1](! #2\space 0)(! #4\space 0)% 
\psline[arrows=<->, linecolor=black, linewidth=1pt, #1](! 0\space #3)(! 0\space #5)% \fcLabels[\fcDefaultXLabel][\fcDefaultYLabel]{#3}{#4}%
}%

\newcommand{\fcAxesStandard}[5][]{%
\psframe*[linecolor=white](! #2\space #3)(! #4 \space 0.1 add #5 \space 0.1 add)%
\fcAxesStandardNoFrame[#1]{#2}{#3}{#4}{#5}%
}%
\newcommand{\fcColorTangent}{blue}
\newcommand{\fcColorGraph}{red}
\newcommand{\fcColorAreaUnderGraph}{cyan}
\newcommand{\fcColorNegativeAreaUnderGraph}{orange}

\newcommand{\fcMachine}[2]{
\pscustom*[linecolor=#2]{
\psline(1,1.1)(1,0.1)(1.5,0.1)(2, 0.6)(2.5, 0.6)(2.5, -0.6)(2, -0.6)(1.5,-0.1)(1,-0.1)(1,-1.1)(-1,-1.1)(-1,-0.1)(-1.5,-0.1)(-2, -0.6)(-2.5, -0.6)(-2.5, 0.6)(-2, 0.6)(-1.5,0.1)(-1,0.1)(-1,1.1)
}
\pscircle*[linecolor=white](0,0){0.3}
\rput(0,0){#1}
}

%command format
%first argument gives you formula for the direction field in
%postscript notation, for example x y add.
%second and third argument give the starting x,y coordinates
\newcommand{\fcDirectionFieldOneTangent}[6]{%
\pstVerb{%
3 dict begin%
/x #2 \space def%
/y #3 \space def%
/F #1 \space def%
}%
\psline[#6](! x F ATAN 57.295 mul cos #4 mul sub y F ATAN 57.295 mul sin #4 mul sub)(! x F ATAN 57.295 mul cos #4 mul add y F ATAN 57.295 mul sin #4 mul add)%
\pscircle*[linecolor=red!60](! x y){#5}%
\pstVerb{%
end%
}%
}

\newcommand{\fcDirectionFieldOneTangentDefault}[3]{%
\fcDirectionFieldOneTangent{#1}{#2}{#3}{0.3}{0.03}{linecolor=blue}%
}

%command format
%first argument gives you formula for the direction field in
%postscript notation, for example x y add.
%second and third argument give the starting x,y coordinates
%fourth coordinate gives the delta x=delta y
%fifth argument gives the number of iterations delta x
%sixth argument gives the number of iterations delta y
%seventh argument gives the length of the vector
%eighth  argument gives the circle radius
%ninth argument gives the arguments of the psline command
\newcommand{\fcDirectionFieldFull}[9]{%
\multido{\ra=#2+#4}{#5}{%
\multido{\rb=#3+#4}{#6}{%
\fcDirectionFieldOneTangent{#1}{\ra}{\rb}{#7}{#8}{#9}%
}%end multido
}%end multido
}%end newcommand

\newcommand{\fcDirectionFieldDefault}[5]{%
\fcDirectionFieldFull{#1}{#2}{#3}{#4}{#5}{#5}{0.2}{0.02}{linecolor=blue}%
}%
\newcommand{\fcDirectionFieldDefaultRange}[1]{%
\fcDirectionFieldFull{#1}{-4}{-4}{0.5}{21}{21}{0.2}{0.02}{linecolor=blue}%
}

\newcommand{\fcMatrixTimesMatrix}{
10 dict begin
/matrixRight exch def
/matrixLeft exch def
/rowCounter -1 def
[
matrixLeft length {
/rowCounter rowCounter 1 add def
/columnCounter -1 def
[
matrixRight 0 get length{
/columnCounter columnCounter 1 add def
/thirdCounter -1 def
/accum 0 def
matrixLeft rowCounter get length{
/thirdCounter thirdCounter 1 add def
/accum accum
matrixLeft rowCounter get thirdCounter get
matrixRight thirdCounter get columnCounter get
mul add def
}repeat
accum
}repeat
]
}repeat
]
end
}

\newcommand{\fcMatrixTimesVector}{
10 dict begin
/theVector exch def
/theMatrix exch def
/rowCounter -1 def
[
theMatrix length {
/rowCounter rowCounter 1 add def
/columnCounter -1 def
/accum 0 def
theVector length{
/columnCounter columnCounter 1 add def
/accum accum
theMatrix rowCounter get columnCounter get theVector columnCounter get mul
add def
}repeat
accum
}repeat
]
end
}

\newcommand{\fcVectorProjectOntoVector}{%
\fcVectorNormalize dup 3 1 roll \fcVectorScalarVector \fcVectorTimesScalar%
} %

%fcAngleIIId Arguments:
%first optional: pstricks options
%second: vector describing arm of first angle
%third: vector describing arm of second angle
%fourth: radius of arc representing the angle
\newcommand{\fcAngleIIId}[4][]{%
\pstVerb{%
3 dict begin%
/firstV #2 \fcVectorNormalize def%
/orthonormalV #3 dup firstV  \fcVectorProjectOntoVector \fcVectorMinusVector \fcVectorNormalize def%
/theAngle firstV #3\space \fcVectorNormalize \fcVectorScalarVector arccos def%
}%
\parametricplot[#1]{0}{theAngle}{firstV t cos #4 mul \fcVectorTimesScalar orthonormalV t sin #4 mul \fcVectorTimesScalar \fcVectorPlusVector \fcCoordsIIIdToPStricks}%
\pstVerb{end}%
}

\newcommand{\fcAngleDegrees}[5][linecolor=red]{%
\parametricplot[#1]{#2}{#3}{t cos #4\space mul t sin #4\space mul}%
\rput(! #2\space #3\space add 2 div dup cos #4\space 1.2 mul mul exch sin #4\space 1.2 mul mul){#5}%
}

% angle from three points
% 1st argument = options
% 2,3,4th argument = the three points
% 5th argument = radius of the arc.
% example: \fcAngleFromThreePoints{[0 1]}{[3 5]}{[ 2 7]}{0.2}
\newcommand{\fcAngleFromThreePoints}[5][ ]{%
\setkeys{fcGraphics}{#1}%
\pstVerb{%
25 dict begin %
/angleVertex #3\space def
/initialArmPoint #2\space def
/terminalArmPoint #4\space def
/arcRadius #5\space def
angleVertex \fcCheckIsArray not initialArmPoint \fcCheckIsArray not terminalArmPoint \fcCheckIsArray not or or {
(ERROR: at least one of the input to the fcAngleFromThreePoints command is not a vector. ) ==
(Your inputs are: ) ==
angleVertex ==
initialArmPoint ==
terminalArmPoint ==
}{
/firstV initialArmPoint angleVertex \fcVectorMinusVector \fcVectorNormalize def%
/secondV terminalArmPoint angleVertex \fcVectorMinusVector \fcVectorNormalize def%
/orthonormalV secondV dup firstV  \fcVectorProjectOntoVector \fcVectorMinusVector \fcVectorNormalize def%
/theAngle firstV secondV \fcVectorNormalize \fcVectorScalarVector arccos def%
}ifelse
}%
\parametricplot[linewidth=\fcAngleLineWidth, linecolor=\fcColorAngle]{0}{theAngle}{firstV t cos arcRadius mul \fcVectorTimesScalar orthonormalV t sin arcRadius mul \fcVectorTimesScalar \fcVectorPlusVector angleVertex \fcVectorPlusVector \fcArrayToStack}%
\psline[#1](! initialArmPoint  \fcArrayToStack)(! angleVertex \fcArrayToStack)(! terminalArmPoint \fcArrayToStack)%
\pstVerb{end}%
}%

\newcommand{\fcAngleBetweenVectors}[5][linecolor=\fcColorGraph]{%
\pstVerb{%
3 dict begin%
/firstV #2 \fcVectorNormalize def%
/orthonormalV #3 dup firstV  \fcVectorProjectOntoVector \fcVectorMinusVector \fcVectorNormalize def%
/theAngle firstV #3\space \fcVectorNormalize \fcVectorScalarVector arccos def%
}%
\parametricplot[#1]{0}{theAngle}{firstV t cos #4 mul \fcVectorTimesScalar orthonormalV t sin #4 mul \fcVectorTimesScalar \fcVectorPlusVector \fcArrayToStack}%
\rput(! firstV theAngle 2 div cos #4 mul \fcVectorTimesScalar orthonormalV theAngle 2 div sin #4 mul \fcVectorTimesScalar \fcVectorPlusVector \fcArrayToStack){#5}
\pstVerb{end}%
}

\makeatletter
\newcommand{\fcAngle}[5][linecolor=\fcColorGraph]{%
\ifPst@algebraic{%
\parametricplot[#1, algebraic=true]{#2}{#3}{#4*cos(t)| #4*sin(t)}%
\rput(! #2\space #3\space add 2 div 57.29578 mul cos #4\space 0.2 add mul #2\space #3\space add 2 div 57.29578 mul sin #4\space 0.2 add mul){#5}%
}%
\else%
\parametricplot[#1, algebraic=false]{#2}{#3}{t 57.29578 mul cos #4\space mul t 57.29578 mul sin #4\space mul}%
\rput(! #2\space #3\space add 2 div 57.29578 mul cos #4\space 0.2 add mul #2\space #3\space add 2 div 57.29578 mul sin #4\space 0.2 add mul){#5}%
\fi%
}
\makeatother

\newcommand{\fcDistance}{ \fcVectorMinusVector \fcVectorNorm\space}

%Indicates length with options #1 
%from point (argument2, argument3) to point (argument4, argument5)
%with label argument6
\newcommand{\fcLengthIndicator}[6][]{%
\psline[arrows=-|, linecolor=red, #1](! #2 0.58 mul #4 0.42 mul add #3 0.58 mul #5 0.42 mul add)(! #2 #3)%
\psline[arrows=-|, linecolor=red, #1](! #2 0.42 mul #4 0.58 mul add #3 0.42 mul #5 0.58 mul add)(! #4 #5)%
\rput(! #2 #4 add 0.5 mul #3 #5 add 0.5 mul){#6}%
}%

\newcommand{\fcLengthIndicatorTwo}[6][t]{%
\pstVerb{5 dict begin
/pointA [#2\space #3] def 
/pointB [#4\space #5] def 
}%
\psline[arrows=|-|](! pointA \fcArrayToStack)(! pointB \fcArrayToStack)%
\rput[#1](! pointA pointB \fcVectorPlusVector 0.5 \fcVectorTimesScalar \fcArrayToStack){#6}%
\pstVerb{end}%
%\rput[#1](0 ,0){#1}%
}

\makeatletter
\newcommand{\fcDrawPolar}[4][linecolor=\fcColorGraph]{%
\ifPst@algebraic{%
\parametricplot[#1]{#2}{#3}{(#4) *cos(t) | (#4) * sin(t)}%
}%
\else%
\parametricplot[#1]{#2}{#3}{#4 t 57.29578 mul cos mul #4 t 57.29578 mul sin mul}%
\fi%
}
\makeatother

\newcommand{\fcPolarWedge}[4][fillstyle=solid, linecolor=blue, fillcolor=\fcColorAreaUnderGraph]{%
\pstVerb{%
2 dict begin%
/theta {t 57.295779513 mul} def%
/r {#4} def%
}%
\pscustom[#1]{%
\psline(0,0)%
(! 1 dict begin /t #2\space def theta cos r mul theta sin r mul end)%
(! 1 dict begin /t #3\space def theta cos r mul theta sin r mul end)%
(0,0)%
} %
\pstVerb{end}%
}%

\newcommand{\fcPolarWedgeSequence}[4]{%
\multido{\ra=#1+#2}{#3}{%
\fcPolarWedge{\ra}{\ra\space #2 add}{#4}%
}%
}

\newcommand{\fcRegularNgon}[3][linecolor=\fcColorGraph]{%
\multido{\ra=0+1}{#2}{%
\psline[#1](! \ra \space #2 div 360 mul cos #3 mul \ra \space #2 div 360 mul sin #3 mul)(! \ra \space 1 add #2 div 360 mul cos #3 mul \ra \space 1 add #2 div 360 mul sin #3 mul)%
}%end multido
}

\newcommand{\fcEvaluateT}[2]{%
1 dict begin /t #1 def #2 end
}

\newcommand{\fcPolylineAlongCurve}[5][linecolor=\fcColorGraph]{%
\multido{\ra=0+1}{#2}{%
\psline[#1](! \fcEvaluateT{\ra\space #2 div #3 mul 1 \ra \space #2 div sub #4 mul add}{#5})(! \fcEvaluateT{\ra\space 1 add #2 div #3 mul 1 \ra \space 1 add #2 div sub #4 mul add}{#5})%
\rput(! \fcEvaluateT{\ra\space #2 div #3 mul 1 \ra \space #2 div sub #4 mul add}{#5}){\fcFullDot{0}{0}}%
}%
\rput(! \fcEvaluateT{#3}{#5}){\fcFullDot{0}{0}}%
}

\newcommand{\fcPolylineAlongCurveWithLabels}[6][linecolor=\fcColorGraph]{%
\fcPolylineAlongCurve[#1]{#2}{#3}{#4}{#5}%
\multido{\ia=0+1}{#2}{%
\rput[b](! \fcEvaluateT{\ia\space #2 div #3 mul 1 \ia \space #2 div sub #4 mul add}{#5} 0.1 add){${#6}_{\ia}$}%
}%
\rput[b](! \fcEvaluateT{#3}{#5}){${#6}_{#2}$}%
}

\newcommand{\fcVectorNormalize}{ %
1 dict begin %
/theV exch def % theV is our vector
theV 1 theV \fcVectorNorm div \fcVectorTimesScalar %
end %
} %pushes elements of array onto the stack

\newcommand{\fcArrayToStack}{ %
aload pop
} %pushes elements of array onto the stack

\newcommand{\fcSpliceArrayOperationArray}{ %
5 dict begin %
/theOp exch def %
/secondV exch def %
/firstV exch def %
/counter 0 def %
/dimension firstV length def %
[dimension {firstV counter get secondV counter get theOp /counter counter 1 add def } repeat] %
end %
} %splices two arrays and operation, for example [a b] [c d] {op} -> [a c op b d op]

\newcommand{\fcSpliceArrayOperation}{ %
4 dict begin %
/theOp exch def %
/firstV exch def %
/counter 0 def %
/dimension firstV length def %
[ dimension {firstV counter get theOp /counter counter 1 add def } repeat ] %
end %
} %splices array with operation. [a b] {op} -> [a op b op]

\newcommand{\fcArrayOperation}{ %
4 dict begin %
/theOp exch def %
/firstV exch def %
/counter 0 def%
/dimension firstV length def %
dimension {firstV counter get /counter counter 1 add def} repeat %
dimension 1 sub {theOp} repeat %
end %
} %applies operation n-1 times to array. Example: [a b c] {op} -> a b c op op

\newcommand{\fcVectorScalarVector}{%
{mul} \fcSpliceArrayOperationArray {add}\fcArrayOperation
} %Scalar product two vectors

\newcommand{\fcVectorPlusVector}{%
{add} \fcSpliceArrayOperationArray %
} %Adds two vectors

\newcommand{\fcVectorMinusVector}{%
{sub} \fcSpliceArrayOperationArray %
} %Adds two vectors

\newcommand{\fcVectorTimesScalar}{ %
2 dict begin %
/theScalar exch def %
/theV exch def %
theV {theScalar mul} \fcSpliceArrayOperation %
end %
} %

\newcommand{\fcVectorTripleProduct}{%
\fcVectorCrossVector \fcVectorScalarVector\space %
}

\newcommand{\fcVectorCrossVector}{ %
8 dict begin %
/vectB exch def %
/vectA exch def %
vectA \fcArrayToStack %
/a3 exch def %The three coordinates of Vector a
/a2 exch def %
/a1 exch def %
vectB \fcArrayToStack %
/b3 exch def %The three coordinates of Vector b
/b2 exch def %
/b1 exch def %
[a2 b3 mul a3 b2 mul sub a3 b1 mul a1 b3 mul sub a1 b2 mul a2 b1 mul sub] %the cross product of a and b
end %
}

\newcommand{\fcVectorNorm}{%
dup \fcVectorScalarVector sqrt %
} %

\newcommand{\fcVectorNormSquared}{%
dup \fcVectorScalarVector %
} %

\newcommand{\fcMarkClean}{
mark\space
}

\newcommand{\fcMarkCleanCheck}{
counttomark 0 ne {(ERROR: procedure did not clean up properly. Printing stack: ) print pstack == error}if pop
}

\newcommand{\fcProjectOntoScreen}{%
3 dict begin %
\fcScreen\space %
/theD exch def %
/theNormal exch def %
/theV exch def %
theV theNormal theD theV theNormal \fcVectorScalarVector sub theNormal \fcVectorNormSquared div \fcVectorTimesScalar \fcVectorPlusVector %
end %
} %Projection of point onto a plane. First argument is point, second argument is plane normal, third argument is the scalar product you need to have with the normal to be in the plane. Format: [1 2 3] [4 5 6] 7, corresponds to projecting the point (1,2,3) onto the plane 4x+5y+6z=7

\newcommand{\fcCoordsIIIdToPStricks}{%
5 dict begin %
/theV exch def %
/theVprojected theV \fcProjectOntoScreen [0 0 0] \fcProjectOntoScreen  \fcVectorMinusVector def%
/theNormalizedNormal \fcScreen\space pop \fcVectorNormalize def %
(\fcScreenStyle) (z) eq %
{ %
/theYUnitV [0 0 1] \fcProjectOntoScreen [0 0 0] \fcProjectOntoScreen \fcVectorMinusVector \fcVectorNormalize def %
/theXUnitV theNormalizedNormal theYUnitV \fcVectorCrossVector def %
} %
{ %
(\fcScreenStyle) (x) eq %
{
/theXUnitV [1 0 0] \fcProjectOntoScreen [0 0 0] \fcProjectOntoScreen \fcVectorMinusVector \fcVectorNormalize def %
/theYUnitV theXUnitV theNormalizedNormal \fcVectorCrossVector def%
}
{
/theYUnitV \fcScreenStyle \fcProjectOntoScreen [0 0 0] \fcProjectOntoScreen \fcVectorMinusVector \fcVectorNormalize def%
/theXUnitV theNormalizedNormal theYUnitV \fcVectorCrossVector def%
} ifelse%
}%
ifelse %
%(normalized normal: ) == theNormalizedNormal ==
%(y unit v) == theYUnitV ==
%(x unit v: ) == theXUnitV ==
theVprojected theXUnitV \fcVectorScalarVector theVprojected theYUnitV \fcVectorScalarVector
end %
}

\newcommand{\fcCoordsIIIdToPS}{%
[ exch \fcCoordsIIIdToPStricks ] \fcCoordsPStricksToPS
}

\newcommand{\fcBoxIIId}[5][]{%
\pstVerb{%
4 dict begin%
/visibleCorner #2 def%
/vectorOne #3 #2 \fcVectorMinusVector def%
/vectorTwo #4 #2 \fcVectorMinusVector def%
/vectorThree #5 #2 \fcVectorMinusVector def%
}%
\fcPolyLineIIId[#1]{visibleCorner dup vectorOne \fcVectorPlusVector dup vectorTwo \fcVectorPlusVector dup vectorOne \fcVectorMinusVector dup vectorTwo \fcVectorMinusVector visibleCorner}%
\fcPolyLineIIId[#1]{visibleCorner dup vectorOne \fcVectorPlusVector dup vectorThree \fcVectorPlusVector dup vectorOne \fcVectorMinusVector dup vectorThree \fcVectorMinusVector}%
\fcPolyLineIIId[#1]{visibleCorner vectorTwo \fcVectorPlusVector dup vectorThree \fcVectorPlusVector dup vectorTwo \fcVectorMinusVector}%
\fcPolyLineIIId[#1, linestyle=dashed]{visibleCorner vectorOne  vectorTwo vectorThree \fcVectorPlusVector \fcVectorPlusVector \fcVectorPlusVector dup vectorOne \fcVectorMinusVector}%
\fcPolyLineIIId[#1, linestyle=dashed]{visibleCorner vectorOne  vectorTwo vectorThree \fcVectorPlusVector \fcVectorPlusVector \fcVectorPlusVector dup vectorTwo \fcVectorMinusVector}%
\fcPolyLineIIId[#1, linestyle=dashed]{visibleCorner vectorOne  vectorTwo vectorThree \fcVectorPlusVector \fcVectorPlusVector \fcVectorPlusVector dup vectorThree \fcVectorMinusVector}%
\pstVerb{end}%
}

\newcommand{\fcParallelogramIIIdCode}{
4 dict begin
/v2 exch def
/v1 exch def
/v0 exch def
/secondRun false def
2 {
newpath
v0 \fcCoordsPStricksToPS moveto
v0 v1 \fcVectorPlusVector \fcCoordsPStricksToPS lineto
v0 v1 v2 \fcVectorPlusVector \fcVectorPlusVector \fcCoordsPStricksToPS lineto
v0 v2 \fcVectorPlusVector \fcCoordsPStricksToPS lineto
v0 \fcCoordsPStricksToPS lineto
closepath
secondRun not {fill} if
stroke
/secondRun true def
}repeat
end
}

\newcommand{\fcPatchMakeFromThreeCorners}{
5 dict begin
/options exch def
/v2 exch def
/v1 exch def
/v0 exch def
/v3 v1 v2 \fcVectorPlusVector v0 \fcVectorMinusVector def
[v0 v1 v2 v3 [v0 v1 v1 v3 v3 v2 v2 v0] options]
end
}

\newcommand{\fcZDepth}{
\fcScreen\space pop \fcVectorScalarVector
}

\newcommand{\fcBoxIIIdFilledCode}{
%input order
% corner0 corner1 corner2 corner3
15 dict begin
/currentDashes exch def
/contourIsDashedIndependentOfVisibility exch def
/sidesVisible exch def
/colorSides exch def
/colorContour exch def
/options [colorSides colorSides true true colorContour contourIsDashedIndependentOfVisibility currentDashes] def
/corner3 exch def
/corner2 exch def
/corner1 exch def
/corner0 exch def
/v1 corner1 corner0 \fcVectorMinusVector def
/v2 corner2 corner0 \fcVectorMinusVector def
/v3 corner3 corner0 \fcVectorMinusVector def
%the following code selects the corner closest to the viewing screen
v1 \fcScreen\space pop \fcVectorScalarVector 0 lt
{/corner0 corner0 v1 \fcVectorPlusVector def /v1 v1 -1 \fcVectorTimesScalar def }if
v2 \fcScreen\space pop \fcVectorScalarVector 0 lt
{/corner0 corner0 v2 \fcVectorPlusVector def /v2 v2 -1 \fcVectorTimesScalar def }if
v3 \fcScreen\space pop \fcVectorScalarVector 0 lt
{/corner0 corner0 v3 \fcVectorPlusVector def /v3 v3 -1 \fcVectorTimesScalar def }if
%the closest corner is selected, we are recomputing the box corners
/corner1 corner0 v1 \fcVectorPlusVector def
/corner2 corner0 v2 \fcVectorPlusVector def
/corner3 corner0 v3 \fcVectorPlusVector def
[
corner0 corner1 corner2 options \fcPatchMakeFromThreeCorners
corner0 corner2 corner3 options \fcPatchMakeFromThreeCorners
corner0 corner3 corner1 options \fcPatchMakeFromThreeCorners
%corner1 corner1 v2 \fcVectorPlusVector corner1 v3 \fcVectorPlusVector options \fcPatchMakeFromThreeCorners
%corner2 corner2 v3 \fcVectorPlusVector corner2 v1 \fcVectorPlusVector options \fcPatchMakeFromThreeCorners
%corner3 corner3 v1 \fcVectorPlusVector corner3 v2 \fcVectorPlusVector options \fcPatchMakeFromThreeCorners
]
/LeftGreaterThanRight {\fcPatchGetPoint \fcZDepth exch \fcPatchGetPoint \fcZDepth gt} def
\fcMergeSort
sidesVisible{dup {\fcPatchPaintFilledDirectly }forall }if
{\fcPatchPaintContourDirectly}forall
/cornerop corner0 v1 v2 v3 \fcVectorPlusVector \fcVectorPlusVector \fcVectorPlusVector def
\fcLineFormatCode
currentDashes \fcArrayToStack setdash
[v1 v2 v3]
{
newpath
cornerop \fcCoordsIIIdToPS moveto
cornerop exch \fcVectorMinusVector \fcCoordsIIIdToPS lineto
stroke
}forall
end
}

\newcommand{\fcBoxIIIdFilledNew}[5][]{%
\setkeys{fcGraphics}{#1}%
\pscustom{%
\code{%
\fcSetUpGraphicsToScreen %
#2\space #3\space #4\space #5\space[ \fcGetColorCode{\fcColorLine} ] [\fcGetColorCode{\fcColorPatchUV}] true (\fcLineStyle) (dashed) eq [\fcDashes] \fcBoxIIIdFilledCode%
}%
}%
}

\newcommand{\fcBoxIIIdHollowNew}[5][]{%
\setkeys{fcGraphics}{#1}%
\pscustom{%
\code{%
\fcSetUpGraphicsToScreen %
#2\space #3\space #4\space #5\space[ \fcGetColorCode{\fcColorLine} ] [\fcGetColorCode{\fcColorPatchUV}] false (\fcLineStyle) (dashed) eq [\fcDashes] \fcBoxIIIdFilledCode%
}%
}%
}

\newcommand{\fcBoxIIIdFilled}[5][]{%
\pscustom*[#1]{%
\fcPolyLineIIId{4 dict begin%
/visibleCorner #2 def%
/vectorOne #3 #2 \fcVectorMinusVector def%
/vectorTwo #4 #2 \fcVectorMinusVector def%
/vectorThree #5 #2 \fcVectorMinusVector def %
visibleCorner vectorOne \fcVectorPlusVector dup vectorTwo \fcVectorPlusVector dup vectorOne \fcVectorMinusVector dup vectorThree \fcVectorPlusVector dup vectorTwo \fcVectorMinusVector dup vectorOne \fcVectorPlusVector visibleCorner vectorOne \fcVectorPlusVector end %
}%
}%
}

\newcommand{\fcParallelogramIIId}[4][linecolor=cyan!30]{%
\pscustom*[#1]{%
\fcParallelogramHollowIIId{#2}{#3}{#4}%
}%
}

\newcommand{\fcParallelogramHollowIIId}[4][]{ %
\fcPolyLineIIId[#1]{3 dict begin /corner #2 def /vectorOne #3 #2 \fcVectorMinusVector def /vectorTwo #4 #2 \fcVectorMinusVector def corner dup vectorOne \fcVectorPlusVector dup vectorTwo \fcVectorPlusVector dup vectorOne \fcVectorMinusVector corner end
}%
}

\newcommand{\fcParallelogramHalfVisibleIIId}[4][]{%
\pstVerb{3 dict begin /corner #2 def /vectorOne #3 #2 \fcVectorMinusVector def /vectorTwo #4 #2 \fcVectorMinusVector def}%
\fcPolyLineIIId[#1]{corner vectorOne \fcVectorPlusVector corner dup vectorTwo \fcVectorPlusVector}%
\fcPolyLineIIId[#1,linestyle=dashed]{corner vectorOne \fcVectorPlusVector dup vectorTwo \fcVectorPlusVector dup vectorOne \fcVectorMinusVector}%
\pstVerb{end}%
}

\newcommand{\fcPolyLineIIId}[2][linecolor=black]{%
\listplot[#1]{ [#2] {\fcCoordsIIIdToPStricks} \fcSpliceArrayOperation \fcArrayToStack}%
}

%\newcommand{\fcCoordsPStricksToPS}{\fcArrayToStack \fcConvertPSYUnit exch \fcConvertPSXUnit exch\space }
\makeatletter
\newcommand{\fcCoordsPStricksToPS}{\fcArrayToStack \tx@ScreenCoor\space }
\makeatother

\newcommand{\fcLine}[3][]{%
\setkeys{fcGraphics}{#1}
\pscustom{%
\code{%
\fcLineFormatCode
newpath %
#2\space \fcCoordsPStricksToPS moveto %
#3\space \fcCoordsPStricksToPS lineto %
stroke %
}%
}%
}

\newcommand{\fcEllipsoidInScene}[2][iterationsU=22, iterationsV=22]{%
\setkeys{fcGraphics}{#1}%
\pstVerb{%
/theIIIdObjects%
[theIIIdObjects \fcArrayToStack [0 0 180 360%
{ #2\space 6 dict begin%
  /c exch def%
  /b exch def%
  /a exch def%
  /z1 exch def%
  /y1 exch def%
  /x1 exch def%
  [ u sin v cos mul a mul x1 add %
    u sin v sin mul b mul y1 add %
    u cos c mul z1 add%
  ]%
  end%
}%
{true}%
\fcIterationsU\space \fcIterationsV\space %
\fcPatchOptions %
\fcContourOptions %
(surface)%
]%
]%
def%
}%
}

\newcommand{\fcLineFormatCode}{\fcDashesCode \fcLineWidth\space setlinewidth \fcGetColorCode{\fcColorLine} setrgbcolor %(fcDashesCode: \fcDashesCode ) == %
}
\newcommand{\fcLineFormatCodeVirtual}{\fcDashesCodeVirtual \fcLineWidth\space setlinewidthVirtual \fcGetColorCode{\fcColorLine} setrgbcolorVirtual %(fcDashesCodeVirtual: \fcDashesCodeVirtual ) == %
}

\newcommand{\fcCurveCode}{%
%(calling fcCurveCode) == %
5 dict begin %
%newpath 0 0 moveto 1000 1000 lineto stroke
/theCurve exch def %
%theCurve == %
/tMin exch def%
/tMax exch def%
/Delta tMax tMin sub \fcPlotPoints \space 1 sub div def %
/t tMin def %
\fcLineFormatCode %
newpath %
theCurve \fcCoordsPStricksToPS moveto %
\fcPlotPoints\space 1 sub {/t t Delta add def theCurve \fcCoordsPStricksToPS lineto %
} repeat %
stroke %
end\space%
}

\newcommand{\fcCurve}[4][]{%
\setkeys{fcGraphics}{#1}%
\pstVerb{#2\space #3\space {#4} \space \fcCurveCode}%
}

\newcommand{\fcLineIIId}[3][linecolor=black]{%
\psline[#1](! #2 \space \fcCoordsIIIdToPStricks)(! #3 \space \fcCoordsIIIdToPStricks)%
}

\newcommand{\fcAxesIIIdFull}[4][linecolor=black, arrows=->]{%
\fcAxesIIId[#1]{#2}{#3}{#4}%
\fcLineIIId[#1]{[0 0 0]}{[#2\space -1 mul 0 0]}%
\fcLineIIId[#1]{[0 0 0]}{[0 #3\space -1 mul 0]}%
\fcLineIIId[#1]{[0 0 0]}{[0 0 #4\space -1 mul]}%
} %

\newcommand{\fcAxesIIIdInScene}[4][linecolor=black, arrows=->]{%
\setkeys{fcGraphics}{#1}%
\fcLineIIIdInScene[#1]{[0 0 0]}{[#2 0 0]}%
\fcLineIIIdInScene[#1]{[0 0 0]}{[0 #3 0]}%
\fcLineIIIdInScene[#1]{[0 0 0]}{[0 0 #4]}%
\rput[l](! [#2 0 0] \fcCoordsIIIdToPStricks){~\fcXLabel}%
\rput[l](! [0 #3 0] \fcCoordsIIIdToPStricks){~\fcYLabel}%
\rput[r](! [0 0 #4] \fcCoordsIIIdToPStricks){\fcZLabel~}%
}%

\newcommand{\fcAxesIIIdFullInScene}[4][linecolor=black, arrows=->]{%
\setkeys{fcGraphics}{#1}%
\fcLineIIIdInScene[#1]{[0 0 0]}{[#2 0 0]}%
\fcLineIIIdInScene[#1]{[0 0 0]}{[0 #3 0]}%
\fcLineIIIdInScene[#1]{[0 0 0]}{[0 0 #4]}%
\fcLineIIIdInScene[#1]{[0 0 0]}{[#2\space-1 mul 0 0]}%
\fcLineIIIdInScene[#1]{[0 0 0]}{[0 #3\space-1 mul 0]}%
\fcLineIIIdInScene[#1]{[0 0 0]}{[0 0 #4\space-1 mul]}%
}

\newcommand{\fcAxesIIId}[4][linecolor=black, arrows=->]{%
\setkeys{fcGraphics}{#1}%
\fcLineIIId[#1]{[0 0 0]}{[#2 0 0]}%
\fcLineIIId[#1]{[0 0 0]}{[0 #3 0]}%
\fcLineIIId[#1]{[0 0 0]}{[0 0 #4]}%
\rput[l](! [#2 0 0] \fcCoordsIIIdToPStricks){~\fcXLabel}%
\rput[l](! [0 #3 0] \fcCoordsIIIdToPStricks){~\fcYLabel}%
\rput[r](! [0 0 #4] \fcCoordsIIIdToPStricks){\fcZLabel~}%
}

\newcommand{\fcDotIIId}[2][linecolor=\fcColorGraph]{%
\pscircle*[#1](! #2 \fcCoordsIIIdToPStricks){0.07} %
} %

\newcommand{\fcPutIIId}[3][]{ \rput[#1](! #2 \fcCoordsIIIdToPStricks) {#3}%
} %

\newcommand{\fcPaintCone}{ %
\fcArrayToStack %
15 dict begin %
/c exch def %
/b exch def %
/a exch def %
/z1 exch def %
/y1 exch def %
/x1 exch def %
/zmax exch def %
/zmin exch def %
}

\newcommand{\fcZBufferRowColumn}{ %
%input: vector on the top of the stack.
%output: row column of point in the z-buffer.
\fcCoordsIIIdToPStricks %
2 dict begin %
/rowIndex exch \space getZBufferYmin sub getZBufferYmax getZBufferYmin sub div zBufferNumRows mul floor cvi def %
/columnIndex exch getZBufferXmin sub getZBufferXmax getZBufferXmin sub div zBufferNumCols mul floor cvi def %
rowIndex zBufferNumRows ge {/rowIndex rowIndex 1 sub def}if %
columnIndex zBufferNumCols ge {/columnIndex columnIndex 1 sub def}if %
rowIndex zBufferNumRows ge {(ERROR: bad row index!!!) == rowIndex ==}if %
columnIndex zBufferNumCols ge {(ERROR: bad column index: ) == columnIndex == }if %
rowIndex 0 lt {/rowIndex rowIndex 1 add def}if %
columnIndex 0 lt {/columnIndex columnIndex 1 add def}if %
rowIndex 0 lt {(ERROR: bad row index!!!) == rowIndex ==}if %
columnIndex 0 lt {(ERROR: bad column index: ) == columnIndex ==  }if %
rowIndex columnIndex %
end %
}

\newcommand{\fcPointIsBehindOrInFrontOfPatch}[1]{ %
%(entering fcPointIsBehindOrInFrontOfPatch) ==
%a patch is assumed to be on the top of the stack
12 dict begin %
/thePatch exch def
/point exch def
thePatch \fcPatchGetInBounds
{
/v0 thePatch \fcPatchGetvZero def %
/v1 thePatch \fcPatchGetvOne def %
/v2 thePatch \fcPatchGetvTwo def %
/v3 thePatch \fcPatchGetvThree def %
/normalLeft v1 v0 \fcVectorMinusVector \fcScreen\space pop \fcVectorCrossVector def %
/normalRight v3 v2 \fcVectorMinusVector \fcScreen\space pop \fcVectorCrossVector def %
/normalBottom v2 v0 \fcVectorMinusVector \fcScreen\space pop \fcVectorCrossVector def %
/normalTop v3 v1 \fcVectorMinusVector \fcScreen\space pop \fcVectorCrossVector def %
/patchNormal v1 v0 \fcVectorMinusVector v2 v0 \fcVectorMinusVector \fcVectorCrossVector def %
point v0 \fcVectorMinusVector normalLeft \fcVectorScalarVector %
v2 point \fcVectorMinusVector normalRight \fcVectorScalarVector %
mul 0 ge { %
point v0 \fcVectorMinusVector normalBottom \fcVectorScalarVector %
v1 point \fcVectorMinusVector normalTop \fcVectorScalarVector %
mul 0 ge %
{ %
point v0 \fcVectorMinusVector patchNormal \fcVectorScalarVector %
\fcScreen\space pop patchNormal \fcVectorScalarVector %
mul #1{0.00001  gt}{-0.00001 lt}ifelse %
{true}{false}ifelse %
}{false}ifelse %
}{false}ifelse %
}{false}ifelse
end %
}

\newcommand{\fcIsInForeground}{ %
15 dict begin %
/theNeighborhood exch def %
/thePoint theNeighborhood 0 get def %
%(neighborhood: ) print
%theNeighborhood ==
%(thePoint:) print
%thePoint ==
thePoint \fcZBufferRowColumn %
/column exch def %
/row exch def %
/theZBuffEntry theZBuffer row get column get def %
/result true def %
/counterZBuff -1 def %
theZBuffEntry length { %
/counterZBuff counterZBuff 1 add def %
/theZbuffPatchIndex theZBuffEntry counterZBuff get def %
/theZbuffPatch thePatchCollection theZbuffPatchIndex get def %
theZbuffPatchIndex theNeighborhood \fcContains not{ %
%(patch) == theZbuffPatch == (is not contained in neighborhood ) ==
%theNeighborhood ==
thePoint theZbuffPatch \fcPointIsBehindOrInFrontOfPatch{true}
{/result false def
exit
}
{ %(point is in front of patch) ==
}
ifelse
}
{ %(patch coincides with zbuff patch) ==
}
ifelse %
}repeat %
result %
end %
}

\newcommand{\fcZBufferBoundingBoxPatch}{ %
5 dict begin %
/thePatch exch def
/v3 thePatch \fcPatchGetvThree def %
/v2 thePatch \fcPatchGetvTwo def %
/v1 thePatch \fcPatchGetvOne def %
/v0 thePatch \fcPatchGetvZero def %
v0 \fcZBufferBoundingBoxPoint %
v1 \fcZBufferBoundingBoxPoint %
v2 \fcZBufferBoundingBoxPoint %
v3 \fcZBufferBoundingBoxPoint %
v1 v2 \fcVectorPlusVector v0 \fcVectorMinusVector \fcZBufferBoundingBoxPoint %
end %
}

\newcommand{\fcZBufferBoundingBoxPoint}{ %
%Account bounding box:
\fcCoordsIIIdToPStricks %
dup dup getZBufferYmin lt {setZBufferYmin}{pop}ifelse %
dup getZBufferYmax gt {setZBufferYmax}{pop}ifelse %
dup dup getZBufferXmin lt {setZBufferXmin}{pop}ifelse %
dup getZBufferXmax gt {setZBufferXmax}{pop}ifelse \space%
}

\newcommand{\fcZBufferEllipsoid}{ %
%(calling fcZBufferEllipsoid with input: ) == dup == %
\fcArrayToStack
6 dict begin
/c exch def %
/b exch def %
/a exch def %
/z1 exch def %
/y1 exch def %
/x1 exch def %
[a -1 mul x1 add b -1 mul y1 add c -1 mul z1 add a x1 add b y1 add c z1 add] %
end
}

\newcommand{\fcSegmentBoundingBox}{ %
\fcZBufferBoundingBoxPoint %
\fcZBufferBoundingBoxPoint %
}

\newcommand{\fcZBufferPaintCellContainingPoint}{
10 dict begin
/thePoint exch def
thePoint \fcZBufferRowColumn
/column exch def
/row exch def
\fcZBufferComputeDeltaXDeltaY
/lowerLeftX getZBufferXmin DeltaX column mul add def
/lowerLeftY getZBufferYmin DeltaY row mul add def
gsave
0.6 0.6 1 setrgbcolor %
newpath
[lowerLeftX lowerLeftY] \fcCoordsPStricksToPS moveto
[lowerLeftX DeltaX add lowerLeftY] \fcCoordsPStricksToPS lineto
[lowerLeftX DeltaX add lowerLeftY DeltaY add] \fcCoordsPStricksToPS lineto
[lowerLeftX lowerLeftY DeltaY add] \fcCoordsPStricksToPS lineto
[lowerLeftX lowerLeftY] \fcCoordsPStricksToPS lineto
stroke
grestore
end
}

\newcommand{\fcZBufferComputeDeltaXDeltaY}{
/DeltaX getZBufferXmax getZBufferXmin sub zBufferNumCols div def %
/DeltaY getZBufferYmax getZBufferYmin sub zBufferNumRows div def %
}

\newcommand{\fcPaintZbuffForDebug}{ %
6 dict begin %
\fcZBufferComputeDeltaXDeltaY
gsave %
0.1 setlinewidth %
/x getZBufferXmin def %
0.5 0.5 0.5 setrgbcolor %
zBufferNumRows {newpath [x getZBufferYmin] \fcCoordsPStricksToPS moveto [x getZBufferYmax] \fcCoordsPStricksToPS lineto stroke /x x DeltaX add def}repeat %
/y getZBufferYmin def %
zBufferNumCols { newpath [getZBufferXmin y] \fcCoordsPStricksToPS moveto [getZBufferXmax y] \fcCoordsPStricksToPS lineto stroke /y y DeltaY add def}repeat %
/y getZBufferYmin DeltaY 2 div add def %
/counterY 0 def %
zBufferNumRows { %
/x getZBufferXmin DeltaX 2 div add def %
/counterX 0 def %
zBufferNumCols { %
theZBuffer counterY get counterX get length 0 gt{ %
[x y] \fcFullDotCode %
} if %
/x x DeltaX add def %
/counterX counterX 1 add def %
}repeat %
/y y DeltaY add def %
/counterY counterY 1 add def %
}repeat %
grestore %
end %
}

\newcommand{\fcStartIIIdScene}{%
\pstVerb{1 dict begin /theIIIdObjects [] def}%
}%

\newcommand{\fcZBufferPrint}{ %
(printing Zbuffer...) == %
getZBufferXmin == %
getZBufferXmax == %
getZBufferYmin == %
getZBufferYmax == %
theZBuffer == %
}

\newcommand{\fcZBufferLoad}{ %
\fcZBufferInitialize %
/theZBuffer exch def %
setZBufferYmax %
setZBufferYmin %
setZBufferXmax %
setZBufferXmin %
}

\newcommand{\fcZBufferInitialize}{ %
/ZBufferRectangle [0 0 0 0] def %
/setZBufferXmin {ZBufferRectangle exch 0 exch put} def %
/setZBufferYmin {ZBufferRectangle exch 1 exch put} def %
/setZBufferXmax {ZBufferRectangle exch 2 exch put} def %
/setZBufferYmax {ZBufferRectangle exch 3 exch put} def %
/getZBufferXmin {ZBufferRectangle 0 get} def %
/getZBufferYmin {ZBufferRectangle 1 get} def %
/getZBufferXmax {ZBufferRectangle 2 get} def %
/getZBufferYmax {ZBufferRectangle 3 get} def %
/zBufferNumCols \fcZBufferNumXIntervals\space def
/zBufferNumRows \fcZBufferNumYIntervals\space def
thePatchCollection length zBufferNumCols zBufferNumRows mul lt
{ /zBufferNumCols thePatchCollection length sqrt round cvi def
  zBufferNumCols 3 lt {/zBufferNumCols 3 def}if
  /zBufferNumRows zBufferNumCols def
  (There are only a few patches in the scene, I decreased z-buffer size to ) print zBufferNumCols == (rows and columns. ) print
}if
/getZBufferDeltaX {getZBufferXmax getZBufferXmin sub zBufferNumCols div} def %
/getZBufferDeltaY {getZBufferYmax getZBufferYmin sub zBufferNumRows div} def %
/theZBuffer [zBufferNumRows {[zBufferNumCols{[]} repeat]}repeat] def %
}

\newcommand{\fcPaintCachedFile}{
graphicsFile run
}

\newcommand{\fcSetUpGraphicsToScreen}{
%(SETTING UP graphcis SCREEN ONLY!!!) ==
/movetoVirtual {moveto} def
/linetoVirtual {lineto} def
/strokeVirtual {stroke} def
/closepathVirtual {closepath} def
/newpathVirtual {newpath} def
/fillVirtual {fill} def
/arrowVirtual {} def
/setrgbcolorVirtual {setrgbcolor} def
/setlinewidthVirtual {setlinewidth} def
/plotArrowHeadVirtual {\fcArrowHeadPlotCode} def
/setdashVirtual {setdash} def
}

\newcommand{\fcSetUpGraphicsToFileAndScreen}{
graphicsFile ( /plotArrowHeadVirtual {\fcArrowHeadPlotCode} def ) writestring
/storeNumberPairToGraphicsFile{
\fcMarkClean 3 1 roll
20 string cvs exch 20 string cvs graphicsFile exch writestring graphicsFile ( ) writestring graphicsFile exch writestring graphicsFile ( ) writestring
\fcMarkCleanCheck
} def
%(About to define movetoVirtual !!!!) ==
/movetoVirtual {
2 copy moveto
storeNumberPairToGraphicsFile
graphicsFile (moveto ) writestring
} def
/setlinewidthVirtual {
dup setlinewidth
20 string cvs graphicsFile exch writestring graphicsFile ( setlinewidth ) writestring
} def
/linetoVirtual {
2 copy lineto
storeNumberPairToGraphicsFile
graphicsFile (lineto ) writestring
} def
/strokeVirtual {
stroke
graphicsFile (stroke ) writestring
} def
/newpathVirtual {
newpath
graphicsFile (newpath ) writestring
} def
/closepathVirtual {
closepath
graphicsFile ( closepath ) writestring
} def
/fillVirtual {
fill
graphicsFile ( fill ) writestring
} def
/setrgbcolorVirtual {
3 copy
setrgbcolor %
graphicsFile 4 -1 roll \fcToString writestring graphicsFile ( ) writestring
graphicsFile 3 -1 roll \fcToString writestring graphicsFile ( ) writestring
graphicsFile exch \fcToString writestring
graphicsFile ( setrgbcolor ) writestring
} def
/setdashVirtual {
2 copy setdash
20 string cvs exch \fcToString graphicsFile exch writestring graphicsFile ( ) writestring graphicsFile exch writestring graphicsFile ( setdash ) writestring
} def
/plotArrowHeadVirtual {
2 copy \fcArrowHeadPlotCode\space
\fcToString exch \fcToString graphicsFile exch writestring graphicsFile ( ) writestring graphicsFile exch writestring graphicsFile ( plotArrowHeadVirtual ) writestring
}def
}

\newcommand{\fcSetupFilesGraphicsIIId}{
\fcSetUpGraphicsToScreen
/graphicsFileName (graphicsCacheSafeToDelete) (\fcScreen) [[1 0] \fcCoordsPStricksToPS] \fcToString [[0 1] \fcCoordsPStricksToPS] \fcToString 6 -1 roll \fcToString \fcHashString (.txt) 6 \fcConcatenateMultiple def
}

%defines graphicsFileAvailable to be true if cached, false else.
\newcommand{\fcSetupFilesGraphicsNameAlreadyDefined}{
/graphicsCached false def
/graphicsFileAvailable true def
/graphicsFile (file not open) def
errordict begin
/invalidfileaccess
{ userdict begin /graphicsFileAvailable false def end
(ERROR: failed to open file for caching large IIId rendering operations. ) print
(This is not fatal but will cause your graphics to compile incredibly slowly. ) print
(To fix this, compile with pdflatex --shell-escape. ) print
(Make sure the file is executed in a folder with write priviledges. \string\n) print
pop pop
} def
/undefinedfilename{
(File doesn't exist. ) print
 pop pop
} def
end
(Opening file ) print graphicsFileName print (. ) print
/graphicsFile graphicsFileName (r) file def
graphicsFile type (filetype) eq {
/graphicsCached true def
\fcPaintCachedFile
graphicsFile closefile
}
{ /graphicsFile graphicsFileName (w) file def
  graphicsFile type (filetype) ne{
  /graphicsFileAvailable false def
  }
  { \fcSetUpGraphicsToFileAndScreen
    (SET UP graphics TO FILE AND SCREEN) ==
  }
  ifelse
}ifelse
}

\newcommand{\fcSetupFiles}{
\fcSetupFilesGraphicsIIId
\fcSetupFilesGraphicsNameAlreadyDefined
}

\newcommand{\fcComputePatchesAndContours}{
/totalNumPatches 0 def
/totalNumContours 0 def
\fcMarkClean
theIIIdObjects {\fcObjectGetNumPatches /totalNumPatches exch totalNumPatches add def} forall
\fcMarkCleanCheck
\fcMarkClean
theIIIdObjects {\fcObjectGetNumContours /totalNumContours exch totalNumContours add def} forall
\fcMarkCleanCheck
/thePatchCollection [totalNumPatches {(empty)}repeat] def
/theContourCollection [totalNumContours{(empty)} repeat] def
(\string\n) print (Expected number of patches, contours: ) print
thePatchCollection length 20 string cvs print (, ) print
theContourCollection length 20 string cvs print
(. Computing patches and contours ...) print
/numPatchesComputedSoFar 0 def
/numContoursComputedSoFar 0 def
/counter -1 def
theIIIdObjects length {
/counter counter 1 add def
theIIIdObjects counter get \fcObjectComputePatchesAndContours
theIIIdObjects counter get \fcObjectGetNumPatches
/numPatchesComputedSoFar exch numPatchesComputedSoFar add def
theIIIdObjects counter get \fcObjectGetNumContours
/numContoursComputedSoFar exch numContoursComputedSoFar add def
} repeat
thePatchCollection{(empty) eq {(ERROR: declared patch not computed!)}if }forall
theContourCollection{(empty) eq {(ERROR: declared contour not computed!)}if }forall
(... computing patches and contours done!\string\n) print
}

\newcommand{\fcPaintPatches}{
thePatchIndices {\fcPaintPatchIndexFilledDirectly} forall
}

\newcommand{\fcPaintPatchLabels}{
/counter -1 def
0 0 0 setrgbcolorVirtual
thePatchCollection length
{/counter counter 1 add def
counter thePatchCollection counter get \fcPatchPaintLabel
}repeat
}

\newcommand{\fcPaintPatchSortOrder}{
/counter -1 def
0 0 0 setrgbcolorVirtual
thePatchIndices length
{/counter counter 1 add def
counter thePatchCollection thePatchIndices counter get get \fcPatchPaintLabel
}repeat
}

\newcommand{\fcPaintContours}{
theContourCollection{\fcPaintContour} forall %
}

\newcommand{\fcProcessCurrentZBuffer}{
/counterI -1 def
%(currentZBuffer is: ) ==
%currentZBuffer ==
currentZBuffer length {
/counterI counterI 1 add def
/counterJ -1 def
currentZBuffer length{
/counterJ counterJ 1 add def
counterI counterJ ne{
/leftIndex currentZBuffer counterI get def
/rightIndex currentZBuffer counterJ get def
rightIndex leftIndex \fcLeftPatchIsBehind {
rightIndex thePatchIncidenceGraph leftIndex get \fcContains not {
thePatchIncidenceGraph leftIndex
[ thePatchIncidenceGraph leftIndex get \fcArrayToStack rightIndex
]
put
}if
}if
}if
}repeat
}repeat
}

\newcommand{\fcComputePatchOrder}{
/thePatchIncidenceGraph [thePatchCollection length {[]}repeat] def
/rowCounter -1 def
(computing patch order... ) print
(processing z-buffer row, column:) print
theZBuffer length {
/rowCounter rowCounter 1 add def
/columnCounter -1 def
theZBuffer rowCounter get length {
/columnCounter columnCounter 1 add def
/currentZBuffer theZBuffer rowCounter get columnCounter get def
% % % % %
(\string\n) print rowCounter == columnCounter ==
(out of: ) print theZBuffer length == theZBuffer rowCounter get length ==
% % % % %
\fcProcessCurrentZBuffer
}repeat
}repeat
(... computing patch order done ) print
}

\newcommand{\fcSortPatchIndices}{
(sorting a total of ) print thePatchCollection length == ( patches... ) print
fastPatchSort
{ (\string\n Sorting patches by their z-depth. This may be inaccurate but is fast. ) print
  /counter -1 def
  /thePatchIndices [thePatchCollection length {/counter counter 1 add def counter} repeat] def
  20 dict begin
  /LeftGreaterThanRight
  { 4 dict begin
  	/rightPatch exch thePatchCollection exch get def
  	/leftPatch  exch thePatchCollection exch get def
    rightPatch \fcPatchGetForcedForegroundStatus leftPatch \fcPatchGetForcedForegroundStatus not and {true}{
    leftPatch \fcPatchGetForcedForegroundStatus rightPatch \fcPatchGetForcedForegroundStatus not and
    {false}{
  	leftPatch  \fcPatchGetPoint \fcScreen\space pop \fcVectorScalarVector
  	rightPatch \fcPatchGetPoint \fcScreen\space pop \fcVectorScalarVector
  	lt
  	}ifelse}ifelse
    end
  } def
  thePatchIndices \fcMergeSort
  end
  /thePatchIndices exch def
  (\string\n Sorting patches done. ) print
}
{
(\string\n Sorting patches via the partial order induced by their visibility. This is slow but somewhat accurate. ) print
%thePatchIncidenceGraph shall have one entry for each patch.
%The entry will consist of a list of all patch indices of
%patches that are behind our patch.
/thePatchIndices [thePatchCollection length {(empty)} repeat] def
20 dict begin
\fcComputePatchOrder
(patch incidence graph:) ==
thePatchIncidenceGraph ==
/accountPatch {
  /patchIndex exch def
  (accounting patch: ) print
  patchIndex ==
  /numAccountedLastCycle numAccountedLastCycle 1 add def
  accountedPatches patchIndex true put
  thePatchIndices numAccountedSoFar patchIndex put
  /numAccountedSoFar numAccountedSoFar 1 add def
} def
/accountedPatches [thePatchCollection length {false} repeat] def
/numAccountedSoFar 0 def
{
/numAccountedLastCycle 0 def
/patchIndex -1 def
thePatchIncidenceGraph length {
/patchIndex patchIndex 1 add def
accountedPatches patchIndex get not
{/patchIsNext true def
/patchBehindIndex -1 def
/patchesBehindCurrent thePatchIncidenceGraph patchIndex get def
patchesBehindCurrent length{
/patchBehindIndex patchBehindIndex 1 add def
accountedPatches patchesBehindCurrent patchBehindIndex get get not{
/patchIsNext false def exit
}if
}repeat
patchIsNext{
patchIndex accountPatch
}if
}if
}repeat
numAccountedLastCycle 0 eq{
(We have cyclically overlapping patches!) ==
/patchIndex -1 def
thePatchIncidenceGraph length {
/patchIndex patchIndex 1 add def
accountedPatches patchIndex get not
{ patchIndex accountPatch exit
}if
}repeat
}if
numAccountedSoFar thePatchIndices length eq{exit} if
}loop
(sorting patches done) print
%thePatchIndices ==
%(thePatchCollection: ) ==
%thePatchCollection ==
end
}ifelse
}

\newcommand{\fcFinishIIIdScene}[1][fastsort=false]{%
\setkeys{fcGraphics}{#1}%
\pscustom{%
\code{%
%print the objects we are about to paint:
theIIIdObjects length 0 gt { %
%(about to process IIId scene given by: ) print %
%theIIIdObjects == %
} if %
60 dict begin %
theIIIdObjects \fcSetupFiles
graphicsCached not{
/fastPatchSort \fcFastPatchSort\space def
% % % % % % % % % % % % % % % % % % %
\fcComputePatchesAndContours
% % % % % % % % % % % % % % % % % % %
\fcZBufferInitialize %
(computing bounding box IIId scene... ) print %
theContourCollection {\fcZBufferBoundingBoxPatchContour} forall
thePatchCollection {\fcZBufferBoundingBoxPatch} forall
%extend slightly the bounding box to take care of floating point errors at the
%border
getZBufferXmin 0.1 sub setZBufferXmin %
getZBufferXmax 0.1 add setZBufferXmax %
getZBufferYmin 0.1 sub setZBufferYmin %
getZBufferYmax 0.1 add setZBufferYmax %
(bounding box computed: ) == ZBufferRectangle == %
% % % % % % % % % % % % % % % % % % % % % % % % % %
(computing z-buffer IIId scene... ) print %
/counter -1 def
thePatchCollection length { /counter counter 1 add def counter \fcZBufferPatchIndex} repeat %
(z buffer computed.) print %
% % % % % % % % % % % % % % % % % % % % % % % % % %
\fcSortPatchIndices
\fcPaintPatches
\fcPaintContours
%\fcPaintPatchSortOrder
%\fcPaintPatchLabels
%[
%thePatchCollection { \fcPatchGetPoint \fcScreen \space pop \fcVectorScalarVector } forall
%] ==
% % % % % %
%(z buffer sorted) print %
% % % % % % % % % % % % % % % % % % % % % % % % % %
%\fcZBufferPrint %
%(painting patches) ==
%\fcZBufferPaintPatches
% %
%\fcPaintZbuffForDebug %
% %
end %
(done, printing stack to make sure no trash is left) == %
pstack %
} %if graphics is not cached
if
}%
}%
\pstVerb{end}%
}%

\newcommand{\fcObjectGetNumContours}{%
\fcArrayToStack %
1 dict begin %
/HandlerNotFound true def %
HandlerNotFound{dup (surface) eq {pop \fcSurfaceGetNumContours /HandlerNotFound false def} if} if %
HandlerNotFound{dup (curve) eq {pop \fcCurveInit 1 /HandlerNotFound false def} if} if %
HandlerNotFound{dup (triangle) eq {pop \fcTriangleInSceneInit 1 /HandlerNotFound false def} if} if %
HandlerNotFound{== (ERROR: OBJECT GET NUMBER OF CONTOURS HANDLER NOT FOUND)} if %
end %
}%

\newcommand{\fcObjectGetNumPatches}{%
\fcArrayToStack %
1 dict begin %
/HandlerNotFound true def %
HandlerNotFound{dup (surface) eq {pop \fcSurfaceGetNumPatches /HandlerNotFound false def} if} if %
HandlerNotFound{dup (curve) eq {pop \fcCurveInit 0 /HandlerNotFound false def} if} if %
HandlerNotFound{dup (triangle) eq {pop \fcTriangleInSceneInit 1 /HandlerNotFound false def} if} if %
HandlerNotFound{== (ERROR: OBJECT NUMBER OF PATCHES HANDLER NOT FOUND)} if %
end %
}%

\newcommand{\fcObjectComputePatchesAndContours}{%
\fcMarkClean exch
\fcArrayToStack %
1 dict begin %
/HandlerNotFound true def %
HandlerNotFound{dup (surface) eq {pop \fcSurfaceComputePatchesAndContours /HandlerNotFound false def} if} if %
HandlerNotFound{dup (curve) eq {pop \fcCurveComputeContour /HandlerNotFound false def} if} if %
HandlerNotFound{dup (triangle) eq {pop \fcTriangleComputePatchesAndContours /HandlerNotFound false def} if} if %
HandlerNotFound{== (ERROR: OBJECT PATCH-CONTOUR HANDLER NOT FOUND)} if %
end %
\fcMarkCleanCheck
}%

\newcommand{\fcZBufferBoundingBoxPatchContour}{ %
2 dict begin %
/theContour exch def %
/counter -1 def %
theContour length 1 sub { /counter counter 1 add def theContour counter get 0 get \fcZBufferBoundingBoxPoint}repeat %
end %
}

\newcommand{\fcCheckIsArray}{type (arraytype) eq\space}

\newcommand{\fcPaintPointForegroundData}{
20 dict begin %
gsave
/theNeighborhood exch def %
/thePoint theNeighborhood 0 get def %
(theNeighborhood:)==
theNeighborhood ==
thePoint \fcZBufferRowColumn
/column exch def
/row exch def
/theZBufferCurrent theZBuffer row get column get def
/counter 0 def
/numPatchesInNeighborhood 0 def %
theNeighborhood length 1 sub {
/counter counter 1 add def
1.8 setlinewidth
0.5 1 0.5 setrgbcolor
theNeighborhood counter get theZBufferCurrent \fcContains not
{3 setlinewidth 1 0 0 setrgbcolor
}if
theNeighborhood counter get \fcPatchPaintContourDirectly
theNeighborhood counter get type (arraytype) eq
{/numPatchesInNeighborhood numPatchesInNeighborhood 1 add def}if
}repeat
/counter -1 def
theZBufferCurrent length {
/counter counter 1 add def %
1.1 setlinewidth
1 0.7 0.7 setrgbcolor
thePoint thePatchCollection theZBufferCurrent counter get get \fcPointIsBehindOrInFrontOfPatch{true}
{1 0 0 setrgbcolor
}if
thePatchCollection theZBufferCurrent counter get get \fcPatchPaintContourDirectly
}repeat
thePoint \fcZBufferPaintCellContainingPoint %
[thePoint \fcCoordsIIIdToPStricks] theNeighborhood \fcIsInForeground
{\fcFullDotCode}{\fcHollowDotCode}ifelse %
0 0 0 setrgbcolor
(nsize: ) numPatchesInNeighborhood 20 string cvs \fcConcatenate [thePoint \fcCoordsIIIdToPStricks ] \fcTextCode
(bsize: ) theZBufferCurrent length 20 string cvs \fcConcatenate [thePoint \fcCoordsIIIdToPStricks 0.2 sub ] \fcTextCode
grestore
end
}

\newcommand{\fcZBufferRowColumnIsInvestigated}{
\fcZBufferRowColumnsUnderInvestigation\space column eq exch row eq and
}

\newcommand{\fcArrowHeadAndTailPlotCode}{
2 copy 
10 dict begin
/pointRight exch def
/pointLeft exch def
newpath %
pointLeft \fcCoordsPStricksToPS moveto %
pointRight \fcCoordsPStricksToPS lineto %
stroke %
end
\fcArrowHeadPlotCode
}

\makeatletter
\newcommand{\fcArrowHeadPlotCode}{
10 dict begin
/pointRight exch [ exch \fcCoordsPStricksToPS ] def
/pointLeft  exch [ exch \fcCoordsPStricksToPS ] def
 gsave
/directionVector [pointRight pointLeft \fcVectorMinusVector \fcArrayToStack] def
directionVector \fcVectorNorm 0 ne{
/directionVector directionVector \fcVectorNormalize def
}if
/xPS directionVector 0 get def
/yPS directionVector 1 get def
[yPS  xPS -1 mul  -1 xPS mul -1 yPS mul pointRight \fcArrayToStack] concat
%[1 0 0 1  pointRight 0 get \fcCoordsIIIdToPS ] concat
 newpath
 false 0.4 1.5 0.4 0.5 \tx@Arrow
 closepath
 stroke
 grestore
end
}
\makeatother

\newcommand{\fcPointOnContourGetVisibility}{
dup length 1 sub get\space
}

\newcommand{\fcContourGetUseArrows}{dup length 1 sub get 0 get\space}
\newcommand{\fcContourGetColor}    {dup length 1 sub get 1 get\space}
\newcommand{\fcContourGetWidth}    {dup length 1 sub get 2 get\space}
\newcommand{\fcContourGetDashes}   {dup length 1 sub get 3 get\space}
\newcommand{\fcContourGetLineStyle}{dup length 1 sub get 4 get\space}

\newcommand{\fcPaintContour}{ %
20 dict begin %
/theContour exch def %
theContour \fcContourGetLineStyle (none) ne{
/numSegments theContour length 2 sub def %
/counter -1 def %
/rightIsInForeground theContour 0 get \fcIsInForeground def %
/style (none) def %
/useArrows theContour \fcContourGetUseArrows def
/currentDashes {theContour \fcContourGetDashes \fcArrayToStack} def
theContour \fcContourGetWidth setlinewidthVirtual
theContour \fcContourGetColor \fcArrayToStack setrgbcolorVirtual
numSegments{ %
  /counter counter 1 add def %
  /pointLeft theContour counter get def %
  /pointRight theContour counter 1 add get def %
  /leftIsInForeground rightIsInForeground def %
  /rightIsInForeground pointRight \fcIsInForeground def %
  /leftIsVisible pointLeft \fcPointOnContourGetVisibility def %
  /rightIsVisible pointRight \fcPointOnContourGetVisibility def %
  /oldStyle style def %
  /style leftIsInForeground rightIsInForeground or {(normal)}{(dashed)}ifelse def %
  /setStyle {style (normal) eq{[] 0 setdashVirtual}{currentDashes setdashVirtual}ifelse } def
  leftIsVisible rightIsVisible and{
	counter 0 eq{newpathVirtual}if
    style oldStyle ne{strokeVirtual setStyle %
    newpathVirtual pointLeft 0 get \fcCoordsIIIdToPS movetoVirtual %
    }if %
    pointRight 0 get \fcCoordsIIIdToPS linetoVirtual
  }if
  leftIsVisible rightIsVisible not and{
    strokeVirtual
    /style (invisible) def
  }if
  leftIsVisible not rightIsVisible and{
    setStyle
    newpathVirtual pointRight 0 get \fcCoordsIIIdToPS movetoVirtual %
  }if
}repeat %
strokeVirtual %
useArrows{[] 0 setdashVirtual [pointLeft 0 get \fcCoordsIIIdToPStricks] [pointRight 0 get \fcCoordsIIIdToPStricks] plotArrowHeadVirtual}if %
}if %
end %
}

\newcommand{\fcCurveInit}{
/contourOptions exch def
/theCurve exch def %
/tMax exch def %
/tMin exch def %
/tIterations \fcPlotPoints\space def %
}

\newcommand{\fcCurveComputeContour}{
30 dict begin %
\fcCurveInit
/DeltaT tMax tMin sub tIterations div def %
/t tMin def %
theContourCollection numContoursComputedSoFar
[
tIterations { %
[theCurve true]
/t t DeltaT add def %
}repeat %
contourOptions
]
put
end %
}

\newcommand{\fcComputeSurfacePatch}{
/oldU u def %
/oldV v def %
/inBounds true def
[ %start of patch data structure
theSurface %(x(u,v), y(u,v), z(u,v))
theRestrictions not {/inBounds false def}if
/u u DeltaU add def %
theSurface %(x(u+Delta,v), y(u+Delta,v), z(u+Delta,v))
theRestrictions not {/inBounds false def}if
/u oldU def %
/v v DeltaV add def %
theSurface %(x(u,v+Delta), y(u,v+Delta), z(u,v+Delta))
theRestrictions not {/inBounds false def}if
/u u DeltaU add def %
theSurface %(x(u+Delta,v+Delta), y(u+Delta,v+Delta), z(u+Delta,v+Delta))
theRestrictions not {/inBounds false def}if
[
/u oldU def
/v oldV def
numContourUSegmentsPerPatch {theRestrictions{theSurface}if /u u DeltaDeltaU add def} repeat
/u oldU DeltaU add def
/v oldV def
numContourVSegmentsPerPatch {theRestrictions{theSurface}if /v v DeltaDeltaV add def} repeat
/v oldV DeltaV add def
numContourVSegmentsPerPatch {theRestrictions{theSurface}if /u u DeltaDeltaU sub def} repeat
/u oldU def
numContourVSegmentsPerPatch {theRestrictions{theSurface}if /v v DeltaDeltaV sub def} repeat
]
[colorUVpatch % front color of patch
colorVUpatch % back color of patch
forceForeground %
inBounds %
colorVUpatch %patch built-in contour color, used when drawing patch contour directly
false %is contour dashed independent of visibility?
[] %dashes not used
]
(patch) %
] %patch data structure complete
/u oldU def %
/v oldV def %
}

\newcommand{\fcSurfaceGetNumContours}{
30 dict begin
\fcSurfaceInit %
uIterations 1 add vIterations 1 add add
end
}

\newcommand{\fcSurfaceGetNumPatches}{
30 dict begin
\fcSurfaceInit %
uIterations vIterations mul
end
}

\newcommand{\fcSurfaceInit}{%
/contourOptions exch def%
/patchOptions exch def%
/forceForeground patchOptions 2 get def%
/colorUVpatch patchOptions 0 get def%
/colorVUpatch patchOptions 1 get def%
/vIterations exch def %
/uIterations exch def %
/theRestrictions exch def
/theSurface exch def %
/vMax exch def %
/uMax exch def %
/vMin exch def %
/uMin exch def %
}

\newcommand{\fcSurfaceComputePatchesAndContours}{%
30 dict begin %
{ %begin loop, used to simulate a jump instruction
%exiting the loop = jumping at loop end
\fcSurfaceInit
/u uMin def
/v vMin def
mark
theSurface type (arraytype) ne {(\string\n ERROR: surface must be an array. \string\n) print cleartomark exit}if cleartomark
\fcMarkClean
/DeltaU uMax uMin sub uIterations div def %
/DeltaV vMax vMin sub vIterations div def %
/getPatchIndex {exch vIterations mul add numPatchesComputedSoFar add} def
/accountPatch {getPatchIndex dup thePatchCollection exch get (empty) eq {thePatchCollection exch 3 -1 roll put}{pop pop}ifelse
} def
/numContourVSegmentsPerPatch \fcNumCountourSegmentsPatchV \space def
/numContourUSegmentsPerPatch \fcNumCountourSegmentsPatchU \space def
/DeltaDeltaV DeltaV numContourVSegmentsPerPatch div def %
/DeltaDeltaU DeltaU numContourUSegmentsPerPatch div def %
% % % % % % % % % % % % % % % % % % % % %
%process uv-contours
/u uMin def %
/counterU -1 def %
uIterations 1 add{ %
/counterU counterU 1 add def %
/counterV -1 def %
/v vMin def %
/patchLeftIndex (empty) def %
/patchRightIndex (empty) def %
[
vIterations { %
/counterV counterV 1 add def
/patchLeftBackIndex patchLeftIndex def %
/patchRightBackIndex patchRightIndex def %
/patchLeftIndex counterU uIterations lt
{\fcComputeSurfacePatch counterU counterV accountPatch counterU counterV getPatchIndex}
{(empty)}
ifelse def %
/patchRightIndex counterU 0 ne {counterU 1 sub counterV getPatchIndex}
{(empty)} ifelse def %
/vOld v def %
[theSurface patchLeftIndex patchRightIndex patchLeftBackIndex patchRightBackIndex theRestrictions]
numContourUSegmentsPerPatch 1 sub{/v v DeltaDeltaV add def [theSurface patchLeftIndex patchRightIndex theRestrictions]} repeat
/v vOld DeltaV add def %
}repeat %
[theSurface patchLeftIndex patchRightIndex theRestrictions]
contourOptions
]
/thePatchContour exch def %
%/contourIsUnderInvestigation \fcZBufferVparameterPointUnderInvestigation\space pop counterU eq def
%/indexPointUnderInvestigation
%\fcZBufferVparameterPointUnderInvestigation\space exch pop def
theContourCollection counterU numContoursComputedSoFar add thePatchContour put
/uOld u def %
/u u DeltaU add def %
} repeat %
% % % % % % % % % % % % % % % % % % % % %
%process vu-contours
/v vMin def %
/counterV -1 def %
vIterations 1 add{ %
  /counterV counterV 1 add def %
  /counterU -1 def
  /u uMin def %
  /patchLeftIndex (empty) def %
  /patchRightIndex (empty) def %
  [
  uIterations { %
  /counterU counterU 1 add def
  /patchLeftBackIndex patchLeftIndex def %
  /patchRightBackIndex patchRightIndex def %
  /patchLeftIndex counterV vIterations lt
  {counterU counterV getPatchIndex}
  {(empty)}
  ifelse
  def %
  /patchRightIndex counterV 0 ne {counterU counterV 1 sub getPatchIndex} {(empty)} ifelse def %
  /uOld u def %
  [theSurface patchLeftIndex patchRightIndex patchLeftBackIndex patchRightBackIndex theRestrictions]
  numContourVSegmentsPerPatch 1 sub{/u u DeltaDeltaU add def [theSurface patchLeftIndex patchRightIndex theRestrictions]} repeat
  /u uOld DeltaU add def %
  }repeat %
  [theSurface patchLeftIndex patchRightIndex theRestrictions]
  contourOptions
  ]
  /thePatchContour exch def %
  %/contourIsUnderInvestigation \fcZBufferUparameterPointUnderInvestigation\space pop counterV  eq def
  %/indexPointUnderInvestigation
  %\fcZBufferUparameterPointUnderInvestigation\space exch pop def
  theContourCollection uIterations 1 add counterV add numContoursComputedSoFar add thePatchContour put
  /vOld v def %
  /v v DeltaV add def %
} repeat %
\fcMarkCleanCheck
exit
}loop %this loop is used to simulate a jump instruction
end %
}%

\newcommand{\fcGetColorCode}[1]{%
2 dict begin%
/theColor {0 0 0} def%
/colorNotFound true def%
(#1) (black) eq (#1) (black ) eq or{/theColor {0 0 0} def /colorNotFound false def}if%
(#1) (white) eq (#1) (white ) eq or{/theColor {1 1 1} def /colorNotFound false def}if%
(#1) (red) eq (#1) (red ) eq or{/theColor {1 0 0} def /colorNotFound false def}if%
(#1) (blue) eq (#1) (blue ) eq or{/theColor {0 0 1} def /colorNotFound false def}if%
(#1) (green) eq (#1) (green ) eq or{/theColor {0 1 0} def /colorNotFound false def}if%
(#1) (brown) eq (#1) (brown ) eq or{/theColor {0.6484375 0.1640625 0.1640625} def /colorNotFound false def}if%
(#1) (orange) eq (#1) (orange ) eq or{/theColor {1 0.647058824 0} def /colorNotFound false def}if%
(#1) (cyan) eq (#1) (cyan ) eq or {/theColor {0 1 1} def /colorNotFound false def}if %
(#1) (pink) eq (#1) (pink ) eq or {/theColor {1 0.75390625 0.796875} def /colorNotFound false def}if %
(#1) (gray) eq (#1) (gray ) eq or {/theColor {0.5 0.5 0.5} def /colorNotFound false def}if %
colorNotFound{/theColor {#1} def}if %
theColor %
end%
}%

\newcommand{\fcLineIIIdInScene}[3][arrows=,]{%
\fcCurveIIIdInScene[#1]{0}{1}{#3 t \fcVectorTimesScalar #2 1 t sub \fcVectorTimesScalar \fcVectorPlusVector}%
}

%Format of curve: we store the curve in the format [tmin tmax [x y z] arrows red green blue (curve)]
%Example use: 
%\begin{pspicture}(-1,-1)(1,1)
%\fcStartIIIdScene
%\fcCurveIIIdInScene[linecolor=orange]{0}{1}{[t t sqrt 0 ]}
%\fcFinishIIIdScene[true]
%\end{pspicture}
\newcommand{\fcCurveIIIdInScene}[4][]{%
\setkeys{fcGraphics}{#1}%
\pstVerb{%
[theIIIdObjects \fcArrayToStack [#2\space #3{#4} \fcContourOptions (curve)] ]/theIIIdObjects exch def}%
}%

\newcommand{\fcSegmentCodeNoFirstPoint}{
5 dict begin
/right exch def
/left exch def
/Delta 1 \fcNumCountourSegmentsPatchU div def
/t Delta def
\fcNumCountourSegmentsPatchU {left 1 t sub \fcVectorTimesScalar right t \fcVectorTimesScalar \fcVectorPlusVector /t t Delta add def} repeat
end
}

\newcommand{\fcTriangleComputePatchesAndContours}{
25 dict begin
\fcTriangleInSceneInit
\fcMarkClean
/currentPatch
[ vertex0 vertex1 vertex2 vertex1 vertex2 \fcVectorPlusVector 0.5
\fcVectorTimesScalar
[ vertex0 dup vertex1 \fcSegmentCodeNoFirstPoint vertex1 vertex2 \fcSegmentCodeNoFirstPoint vertex2 vertex0 \fcSegmentCodeNoFirstPoint]
patchOptions (patch)
] def
/currentContour
[
currentPatch \fcPatchGetContour {[exch true]}forall
contourOptions
]
def
thePatchCollection numPatchesComputedSoFar currentPatch put
theContourCollection numContoursComputedSoFar currentContour put
\fcMarkCleanCheck
end
}

\newcommand{\fcTriangleInSceneInit}{
/contourOptions exch def
/patchOptions exch def
/vertex2 exch def
/vertex1 exch def
/vertex0 exch def
}

\newcommand{\fcBoxIIIdInScene}[5][]{%
\fcPatchInScene[#1]{#2}{#4}{#3}%
\fcPatchInScene[#1]{#2}{#5}{#4}%
\fcPatchInScene[#1]{#2}{#3}{#5}%
\fcPatchInScene[#1]{#3}{#3 #4 #2 \fcVectorMinusVector \fcVectorPlusVector}{#3 #5 #2 \fcVectorMinusVector \fcVectorPlusVector}%
\fcPatchInScene[#1]{#4}{#4 #5 #2 \fcVectorMinusVector \fcVectorPlusVector}{#4 #3 #2 \fcVectorMinusVector \fcVectorPlusVector}%
\fcPatchInScene[#1]{#5}{#5 #3 #2 \fcVectorMinusVector \fcVectorPlusVector}{#5 #4 #2 \fcVectorMinusVector \fcVectorPlusVector}%
}

%We give the patch by its corners v0, v1, v2.
\newcommand{\fcTriangleInScene}[4][]{%
\setkeys{fcGraphics}{#1}%
\pstVerb{%
/theIIIdObjects [theIIIdObjects \fcArrayToStack [#2\space #3\space #4\space \fcPatchOptions \fcContourOptions (triangle)] ] def%
}%
}

%Format of patch: we give the patch by its corners v0, v1, v2. The patch is spanned by v1-v0 and v2-v0
\newcommand{\fcPatchInScene}[4][]{%
\fcSurfaceInScene[#1, iterationsU=1, iterationsV=1]{0}{0}{1}{1}{%
3 dict begin %
/v0 #2\space def %
/t1 #3\space v0 \fcVectorMinusVector def %
/t2 #4\space v0 \fcVectorMinusVector def %
v0 %
t1 u \fcVectorTimesScalar %
t2 v \fcVectorTimesScalar %
\fcVectorPlusVector \fcVectorPlusVector %
end %
}{}%
}

%Format of surface: we store the surface in the format
%[umin vmin umax vmax
%[x(u,v) y(u,v) z(u,v)] %coordinate functions
% restrictions %boolean function in u,v, when the function evaluates to false the surface is not drawn. A great tool for cutting surfaces.
%uIterations vIterations   %number of curvilinear u,v-segments
%[red green blue] %color of patches whose u,v-side is visible
%[red green blue] %color of patches whose v,u-side is visible
%[red green blue] %color of contours
% foregroundstatus %true or false
%(surface)].
%Example:
%\begin{pspicture}
%\fcStartIIIdScene
%\fcSurfaceInScene[arrows=(none), linecolor=red]{0}{0}{1}{360}{[u u sqrt v cos mul u sqrt v sin mul]}{}
%\fcFinishIIIdScene[true]
%\end{pspicture}
\newcommand{\fcSurfaceInScene}[7][arrows=none]{%
\setkeys{fcGraphics}{#1}%
\pstVerb{%
[theIIIdObjects \fcArrayToStack [#2\space #3\space #4\space #5\space {#6} {#7} length 0 ne {{#7}}{{true}}ifelse \fcIterationsU\space \fcIterationsV%
\fcPatchOptions%
\fcContourOptions%
(surface)] ]/theIIIdObjects exch def}%
}%

\newcommand{\fcCurveIIIdNoSceneCode}{%
15 dict begin%
/theCurve exch def%
/tMax exch def%
/tMin exch def%
/numPoints \fcPlotPoints\space def%
/Delta tMax tMin sub numPoints 1 sub div def%
/t tMin def %
\fcLineFormatCode %
newpath %
theCurve \fcCoordsIIIdToPS moveto %
numPoints 1 sub {/t t Delta add def theCurve \fcCoordsIIIdToPS lineto } repeat %
stroke %
end %
}%

\newcommand{\fcZBufferBoundingBoxPolyline}{ %
{\fcZBufferBoundingBoxPoint} forall
}

\newcommand{\fcContains}{ %
%format: theElement theArray -> true if theElement is in the array, false else.
3 dict begin %
/theArray exch def %
/theElement exch def %
false %
/counter 0 def %
theArray length { %
theElement theArray counter get \fcAreEqual {pop true exit}if %
/counter counter 1 add def %
}repeat %
end %
}

\newcommand{\fcAreEqual}{ %
1 dict begin
/areEqual
{5 dict begin
/left exch def
/right exch def
left type  right type ne{false}
{ left type (arraytype) ne{ left right eq}
{ left length right length ne{false}
{ /counter 0 def %
true %
left length { left  counter get right counter get areEqual not{pop false exit }if /counter counter 1 add def }repeat
}ifelse
}ifelse
}ifelse
end
} def %
areEqual
end
}

\newcommand{\fcZBufferAccountPatchIndexAtXY}{ %
5 dict begin %
/currentArray theZBuffer row get column get def %
/counter 0 def %
thePatchIndex currentArray \fcContains not
{theZBuffer row get column [currentArray \fcArrayToStack thePatchIndex ] put}if
end %
}

\newcommand{\fcMergeSort}{
2 dict begin
/theArray exch def
/mergeSortStartIndexLength {
10 dict begin
/theLength exch def
/startIndex exch def
{ theLength 1 eq
  { [theArray startIndex get]
  	exit
  } if
  theLength 2 eq
  { theArray startIndex get theArray startIndex 1 add get
    LeftGreaterThanRight
    { [theArray startIndex 1 add get theArray startIndex get]
    }
    { [theArray startIndex get theArray startIndex 1 add get]
    } ifelse
    exit
  } if
  /leftLength theLength 2 div cvi def
  /rightLength theLength leftLength sub def
  /leftSorted startIndex leftLength mergeSortStartIndexLength def
  /rightSorted startIndex leftLength add rightLength mergeSortStartIndexLength def
  /counterLeft 0 def
  /counterRight 0 def
  [ theLength{
      counterLeft leftLength ge{
        /leftNext false def
      }{
        counterRight rightLength ge{
          /leftNext true def
        }{
          /leftNext leftSorted counterLeft get rightSorted counterRight get  LeftGreaterThanRight not def
        } ifelse
      } ifelse
      leftNext{
        leftSorted counterLeft get /counterLeft counterLeft 1 add def
      }{
        rightSorted counterRight get /counterRight counterRight 1 add def
      }ifelse
    } repeat
  ]
  exit
}loop
end
} def
theArray length 0 gt {
  0 theArray length mergeSortStartIndexLength
}{
  theArray
} ifelse
end
}

\newcommand{\fcBubbleSort}{
5 dict begin
/a exch def
/n a length 1 sub def
n 0 gt {
% at this point only the n+1 items in the bottom of a remain to be sorted
% the largest item in that block is to be moved up into position n
n {
0 1 n 1 sub {
/i exch def
a i get a i 1 add get LeftGreaterThanRight {
% if a[i] > a[i+1] swap a[i] and a[i+1]
a i 1 add
a i get
a i a i 1 add get
% set new a[i] = old a[i+1]
put
% set new a[i+1] = old a[i]
put
} if
} for
/n n 1 sub def
} repeat
} if
end
}

\newcommand{\fcGaussianElimination}{
15 dict begin
/theMatrix exch def
/numRows theMatrix length def
/numCols theMatrix 0 get length def
/rowIndex 0 def
/columnIndex -1 def
{ /columnIndex columnIndex 1 add def
  columnIndex numCols ge {exit}if
  /candidateIndex -1 def
  /counter rowIndex 1 sub def
  numRows rowIndex sub {
    /counter counter 1 add def
    theMatrix counter get columnIndex get 0 ne {/candidateIndex counter def exit}if
  }repeat
  candidateIndex -1 ne{
    /temp theMatrix rowIndex get def
    theMatrix rowIndex theMatrix candidateIndex get put
    theMatrix candidateIndex temp put
    /pivotRow theMatrix rowIndex get def
    /theCoeff 1 pivotRow columnIndex get div def
    /pivotRow pivotRow  theCoeff \fcVectorTimesScalar def
    theMatrix rowIndex pivotRow put
    /counter -1 def
    numRows {
      /counter counter 1 add def
      counter rowIndex ne{
      theMatrix counter get dup columnIndex get pivotRow exch \fcVectorTimesScalar \fcVectorMinusVector theMatrix exch counter exch put
      }if
    }repeat
    /rowIndex rowIndex 1 add def
  }if
  rowIndex numRows ge {exit}if
}loop
theMatrix
end\space
}

\newcommand{\fcLeftSegmentIsBehindSegmentsAreSkew}{
%Let l1 l2 be the endpoints of the left segment,
%r1, re - the endpoints of the right.
%Let pl1, pl2, pr1, pr2 denote the projections onto the viewing
%screen of the corresponding endpoints.
%Let
%(a,c) be the vector pl1-pl2
%(b,d) be the vector pr2-pr1
%(e,f) be the vector pr2-pl2
%We need to solve the system
%(a b) (s)= (e)
%(c d) (t)= (f)
%The determinant of the system must be non-zero, else the segments are non-skew.
% the projections of the segments intersect if 0 <= s<=1
% and 0<=t<=1.
%In that case the point on the left segment that projects onto the point of interest is s*l1 +(1-s)l2. The point on the right segment that projects onto the point of interest is t*r1 +(1-t)*r2
%
25 dict begin
\fcArrayToStack
/r1 exch def
/r2 exch def
\fcArrayToStack
/l1 exch def
/l2 exch def
/pr1 [r1 \fcCoordsIIIdToPStricks] def
/pr2 [r2 \fcCoordsIIIdToPStricks] def
/pl1 [l1 \fcCoordsIIIdToPStricks] def
/pl2 [l2 \fcCoordsIIIdToPStricks] def
pl1 pl2 \fcVectorMinusVector \fcArrayToStack
/c exch def
/a exch def
pr2 pr1 \fcVectorMinusVector \fcArrayToStack
/d exch def
/b exch def
pr2 pl2 \fcVectorMinusVector \fcArrayToStack
/f exch def
/e exch def
/theMatrix [[a b e][c d f]] \fcGaussianElimination def
/a theMatrix 0 get 0 get def
/d theMatrix 1 get 1 get def
/e theMatrix 0 get 2 get def
/f theMatrix 1 get 2 get def
a 0 eq d 0 eq or {false}{
/s e a div def
/t f d div def
s 0 gt s 1 lt t 0 gt t 1 lt and and and
{
/leftPoint l1 s \fcVectorTimesScalar l2 1 s sub \fcVectorTimesScalar \fcVectorPlusVector def
/rightPoint r1 t \fcVectorTimesScalar r2 1 t sub \fcVectorTimesScalar \fcVectorPlusVector def
leftPoint  \fcScreen\space pop \fcVectorScalarVector
rightPoint \fcScreen\space pop \fcVectorScalarVector
ge
}
{false}
ifelse
}ifelse
end
}

\newcommand{\fcLeftPatchIsBehind}{
2 dict begin
/rightIndex exch def
/leftIndex exch def
leftIndex rightIndex \fcLeftPatchIsBehindOrPatchesIntersect
{
rightIndex leftIndex \fcLeftPatchIsBehindOrPatchesIntersect not
}
{false}ifelse
end
}

\newcommand{\fcLeftPatchIsBehindOrPatchesIntersect}{
%this function compares two patches:
40 dict begin
/rightIndex exch def
/leftIndex exch def
/rightPatch thePatchCollection rightIndex get def
/leftPatch thePatchCollection leftIndex get def
rightPatch \fcPatchGetForcedForegroundStatus leftPatch \fcPatchGetForcedForegroundStatus not and {true}{
leftPatch \fcPatchGetForcedForegroundStatus rightPatch \fcPatchGetForcedForegroundStatus not and
{false}{
/result false def
{ leftPatch \fcPatchGetContour {rightPatch \fcPointIsBehindOrInFrontOfPatch{true} {/result true def exit}if }forall
result {exit}if
rightPatch \fcPatchGetContour {leftPatch \fcPointIsBehindOrInFrontOfPatch{false} {/result true def exit}if }forall
exit
}loop
result
}ifelse
}ifelse
end
}

\newcommand{\fcLeftPatchIsBehindOrPatchesIntersectOLDAndINCORRECT}{
%this function compares two patches:
40 dict begin
/rightIndex exch def
/leftIndex exch def
/rightPatch thePatchCollection rightIndex get def
/leftPatch thePatchCollection leftIndex get def
rightPatch \fcPatchGetForcedForegroundStatus leftPatch \fcPatchGetForcedForegroundStatus not and {true}{
leftPatch \fcPatchGetForcedForegroundStatus rightPatch \fcPatchGetForcedForegroundStatus not and
{false}{
/lv0 leftPatch \fcPatchGetvZero def
/lv1 leftPatch \fcPatchGetvOne def
/lv2 leftPatch \fcPatchGetvTwo def
/lv3 leftPatch \fcPatchGetvThree def
/rv0 rightPatch \fcPatchGetvZero def
/rv1 rightPatch \fcPatchGetvOne def
/rv2 rightPatch \fcPatchGetvTwo def
/rv3 rightPatch \fcPatchGetvThree def
/ls0 [lv0 lv1] def
/ls1 [lv1 lv3] def
/ls2 [lv2 lv3] def
/ls3 [lv0 lv2] def
/rs0 [rv0 rv1] def
/rs1 [rv1 rv3] def
/rs2 [rv2 rv3] def
/rs3 [rv0 rv2] def
/result false def
4 leftIndex eq  3 rightIndex eq and {(4 behind 3?) == }if
{ lv0 rightPatch \fcPointIsBehindOrInFrontOfPatch{true} {/result true def 4 leftIndex eq  3 rightIndex eq and {(4 IS behind 3 for vertex reasons) == }if exit }if
  lv1 rightPatch \fcPointIsBehindOrInFrontOfPatch{true} {/result true def 4 leftIndex eq 3 rightIndex eq and {(4 IS behind 3 for vertex reasons) == }if exit }if
  lv2 rightPatch \fcPointIsBehindOrInFrontOfPatch{true} {/result true def 4 leftIndex eq 3 rightIndex eq and {(4 IS behind 3 for vertex reasons) == }if exit }if
  lv3 rightPatch \fcPointIsBehindOrInFrontOfPatch{true} {/result true def 4 leftIndex eq 3 rightIndex eq and {(4 IS behind 3 for vertex reasons) == }if exit }if
  [ls0 ls1 ls2 ls3]
  { [rs0 rs1 rs2 rs3]
    {
    3 leftIndex eq  4 rightIndex eq and {(3 behind 4? 2nd) == pstack (STACK) ==}if
    %3 leftIndex eq  3 rightIndex eq and {(ere be i) == pstack }if
    %(printint stack) == pstack (printing stack done ) ==
      exch dup 3 -1 roll \fcLeftSegmentIsBehindSegmentsAreSkew{/result true def exit}if
    }forall
    pop
    result {exit}if
  }forall
  exit
}loop
3 leftIndex eq 4 rightIndex eq and {(and the 34 RESULT result is...) == result ==}if
result
}ifelse
}ifelse
end
}

\newcommand{\fcZBufferPaintPatches}{
10 dict begin
gsave
/row -1 def %
theZBuffer length{ %
/row row 1 add def %
/column -1 def %
theZBuffer row get length{ %
/column column 1 add def %
/currentZBuffer theZBuffer row get column get def %
currentZBuffer {\fcPaintPatchIndexFilledDirectly} forall %
} repeat%
}repeat %
grestore
end
}

\newcommand{\fcPatchGetNormal}{
1 dict begin
/thePatch exch def
thePatch \fcPatchGetvOne thePatch \fcPatchGetvZero \fcVectorMinusVector
thePatch \fcPatchGetvTwo thePatch \fcPatchGetvZero \fcVectorMinusVector
\fcVectorCrossVector
end
}

\newcommand{\fcPatchOptions}{%
[[\fcGetColorCode{\fcColorPatchUV}] [\fcGetColorCode{\fcColorPatchVU}] \fcForceForeground \space true [\fcGetColorCode{\fcColorLine}] ]%
}%

\newcommand{\fcPatchGetvZero}{0 get\space}
\newcommand{\fcPatchGetvOne}{1 get\space}
\newcommand{\fcPatchGetvTwo}{2 get\space}
\newcommand{\fcPatchGetvThree}{3 get \space}
\newcommand{\fcPatchGetContour}{4 get\space}
\newcommand{\fcPatchGetColorUV}{5 get 0 get \fcArrayToStack \space}
\newcommand{\fcPatchGetColorVU}{5 get 1 get \fcArrayToStack \space}
\newcommand{\fcPatchGetForcedForegroundStatus}{5 get 2 get\space}
\newcommand{\fcPatchGetInBounds}{5 get 3 get\space}
\newcommand{\fcPatchGetColorContour}{5 get 4 get \fcArrayToStack \space}
\newcommand{\fcPatchGetIsDashed}{5 get 5 get \space}
\newcommand{\fcPatchGetDashes}{5 get 6 get \fcArrayToStack \space}

\newcommand{\fcPaintPatchIndexFilledDirectly}{
thePatchCollection exch get \fcPatchPaintFilledDirectly
}

\newcommand{\fcPatchGetPoint}{
1 dict begin
/thePatch exch def %
thePatch \fcPatchGetvZero
thePatch \fcPatchGetvOne
thePatch \fcPatchGetvTwo
thePatch \fcPatchGetvThree
\fcVectorPlusVector
\fcVectorPlusVector
\fcVectorPlusVector
0.25 \fcVectorTimesScalar
end
}

\newcommand{\fcPatchPaintLabel}{
3 dict begin
/thePatch exch def
20 string cvs
/Times-Roman findfont
4 scalefont
setfont
newpath
thePatch \fcPatchGetPoint \fcCoordsIIIdToPS moveto
show
stroke
end
}

\newcommand{\fcPlotArrow}{
2 copy
exch
newpath
\fcCoordsIIIdToPS moveto
\fcCoordsIIIdToPS lineto
stroke
exch [ exch \fcCoordsIIIdToPStricks ] exch [exch \fcCoordsIIIdToPStricks ] plotArrowHeadVirtual
}


\newcommand{\fcPatchPaintNormal}{
1 dict begin
/thePatch exch def
2 setlinewidth
0 0 0 setrgbcolorVirtual
thePatch \fcPatchGetPoint
thePatch \fcPatchGetPoint thePatch \fcPatchGetNormal \fcVectorPlusVector
\fcPlotArrow
1 1 0 setrgbcolorVirtual
thePatch \fcPatchGetvZero
thePatch \fcPatchGetvOne
\fcPlotArrow
0 1 1 setrgbcolorVirtual
thePatch \fcPatchGetvZero
thePatch \fcPatchGetvTwo
\fcPlotArrow
end
}

\newcommand{\fcPatchPaintFilledDirectly}{
1 dict begin
/thePatch exch def %
thePatch type (arraytype) eq{
thePatch \fcPatchGetContour length 0 gt{
thePatch \fcPatchGetNormal \fcScreen\space pop \fcVectorScalarVector 0 gt
{ thePatch \fcPatchGetColorVU setrgbcolorVirtual }
{ thePatch \fcPatchGetColorUV setrgbcolorVirtual }
ifelse
0.5 setalpha
newpathVirtual
thePatch \fcPatchGetContour 0 get \fcCoordsIIIdToPS movetoVirtual
thePatch \fcPatchGetContour{\fcCoordsIIIdToPS linetoVirtual}forall
closepathVirtual
fillVirtual
strokeVirtual
%thePatch \fcPatchPaintNormal
}if
}if
end
}

\newcommand{\fcPatchPaintContourDirectly}{
1 dict begin
/thePatch exch def %
thePatch type (arraytype) eq{
thePatch \fcPatchGetIsDashed {thePatch \fcPatchGetDashes setdashVirtual}{[] 0 setdashVirtual}ifelse
thePatch \fcPatchGetContour length 0 gt{
thePatch \fcPatchGetColorContour setrgbcolorVirtual
newpathVirtual
thePatch \fcPatchGetContour 0 get \fcCoordsIIIdToPS movetoVirtual
thePatch \fcPatchGetContour{\fcCoordsIIIdToPS linetoVirtual}forall
closepathVirtual
strokeVirtual
}if
}if
end
}

\newcommand{\fcZBufferPatchIndex}{ %
15 dict begin %
/thePatchIndex exch def %
/thePatch thePatchCollection thePatchIndex get def
%thePatch \fcPatchPaintContourDirectly
/secondPoint thePatch \fcPatchGetvTwo def %
/firstPoint  thePatch \fcPatchGetvOne def %
/basePoint   thePatch \fcPatchGetvZero def %
/firstDirection firstPoint basePoint \fcVectorMinusVector def %
/secondDirection secondPoint basePoint \fcVectorMinusVector def %
/iterationsFirst [firstDirection \fcCoordsIIIdToPStricks\space pop getZBufferDeltaX div firstDirection \fcCoordsIIIdToPStricks\space exch pop getZBufferDeltaY div] \fcVectorNorm 2 mul 2 add round cvi def %
/iterationsSecond [secondDirection \fcCoordsIIIdToPStricks pop  getZBufferDeltaX div secondDirection \fcCoordsIIIdToPStricks exch pop getZBufferDeltaY div] \fcVectorNorm 2 mul 2 add round cvi def
/s 0 def %
iterationsFirst{ %
/firstComponent firstDirection s iterationsFirst 1 sub div  \space\fcVectorTimesScalar basePoint \fcVectorPlusVector def%
/t 0 def %
iterationsSecond{ %
secondDirection t iterationsSecond 1 sub div \fcVectorTimesScalar %
firstComponent \fcVectorPlusVector \fcZBufferRowColumn %
/column exch def %
/row exch def %
\fcZBufferAccountPatchIndexAtXY %
/t t 1 add def %
}repeat
/s s 1 add def %
}repeat
end %
}

\newcommand{\fcCurveIIId}[4][linecolor=\fcColorGraph]{%
\parametricplot[#1]{#2}{#3}{#4 \fcCoordsIIIdToPStricks}%
}

\newcommand{\fcZeroVector}{[exch {0} repeat]}

\newcommand{\fcPerpendicularComputeHeel}[3]{%
\pstVerb{%
7 dict begin%
/thePoint #1 def%
/heelSize #3 def %
mark #2 %
counttomark 1 eq {%
/directionUnitVector exch \fcVectorNormalize def%
/basePoint thePoint length \fcZeroVector def%
}{%
/basePoint exch def%
/directionUnitVector exch basePoint \fcVectorMinusVector \fcVectorNormalize def%
} ifelse %
pop%
/heel directionUnitVector thePoint basePoint \fcVectorMinusVector directionUnitVector \fcVectorScalarVector \fcVectorTimesScalar basePoint \fcVectorPlusVector def%
/perpendicularUnitVector thePoint heel \fcVectorMinusVector \fcVectorNormalize def %
/polyLineInput {%
heel directionUnitVector heelSize \fcVectorTimesScalar \fcVectorMinusVector %
dup perpendicularUnitVector heelSize \fcVectorTimesScalar \fcVectorPlusVector %
heel perpendicularUnitVector heelSize \fcVectorTimesScalar \fcVectorPlusVector%
} def%
}%
}

\newcommand{\fcPerpendicular}[4][ ]{%
\setkeys{fcGraphics}{#1}%
\fcPerpendicularComputeHeel{#2}{#3}{#4}%
\psline[#1](! thePoint \fcArrayToStack)(! heel \fcArrayToStack)%
\listplot[linecolor=\fcColorAngle, linewidth=\fcAngleLineWidth]{ [polyLineInput] {\fcArrayToStack} \fcSpliceArrayOperation \fcArrayToStack}%
\pstVerb{end}%
}

\newcommand{\fcPerpendicularIIId}[4][]{%
\fcPerpendicularComputeHeel{#2}{#3}{#4}%
\fcLineIIId[#1]{thePoint}{heel}%
\fcPolyLineIIId[linecolor=red]{polyLineInput}%
\pstVerb{end}%
}%

\newcommand{\fcPlotIIId}[7][]{%
\fcPlotIIIdXconst[#1]{#2}{#3}{#4}{#5}{#6}{#7}%
\fcPlotIIIdYconst[#1]{#2}{#3}{#4}{#5}{#6}{#7}%
}
\newcommand{\fcPlotIIIdXconst}[7][]{%
\setkeys{fcGraphics}{#2}%
\multido{\ra=0+1}{\fcIterationsX}{%
\pstVerb{%
3 dict begin %
/x \ra \space #3 mul \fcIterationsX \space \ra \space sub 1 sub  #5\space mul add \fcIterationsX\space 1 sub div def%
/ymin #4 def%
/ymax #6 def%
}%
\parametricplot[#1]{ymin}{ymax}{%
1 dict begin /y t def  [x y #7] \fcCoordsIIIdToPStricks end%
}%
\pstVerb{end}%
}%end multido
}

\newcommand{\fcPlotIIIdYconst}[7][]{%
\setkeys{fcGraphics}{#2}%
\multido{\ra=0+1}{\fcIterationsY}{%
\pstVerb{%
3 dict begin%
/y \ra \space #4 mul \fcIterationsY \space \ra \space sub 1 sub  #6\space mul add \fcIterationsY\space 1 sub div def%
/xmin #3 def%
/xmax #5 def%
}%
\parametricplot[#1]{xmin}{xmax}{%
1 dict begin /x t def  [x y #7] \fcCoordsIIIdToPStricks end%
}%
\pstVerb{end}%
}%end multido
}

\newcommand{\fcSurfaceIIIdUConst}[7][]{%
\setkeys{fcGraphics}{#2}%
\multido{\ra=0+1}{\fcIterationsX}{%
\pstVerb{%
3 dict begin%
/u \ra \space #3 mul \fcIterationsX \space \ra \space sub 1 sub  #5\space mul add \fcIterationsX\space 1 sub div def%
/vmin #4 def%
/vmax #6 def%
}%
\parametricplot[#1]{vmin}{vmax}{%
1 dict begin /v t def #7 \fcCoordsIIIdToPStricks end%
}%
\pstVerb{end}%
}%end multido
}

\newcommand{\fcSurfaceIIIdVConst}[7][]{%
\setkeys{fcGraphics}{#2}%
\multido{\ra=0+1}{\fcIterationsY}{%
\pstVerb{%
3 dict begin%
/v \ra \space #4 mul \fcIterationsY \space \ra \space sub 1 sub  #6\space mul add \fcIterationsY\space 1 sub div def%
/umin #3 def%
/umax #5 def%
}%
\parametricplot[#1]{umin}{umax}{%
1 dict begin /u t def #7 \fcCoordsIIIdToPStricks end%
}%
\pstVerb{end}%
}%end multido
}

\newcommand{\fcSurfaceDirectDraw}[7][]{%
\fcSurfaceIIIdUConst[#1]{#2}{#3}{#4}{#5}{#6}{#7}%
\fcSurfaceIIIdVConst[#1]{#2}{#3}{#4}{#5}{#6}{#7}%
}%

%Use: \fcVectorFieldCenteredArrow[options]{startX}{startY}{iterationsX}{iterationsY}{Delta}{y -x}
\newcommand{\fcVectorFieldCenteredArrow}[7][linecolor=blue]{%
\multido{\ra=#2+#6}{#4}{%
\multido{\rb=#3+#6}{#5}{%
\pstVerb{%
4 dict begin%
/x \ra\space def%
/y \rb\space def %
#7\space%
/vY exch def%
/vX exch def%
}%
\psline[#1](! x vX 2 div sub y vY 2 div sub)(! x vX 2 div add y vY 2 div add)%
\pscircle*[linecolor=red](! x y){0.02}%
\pstVerb{end}%
}%end multido
}%end multido
}%

%Use: \fcVectorField[options]{startX}{startY}{iterationsX}{iterationsY}{Delta}{y -x}
\newcommand{\fcVectorField}[7][linecolor=blue]{%
\setkeys{fcGraphics}{#1}%
\multido{\ra=#2+#6}{#4}{%
\multido{\rb=#3+#6}{#5}{%
\pstVerb{%
6 dict begin%
/x \ra\space def%
/y \rb\space def %
#7\space %
/vY exch def%
/vX exch def%
}%
\pscustom{%
\code{%
vX 0 ne vY 0 ne or{
\fcLineFormatCode
[x y] [x vX add y vY add] \fcArrowHeadAndTailPlotCode
}if%
}%
}%
\pscircle*[linecolor=red](! x y){0.02}%
\pstVerb{end}%
}%end multido
}%end multido
}%

%example 
\newcommand{\fcImplicitIId}[8][]{%
%\fcGrid[#1, linestyle=dashed]{#2}{#3}{#4}{#5}{#6}{#7}{0}%
\setkeys{fcGraphics}{#1}%
\pscustom{%
\code{%
40 dict begin
\fcSetUpGraphicsToScreen
/graphicsFileName (graphicsCacheSafeToDelete) (#1 #2 #3 #4 #5 #6 #7 #8) \fcHashString (.txt) 3 \fcConcatenateMultiple def
\fcSetupFilesGraphicsNameAlreadyDefined
graphicsCached not {
/theEquation {#8} \space def
/startX #2\space def
/startY #3\space def
/iterationsX #4\space def
/iterationsY #5\space def
/DeltaX #6\space def
/DeltaY #7\space def
/interpolate {20 dict begin 
/rightPt exch def
/leftPt exch def
/rightVal rightPt \fcArrayToStack /y exch def /x exch def theEquation def
/leftVal leftPt \fcArrayToStack /y exch def /x exch def theEquation def
leftVal 0 eq rightVal 0 eq and{leftVal}{
leftVal rightVal mul 0 le{
leftVal 0 lt {/leftVal leftVal -1 mul def}if
rightVal 0 lt {/rightVal rightVal -1 mul def}if
%leftPt  leftVal  rightVal leftVal add div \fcVectorTimesScalar
%rightPt rightVal rightVal leftVal add div \fcVectorTimesScalar
%\fcVectorPlusVector
leftPt 0.5 \fcVectorTimesScalar
rightPt 0.5 \fcVectorTimesScalar
\fcVectorPlusVector
}if
}ifelse
end}
def
/processOneTriangle {
20 dict begin
/firstV exch def
/secondV exch def
/thirdV exch def
firstV secondV interpolate
secondV thirdV interpolate
thirdV firstV interpolate
end
} def
%%%%%%%%%%%%%%%%%%%just the grid
\fcShowGridImplicitIId {
[1 1] 0 setdashVirtual
0.5 setlinewidthVirtual
0 0 0 setrgbcolorVirtual
/counterX -1 def
iterationsX {
/counterX counterX 1 add def
/counterY -1 def
iterationsY {
/counterY counterY 1 add def
%
/BottomLeft [startX DeltaX counterX mul add startY DeltaY counterY mul add] def
/BottomRight [startX DeltaX counterX 1 add mul add startY DeltaY counterY mul add] def
/TopLeft [startX DeltaX counterX mul add startY DeltaY counterY 1 add mul add] def
/TopRight [startX DeltaX counterX 1 add mul add startY DeltaY counterY 1 add mul add] def
newpathVirtual 
BottomLeft \fcCoordsPStricksToPS  movetoVirtual
BottomRight \fcCoordsPStricksToPS linetoVirtual
TopRight \fcCoordsPStricksToPS linetoVirtual
BottomLeft \fcCoordsPStricksToPS linetoVirtual
TopLeft \fcCoordsPStricksToPS linetoVirtual
TopRight \fcCoordsPStricksToPS linetoVirtual
strokeVirtual
}repeat
}repeat
}if
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\fcLineFormatCodeVirtual
/counterX -1 def
iterationsX {
/counterX counterX 1 add def
/counterY -1 def
iterationsY {
/counterY counterY 1 add def
%
/BottomLeft [startX DeltaX counterX mul add startY DeltaY counterY mul add] def
/BottomRight [startX DeltaX counterX 1 add mul add startY DeltaY counterY mul add] def
/TopLeft [startX DeltaX counterX mul add startY DeltaY counterY 1 add mul add] def
/TopRight [startX DeltaX counterX 1 add mul add startY DeltaY counterY 1 add mul add] def
/firstPair  [BottomLeft BottomRight TopRight processOneTriangle ] def
/secondPair [BottomLeft TopRight    TopLeft  processOneTriangle ] def
firstPair length 2 eq 
{newpathVirtual 
firstPair 0 get \fcCoordsPStricksToPS movetoVirtual
firstPair 1 get \fcCoordsPStricksToPS linetoVirtual
strokeVirtual
}if
secondPair length 2 eq 
{newpathVirtual 
secondPair 0 get \fcCoordsPStricksToPS movetoVirtual
secondPair 1 get \fcCoordsPStricksToPS linetoVirtual
strokeVirtual
}if
}repeat
}repeat
}if
end
}}%
}%

%example \fcGrid{-2}{-2}{4}{4}{1}{1}{} 
%Arguments in order of appearance: 
% [options] 
%xStart yStart numIntervalsX numIntervalsY DeltaX DeltaY Stickypiece
%Stickypiece is optional, leave at 0 or empty if you don't care about it.
%Stickypiece adds a shift within the grid.
\newcommand{\fcGrid}[8][]{%
\setkeys{fcGraphics}{#1}%
\pscustom{%
\code{%
20 dict begin
/startX #2\space def
/startY #3\space def
/iterationsX #4\space def
/iterationsY #5\space def
/DeltaX #6\space def
/DeltaY #7\space def
/stickyPiece (#8) () eq (#8) ( ) eq or {0}{#8}ifelse def
\fcLineFormatCode 
/counterX -1 def
iterationsX 1 add{
/counterX counterX 1 add def
/currentX1 counterX DeltaX mul startX add def
/currentY1 0        stickyPiece sub DeltaY mul startY add def
/currentY2 iterationsY stickyPiece add DeltaY mul startY add def
/currentX2 currentX1 def
newpath 
[currentX1 currentY1] \fcCoordsPStricksToPS moveto
[currentX2 currentY2] \fcCoordsPStricksToPS lineto
stroke
} repeat
/counterY -1 def
iterationsY 1 add{
/counterY counterY 1 add def
/currentX1 0        stickyPiece sub DeltaX mul startX add def
/currentY1 counterY DeltaY mul startY add def
/currentY2 currentY1 def
/currentX2 iterationsX stickyPiece add DeltaX mul startX add def
newpath 
[currentX1 currentY1] \fcCoordsPStricksToPS moveto
[currentX2 currentY2] \fcCoordsPStricksToPS lineto
stroke
} repeat
end
}%
}%
}

\newcommand{\fcVectorFieldAlongSurfaceInScene}[8][ ]{%
\setkeys{fcGraphics}{#1}%
\fcSurfaceInScene[#1]{#2}{#3}{#4}{#5}{#6}{#7}%
\pstVerb{%
/theIIIdObjects [theIIIdObjects \fcArrayToStack 
30 dict begin
/theField {#8} def
/theSurfaceObject exch def
theSurfaceObject \fcArrayToStack pop \fcSurfaceInit
/DeltaU uMax uMin sub uIterations div def
/DeltaV vMax vMin sub vIterations div def
/counterU -1 def %
uIterations{
/counterU counterU 1 add def
/counterV -1 def %
vIterations{
/counterV counterV 1 add def
/u DeltaU counterU 0.5 add mul uMin add def
/v DeltaV counterV 0.5 add mul vMin add def
/lineStart theSurface def
/lineEnd theSurface theField \fcVectorPlusVector def
[0 1 [lineEnd lineStart {1 t sub \fcVectorTimesScalar exch t \fcVectorTimesScalar \fcVectorPlusVector} \fcArrayToStack] cvx \fcContourOptions (curve)]
}repeat
}repeat
end
] def
}%
}